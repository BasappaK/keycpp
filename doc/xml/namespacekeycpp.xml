<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3.1">
  <compounddef id="namespacekeycpp" kind="namespace">
    <compoundname>keycpp</compoundname>
    <innerclass refid="classkeycpp_1_1_figure_exception" prot="public">keycpp::FigureException</innerclass>
    <innerclass refid="classkeycpp_1_1_plots" prot="public">keycpp::Plots</innerclass>
    <innerclass refid="classkeycpp_1_1_figure" prot="public">keycpp::Figure</innerclass>
    <innerclass refid="classkeycpp_1_1_key_cpp_exception" prot="public">keycpp::KeyCppException</innerclass>
    <innerclass refid="structkeycpp_1_1observe" prot="public">keycpp::observe</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___matrix" prot="public">keycpp::Sort_Matrix</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___vector" prot="public">keycpp::Sort_Vector</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__find__type" prot="public">keycpp::matrix_find_type</innerclass>
    <innerclass refid="structkeycpp_1_1_s_v_d__type" prot="public">keycpp::SVD_type</innerclass>
    <innerclass refid="structkeycpp_1_1tictoc__type" prot="public">keycpp::tictoc_type</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__size__type" prot="public">keycpp::matrix_size_type</innerclass>
    <innerclass refid="classkeycpp_1_1_matrix_exception" prot="public">keycpp::MatrixException</innerclass>
    <innerclass refid="classkeycpp_1_1vector__ref" prot="public">keycpp::vector_ref</innerclass>
    <innerclass refid="classkeycpp_1_1matrix" prot="public">keycpp::matrix</innerclass>
    <innerclass refid="classkeycpp_1_1_spline_exception" prot="public">keycpp::SplineException</innerclass>
    <innerclass refid="classkeycpp_1_1_extrap" prot="public">keycpp::Extrap</innerclass>
    <innerclass refid="classkeycpp_1_1_spline" prot="public">keycpp::Spline</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacekeycpp_1aa6ed5914a3c4b05e1e137fc9735e3ed5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt; T &gt; keycpp::real</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>real</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="31" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="388" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61efb014b42cd8b02a81b4520c41ab2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::real</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>real</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="32" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="393" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af7a0afaf26071f5f60ff1c11a2f9a2a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>imag</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="33" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="398" bodyend="401"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad902a14fdaa4b744a8a11220f5be0161" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>imag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="34" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="403" bodyend="406"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a27940c7f9c645f75b8feb3991f23b545" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="714" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="713" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad033c29d2245437a52140ff3c46fa1d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1, std::string property2, double val2)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="719" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="718" bodyend="721"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acfb9f560ec3a131190f23bf18c12b2f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt;&gt; y, std::string arguments, double val, double lw, double ps, std::string legend_entry)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>arguments</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lw</declname>
        </param>
        <param>
          <type>double</type>
          <declname>ps</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>legend_entry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="724" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="723" bodyend="726"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e50932cc54f92bdd7e38c6438f4f1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::ddot_</definition>
        <argsstring>(const int *N, const double *a, const int *inca, const double *b, const int *incb)</argsstring>
        <name>ddot_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2ce99b4fe4a13b9c70ada81761eb0ca2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zdotu_</definition>
        <argsstring>(std::complex&lt; double &gt; *result, const int *N, const std::complex&lt; double &gt; *a, const int *inca, const std::complex&lt; double &gt; *b, const int *incb)</argsstring>
        <name>zdotu_</name>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="48"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae99c5b242a21ba683701ccb6ab6534b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::daxpy_</definition>
        <argsstring>(const int *N, const double *alpha, const double *x, const int *incx, double *y, const int *incy)</argsstring>
        <name>daxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="51"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6460fa334239dde761d8f737b9438fed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zaxpy_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, const std::complex&lt; double &gt; *x, const int *incx, std::complex&lt; double &gt; *y, const int *incy)</argsstring>
        <name>zaxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d249dd978770119c1b91d88009fefbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dscal_</definition>
        <argsstring>(const int *N, const double *alpha, double *x, const int *incx)</argsstring>
        <name>dscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="57"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad9dd69d0d355e4805a832813199f1dff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zscal_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *x, const int *incx)</argsstring>
        <name>zscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="60"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ace2501951ab3db3a91c3520ae89750b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zggev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zggev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex generalized eigenvalue solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="67"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aebc5253e80ac15a9bfdc5449ae4f972a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgeev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</argsstring>
        <name>dgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wi</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c1cca2a162f40fc6c6218c35cadf9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgeev_</definition>
        <argsstring>(const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>w</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VL</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VR</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="77"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aca3be6524e195662cbb74a810305e721" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgecon_</definition>
        <argsstring>(const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</argsstring>
        <name>dgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>iwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a75e334ffaf1864d7191e9e0b64189783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrf_</definition>
        <argsstring>(const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>dgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="86"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab9c33788a2c083aa5738eda1fe62a261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</argsstring>
        <name>dgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="90"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4507ef954be960fec70ca0f93258d730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::dlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</argsstring>
        <name>dlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="94"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a444e3cdc7e7929414370b6b50ea1218c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgecon_</definition>
        <argsstring>(const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</argsstring>
        <name>zgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex-valued reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="99"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18d58d53d8e19a37d74d24da27a64dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrf_</definition>
        <argsstring>(const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>zgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="103"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abbe4322276dcdb7d864e85854b5b90f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</argsstring>
        <name>zgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="107"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1477c910b07baef984fe8528c29b2774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::zlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</argsstring>
        <name>zlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="111"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a12719f4b48de048f9642066666a920bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesv_</definition>
        <argsstring>(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</argsstring>
        <name>dgesv_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision linear system solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="115"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af92d0d887ae48cc4222f7167232a7f82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetri_</definition>
        <argsstring>(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</argsstring>
        <name>dgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4190e125fe33133aafa586089ca6e174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetri_</definition>
        <argsstring>(const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</argsstring>
        <name>zgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="122"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8fe7a71afbb6c5dc049cdd7afff6c0af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</argsstring>
        <name>dgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="127"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa5e2f74110f53bd288c15ce1f183f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="132"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61795f58aa135cfa0ebb4325f52f9de6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, const matrix&lt; std::complex&lt; double &gt; &gt; &amp;B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="138"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4262bb0ca13c9c1e11732b9b1dab65c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="142"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e462b40dbbb92e5ebef12956d76e1f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="146"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3905cfc35dbd146f5dbf7bcb5729c2c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="148" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="253" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d9a9dd04453e5a417f7a9eb8ae4391b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="149" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="300" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9f68b3d9143ad3582e59dd0a4b1998b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="151"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a46f4a25648e5bad1cf0bd0e7fca7fae0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt; double &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="153" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="437" bodyend="523"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adc96927cda2df7a6e8e2031941c43601" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="154" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="525" bodyend="595"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b74369f5415c3ed45f63995149ad992" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef5c1f5951e8182a7c4ec9612f3f7e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rand</definition>
        <argsstring>()</argsstring>
        <name>rand</name>
        <briefdescription>
<para>Returns a random double between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="157" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="10" bodyend="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5c6c79ad914131dfc2b0ae22c6d5017" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an N x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="158" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="17" bodyend="29"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a259b4e27cc4ec4d79d27688fdafcf2ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an M x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="159" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="33" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae90693acdaf666bd23bf861f2c0d28c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="163" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="162" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1122e5d4ae4b58fc150352b5d38d2cdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="177" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="176" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3a1ba458353cfecef659b40e446baaf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="188" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="187" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad7d9f15708903bc3f2c6d26693b8872d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="202" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="201" bodyend="209"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5afc215befa38bf47fb52cff33794ebe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="213" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="212" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad33e9ccd4e31c7c63d31af13d44312e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="227" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="226" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae14b016d01024e738c3110299ee58666" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="238" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="237" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7f22b23749bd8423cf52448a34280ba4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="252" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="251" bodyend="259"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e8bada51586c0561e1b32ca1ab5f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="278" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="277" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a300d8f6e8992c7b33156492d884bd621" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="292" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="291" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5823fd4b932039262a1eddb2f4f47299" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::prod</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;x)</argsstring>
        <name>prod</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns the product of all the elements of the vector x. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="304" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="303" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9ff26fd7007c28ea88b3ad7cdf90546c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::prod</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a vector containing the product of all the elements in each column of the matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="322" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="321" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae67644e3e1031773d6bfdb1ebb7d88e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>diff</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns a vector of differences between adjacent elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="343" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="342" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abb4e57814fd30b7b8d4845bbc16c73e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of row differences between adjacent rows. </para>        </briefdescription>
        <detaileddescription>
<para>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="362" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="361" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4c2e92e1abe266ccc6735d443c228a97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>conj</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="379" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="378" bodyend="381"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0f000b392fbefccdb089383bb6a20151" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="384" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="383" bodyend="386"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab02a8494963dd9566a978221434d9366" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="409" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="408" bodyend="411"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acce9304ff511ac2e50ad3016045f22f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="414" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="413" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1f83b48bfedf753904dfea9dde554a4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="419" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="418" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae0edec63f48a81c576da0c0ffc768af9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="424" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="423" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a952e5296774667c3be4e792b5cd980da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const double &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="429" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="428" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8faa7912f1f198c5185cb6a36cfd2fb2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="434" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="433" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4da6882977b2262f8d6f080b0eaf60c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="439" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="438" bodyend="454"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa299ed6dd4f0a895be84e9e0076ba96e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="458" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="457" bodyend="472"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a98ef889b03caf6eef0e989b2dcd2e5f6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="476" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="475" bodyend="490"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1c1cd804c6f704b7a9124a9d9a82c325" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="493" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="492" bodyend="500"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad4df2f7feaefed6813ecfe11e37087ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const std::vector&lt; T &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="503" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="502" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adff86e062c6497110b7505b0ef715c2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="513" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="512" bodyend="523"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b4a64905c9d681c174b2dfcfba272c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="526" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="525" bodyend="536"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af66a177fcb4f0ec1f260fdb39069fc29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="541" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="540" bodyend="548"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9a99d5b9548a160a11ed713b85038871" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const std::vector&lt; T &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="551" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="550" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71a8f2ebc458f06e29b17ecc28ed000d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="561" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="560" bodyend="571"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bc853f9410d964ef9f163ce53ea4828" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="574" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="573" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab185edce957f4afd65cb641ec6307376" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="587" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="586" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacbc330eb0eaccf5df2b35f425a15564" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="606" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="605" bodyend="620"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acadf89ed5e860edb0e17cc606c233a9a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="624" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="623" bodyend="638"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d5dbf37b71d16d686dd0fdbad82f8fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="641" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="640" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae187563f8f86e256bc1394edcba1b2b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;A, const T &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="654" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="653" bodyend="664"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6dcf10b0db68d53d126803e8d6d591fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="667" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="666" bodyend="696"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b523ff3dd5abac240788f6efb2e554e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="699" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="698" bodyend="706"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7597ecfbaa85ebc27a72c6fb1af00b60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const double &amp;a, const std::vector&lt; double &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="710" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="709" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a18334ab0064b1d634182170898bf975c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="719" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="718" bodyend="724"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2e9a06b12f7df18005a3daa3c051b2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="727" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="726" bodyend="734"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2dec8480e0274e4e6a2659f8a8f3e942" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="738" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="737" bodyend="743"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a30b05b16a4e69d253281e8568c101e16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="747" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="746" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac2665554c04ea23aad98e77d1618ca6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="755" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="754" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adad4206f801320c785980b9ed743e2da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="766" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="765" bodyend="772"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2184c8432cf367ca33a284adec8ac68c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="776" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="775" bodyend="782"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a390125160a7febd08d5c30629f4f698f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="785" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="784" bodyend="795"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7825f94b7be431bab5e5c99f8d7a1b54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="798" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="797" bodyend="801"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5b10f703c72875b9f5e2ecc5c7696f9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="804" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="803" bodyend="814"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3852c35cfcc8caa784465a26d04c68a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="817" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="816" bodyend="827"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a394f23f09cf122a8e8c20a7afd40f58e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="830" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="829" bodyend="837"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aec485bbc5951a7ea82206c5f401412aa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::operator/</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="841" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="840" bodyend="847"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa6089577ac7b51e05fb96725fbada7ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::operator/</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="851" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="850" bodyend="857"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aafc0089bdf204385c1e627755c5070b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="860" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="859" bodyend="870"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d18510a87d417d5c38f24ded26a8cee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="873" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="872" bodyend="880"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a60d3f3c9d269e14b23609d754684cdcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="886" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="885" bodyend="888"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a56636d37802b9237f0e09690307cacef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="893" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="892" bodyend="895"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d66a7287374d8e1e685538e0363101e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="901" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="900" bodyend="903"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0dd3aac5066a4d3e2c7108b26c554605" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="908" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="907" bodyend="910"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9b3d958e47ae678b0818a166d5a75883" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="916" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="915" bodyend="918"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a51d6592d124735f2377e1a2c43985b94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="923" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="922" bodyend="925"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b8f8e6c241ddcb678acf54c03a89b08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="931" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="930" bodyend="933"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abc28105b536bc99365073d7cbe0f9910" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cos of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="938" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="937" bodyend="940"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1fbb76498765f30f7a95c80ce7491d28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="946" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="945" bodyend="948"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae4fe8a3edd9841d208cc044f79d48ae2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="953" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="952" bodyend="955"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6a91266a8d14f0ae2de1d3e098d05e41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="961" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="960" bodyend="963"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa8cf9e0ed2f49b902c93be19ea6ef147" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="968" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="967" bodyend="970"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a08fac66d81dbcfce4d57bd08b3810dbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="976" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="975" bodyend="978"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a01c85865832f197d01d4f332121bc018" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="983" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="982" bodyend="985"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a88bedf42ff19672e0ddff3c5547d28d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="991" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="990" bodyend="993"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acf579fcfa75e569f491946af9e09ba34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="998" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="997" bodyend="1000"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac038300a49474532929f16d892349ab6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1006" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1005" bodyend="1008"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aba2b31e627ef6a9d04239fa435d81e9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1013" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1012" bodyend="1015"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad1781a15fc7aa5de38db6e4eb92c9e22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1021" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1020" bodyend="1023"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8bb201db3ca1ccd6eca8fd7395f17539" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1028" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1027" bodyend="1030"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a50caa1bee883d40591442882e777a67b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1036" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1035" bodyend="1038"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a66a68550626786b480e7c8d02aaf9039" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1043" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1042" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6a8bd2143a6d613b560f71d0b99b346f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1051" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1050" bodyend="1053"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6cc8180fd2f17512f0f75957615da294" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1058" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1057" bodyend="1060"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a95843ef0a09d799d8b62eb7b91e9c02f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1066" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1065" bodyend="1068"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8239f43008337eeab762bc1c7414e735" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::log</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1073" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1072" bodyend="1075"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aba78d97ea38234b858fffc97b05e6925" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1081" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1080" bodyend="1083"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab1c65fb4ee4ceaf869361f4fb6fef3dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1088" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1087" bodyend="1090"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afb93c1aed2037f957fa113994d7239ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1096" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1095" bodyend="1098"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3042ac961c7bffb3c315f41f175c5760" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1103" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1102" bodyend="1105"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3ea3b5f6f548e122d29e4571e15307fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1111" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1110" bodyend="1113"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1b6529b56bdc13937f058879d0f5881d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1118" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1117" bodyend="1120"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a24d916a516c57aad0e383ce29a50b963" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1126" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1125" bodyend="1128"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8677ad8b7dc8485540330a632cb82994" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1133" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1132" bodyend="1135"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2955a17019e584c29d9cce73ea572adc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1141" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1140" bodyend="1143"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab542118d6ab4772a4f100df097f7d55d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1148" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1147" bodyend="1150"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e9303ca44f49ec926854e6ad9506050" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1156" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1155" bodyend="1158"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e6c724d2e4067f9ae5fd3098da74bf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1163" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1162" bodyend="1165"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4ce9f002c4f3db2000a5c8d3a38f3ca5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1171" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1170" bodyend="1173"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abe9f54061aba34fe730de8c35d68f9fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1178" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1177" bodyend="1180"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8ae33fb19a521ab1ec1f22e7c39ca076" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eye</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>eye</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1183" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1182" bodyend="1191"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2824156817719ffe96a842dd0ef27ae5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;dim)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements along dimension dim. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements along dimension dim. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer value of the number of elements along the desired dimension. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1202" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1201" bodyend="1204"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae713df143a5e71da166f450e01a536e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref></type>
        <definition>matrix_size_type keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the size of matrix A. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the size of matrix A in a <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable containing the number of rows and cols. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1214" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1213" bodyend="1219"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5699c522088657287bf0ac01173b716c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1229" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1228" bodyend="1232"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9a0f013931cb9989320b014d151cc527" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1241" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1240" bodyend="1244"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a388f91a0ccf34978ef9403ccd0c680bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1254" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1253" bodyend="1264"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a831e69a9395f6dfe9e02af46e8b4273b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1273" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1272" bodyend="1280"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bb3ea9a842383b82c889179f25be9ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::initializer_list&lt; T &gt; &amp;</type>
          <declname>lst</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1283" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1282" bodyend="1310"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a400213b20d0dc5e0b31b1bf49f191f11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1313" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1312" bodyend="1337"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac8468ea36d1466ddeda8c64b9f46f8dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1340" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1339" bodyend="1385"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab56165975dd12a86b498134da71bde29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1388" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1387" bodyend="1404"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab7a41247c257a0244dd45c849a0ec3d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1407" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1406" bodyend="1420"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac1ff99e34619478096c271b38df1f3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1428" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1427" bodyend="1446"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90d5fd4f9f7c52f16425105995655e9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>times</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1454" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1453" bodyend="1469"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacd37d195541b2313b753b6e8839f916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs right array division on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1477" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1476" bodyend="1495"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af234cd07a4e1d649629a6b83dbe113ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs right array division on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1503" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1502" bodyend="1518"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac57d32902cba2c399475015235aeccec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Performs left array division on matrices B and A. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1526" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1525" bodyend="1544"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a86bc7e25833cdf9266c038a4edb0ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Performs left array division on vectors v2 and v1. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1552" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1551" bodyend="1567"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a87f2917e6a7c8e20d010aea0d8480668" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::sign</definition>
        <argsstring>(const T &amp;val)</argsstring>
        <name>sign</name>
        <param>
          <type>const T &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1570" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1569" bodyend="1572"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aaa2e17334911e8a447a5ef6c0cc54c3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::angle</definition>
        <argsstring>(const std::complex&lt; T &gt; &amp;x)</argsstring>
        <name>angle</name>
        <param>
          <type>const std::complex&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1575" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1574" bodyend="1577"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9aed8b7c5c058bda28186010d2f3833f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>angle</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1581" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1580" bodyend="1583"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af0c9c769d613f7526406ecf3b3351d89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>angle</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1587" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1586" bodyend="1589"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a646c5e616337a8174bd39ce729e53612" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::max</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1592" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1591" bodyend="1604"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a35292f7ead7b19a2fc098f50f0147ce6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::max</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1607" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1606" bodyend="1621"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af7ff5485352bd4412d18050843809d42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::max</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1624" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1623" bodyend="1631"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a28171fa81d0f537dd058e63164410b43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::min</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1634" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1633" bodyend="1646"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa0241416e190842fd0c352a6c94c57c3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::min</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1649" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1648" bodyend="1663"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a33adfcd8368c2f96891ca3e27fd8affe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::min</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1667" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1666" bodyend="1674"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7fd5ce0385e9cc7bed5b44ed8475e8aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>transpose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1679" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1678" bodyend="1689"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0a72326529750cf63cf05afa6fa15a65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>transpose</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1694" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1693" bodyend="1701"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14503c0419f365433d88fa081d473210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1706" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1705" bodyend="1716"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9fc1e2c9bf6ee79ee28a6f25b7b55b23" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::ctranspose&lt; double &gt;</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>ctranspose&lt; double &gt;</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1721" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1720" bodyend="1723"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad276b8edd0f4f62b430620047245d18d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1728" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1727" bodyend="1735"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a053c56f068ffe8c4a32e5a820b424b6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::sum</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>sum</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the sum of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1740" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1739" bodyend="1747"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a778b050929a9f5cea9136df5d8bfe2d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sum</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the sum of each column of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1752" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1751" bodyend="1759"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a966268670bc3e3b4f7107b8278e9b399" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::mat2vec</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>mat2vec</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Converts matrix A to a column vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1764" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1763" bodyend="1775"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4876140bc1dc01b4488c1bb2bba08940" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::vec2mat</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>vec2mat</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Converts a column vector to a 1 x length(v1) matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1780" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1779" bodyend="1791"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4e8769de1f22713d3564350d53125b26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::linspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const int &amp;N)</argsstring>
        <name>linspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between x1 and x2. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N equally spaced values between x1 and x2, inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1804" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1803" bodyend="1822"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1704b4adc18c9353ee63fa63539df54d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::logspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const int &amp;N)</argsstring>
        <name>logspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between 10^(x1) and 10^(x2). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1837" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1836" bodyend="1853"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afb7e6400d879e910f6bf8eb7270d5a64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::unwrap</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const T &amp;tol=pi)</argsstring>
        <name>unwrap</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>tol</declname>
          <defval>pi</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1856" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1855" bodyend="1873"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad1acd03db6a49523cb5dbe751a80917a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::mean</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>mean</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the mean of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1878" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1877" bodyend="1887"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a640a5654108c737a52e781ee1794571b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1890" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1889" bodyend="2006"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afe6759a7b418424b2ff906479f7be674" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2010" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2009" bodyend="2046"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4a49bf5b82e6ed936de7431edf4a80b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const matrix&lt; T &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2049" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2048" bodyend="2066"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aaf4e4d72785a2ab1f2a5f351789d904f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2070" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2069" bodyend="2092"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0c7738d1b0ccad83715f29398829bd78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const matrix&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2095" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2094" bodyend="2112"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5505a093e19a1f347d347b4a27ca7799" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const std::vector&lt; std::vector&lt; U &gt; &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::vector&lt; U &gt; &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2115" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2114" bodyend="2132"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af1e3b00481455a363456bcdc8ab407fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::trapz</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;eta, const std::vector&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2135" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2134" bodyend="2152"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3172e450b1174671f2fddc9e3d71a764" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::trapz</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2155" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2154" bodyend="2187"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7124131346b73357a9e7d8e7c4ae9cc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u, const int &amp;index=2)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>index</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2191" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2190" bodyend="2228"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af805809516d8ef219573c6f3e4cbd077" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2231" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2230" bodyend="2268"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2e73976d2cf44b145d261f52c4bcdf5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const std::vector&lt; U &gt; &amp;eta, const std::vector&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2271" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2270" bodyend="2290"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adec9b07955f64a93dc76db37eea6656d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::fft</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;u, int N=-1)</argsstring>
        <name>fft</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2293" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2292" bodyend="2328"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a880f7df231a78f912b3fb5d301c809f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_ode</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2332" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2331" bodyend="2358"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afcd6ae07fc18f5374868fe314f00108c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, double val)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2361" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2360" bodyend="2363"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a261a9d83dcc8786777d193575b7e1a1c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, std::initializer_list&lt; int &gt; list)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; int &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2366" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2365" bodyend="2368"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af9dec3da4533a1db21a6c6c4fe8e740a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::print</definition>
        <argsstring>(Figure &amp;h, std::string pterm, std::string pfilename)</argsstring>
        <name>print</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pterm</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pfilename</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2371" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2370" bodyend="2373"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2641f24e5cec5eddddbd6de2159055f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___matrix" kindref="compound">Sort_Matrix</ref>&lt; T &gt;</type>
        <definition>Sort_Matrix&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;dim=2, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>dim</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2383" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2382" bodyend="2484"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adba3dbd0ed8ce919ffcd445bcf273673" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___vector" kindref="compound">Sort_Vector</ref>&lt; T &gt;</type>
        <definition>Sort_Vector&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2494" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2493" bodyend="2541"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6a8a286886d48471685b18b7782f1e4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::disp</definition>
        <argsstring>(const T &amp;x)</argsstring>
        <name>disp</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2548" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2547" bodyend="2551"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aba69db64fe38ad271de1939d3f1a5520" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::input</definition>
        <argsstring>(const std::string &amp;prompt, std::string option)</argsstring>
        <name>input</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prompt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>option</declname>
        </param>
        <briefdescription>
<para>Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as &quot;s&quot; because C++ is a statically typed language. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2558" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2557" bodyend="2573"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bca7924aad17a920f2f5f0606e6d9a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::str2num</definition>
        <argsstring>(const std::string &amp;in)</argsstring>
        <name>str2num</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Converts a string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2579" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2578" bodyend="2581"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1c5fcab6592307cffe0e9aa035122a2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>length</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements in a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2587" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2586" bodyend="2589"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a856e64b0828ca7b61e301e8a803cfa91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>length</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the length of the largest dimension of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2595" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2594" bodyend="2599"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abd52330177821fc7cbf3f1c29e49f476" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::numel</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>numel</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2603" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2602" bodyend="2605"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae34a4afffae90a5579e08be7d2177b2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; keycpp::find</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const int &amp;k=-1, std::string start=&quot;&quot;)</argsstring>
        <name>find</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>k</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>start</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Finds and returns the indices of non-zero elements of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2611" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2610" bodyend="2670"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a97f0fc27cf8489f3f556fb1a0c975115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__find__type" kindref="compound">matrix_find_type</ref>&lt; T &gt;</type>
        <definition>matrix_find_type&lt;T&gt; keycpp::find</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>find</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Finds and returns the row and column indices and values of non-zero elements of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2685" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2684" bodyend="2709"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef6aab5ede3802c66f27415107594ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2713" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2712" bodyend="2736"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5a32dc59a247e09814a4b8ce9ea1db57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const int &amp;m, const int &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2740" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2739" bodyend="2742"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af2f586b97047513a6d2fa346d2302af0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::dot</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2748" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2747" bodyend="2763"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad14584bb6e102379fb176e7a864c9cf8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::dot</definition>
        <argsstring>(const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2769" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2768" bodyend="2780"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af4148cd818cee05304763a197bf56e3c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::dot</definition>
        <argsstring>(const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2786" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2785" bodyend="2799"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac3f44dfd7e58788078a8cba3696d3a39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::dot</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B, const int &amp;dim=-1)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>dim</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Computes the dot product between the first non-singleton dimension of A and B. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2805" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2804" bodyend="2832"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a73fa9874e6923dd54c95d52a22a99d00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::cross</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>cross</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2839" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2838" bodyend="2854"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a85adf7a8804f7d7d3c378d86427b4210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2867" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2866" bodyend="2911"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb34bdd249af3ce92341cdda62f95f65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2913" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="670" bodyend="711"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a838fc93d66e1ab63d68d04781086d81a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; double, double &gt;</type>
        <definition>SVD_type&lt; double, double &gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2914" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="715" bodyend="855"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad211ab5ae14ac9710265c662f70f20ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2915"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab96149e6d3b76c5363601903c4fb72bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; std::complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;std::complex&lt;double&gt;,double&gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;&quot;)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2916"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb9efbc77cc58fa22403ea7ae5f4555c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::rank</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>rank</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2923" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2922" bodyend="2926"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8f497e2da901adba0e1257be943595a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::null</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>null</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the nullspace of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2932" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2931" bodyend="2955"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a70b89ab3e8f66f86c47c3bde004d4487" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>any</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2961" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2960" bodyend="2967"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ade6d308fd22d34ad4860e5fcd22ccb39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>any</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2973" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2972" bodyend="2985"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a01b100190bc21b024340b7bddd4467dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>any</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2991" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2990" bodyend="3000"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aab77d82d9cc7d1fcca87967048f09e0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>all</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3006" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3005" bodyend="3012"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0ebd51ca90981278382a922c04ee7a75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>all</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3018" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3017" bodyend="3030"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adcb91abe9a1d64046037bced47b7b466" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>all</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3036" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3035" bodyend="3045"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a03069647e77ae29e5437553b98274634" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>finite</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3052" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3051" bodyend="3063"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8879482fc9af1a809453e1719948263b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>finite</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3070" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3069" bodyend="3080"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af4add0d0b269850e5f5fc1362d023666" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>finite</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3087" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3086" bodyend="3094"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adca45e7f46618cf193b6b7bb59465a9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isinf</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3101" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3100" bodyend="3112"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abf12e8a9c04720e074328bb1d34dce04" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isinf</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3119" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3118" bodyend="3129"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a34d8480a27e0e6d14d687054a221c0a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>isinf</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3136" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3135" bodyend="3143"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b5311cd26b6819f68c158d08c39d501" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isnan</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3150" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3149" bodyend="3161"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad3b16064066dc041be364e6fbefa173a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isnan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3168" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3167" bodyend="3178"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a00160cff29da446de425d98ffafe8cb3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>isnan</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3185" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3184" bodyend="3192"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acc2de8926c54a2048a0d8965e7d70995" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isempty</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if matrix is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3198" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3197" bodyend="3200"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0bffe72cf3a118ccaaa6f195c4859550" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>isempty</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if vector is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3206" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3205" bodyend="3208"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a81a8c955cdbeb60181f6bf7d6553ac53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isreal</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3214" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3213" bodyend="3220"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a62d7118882bac24ab403ffb5f8ee7034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isreal</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3226" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3225" bodyend="3238"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad811cd86faad44bdf322b55d332fee29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>isreal</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3244" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3243" bodyend="3253"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a005c1190f7087fb1d2545c38c080fd1a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::ceil</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>ceil</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Rounds the real and imaginary parts of complex&lt;double&gt; a towards positive infinity seperately. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3259" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3258" bodyend="3263"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adb46ebfbb914f186bcb1859f39dfae91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>ceil</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of v1 towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3269" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3268" bodyend="3276"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bba31744fef3693901a075fda07857c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ceil</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of A towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3282" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3281" bodyend="3292"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a136df5d07e95d472b1a38d3fd71b3a3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::polyval</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;p, const U &amp;x)</argsstring>
        <name>polyval</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3296" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3295" bodyend="3305"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7752b443d306871030c8867467fe6cc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::roots</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;p)</argsstring>
        <name>roots</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3312" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3311" bodyend="3321"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6069a9eec0edfa1d401230013d98765e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref></type>
        <definition>tictoc_type keycpp::tic</definition>
        <argsstring>()</argsstring>
        <name>tic</name>
        <briefdescription>
<para>Start the timer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3333" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3332" bodyend="3337"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afe03fbbb5126729fb4b9367097acb1d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::toc</definition>
        <argsstring>(tictoc_type &amp;Timer)</argsstring>
        <name>toc</name>
        <param>
          <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref> &amp;</type>
          <declname>Timer</declname>
        </param>
        <briefdescription>
<para>Stop the timer. The number of elapsed seconds is returned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3342" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3341" bodyend="3346"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::sprintf</definition>
        <argsstring>(const std::string &amp;fmt,...)</argsstring>
        <name>sprintf</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Overload of the C++ function <ref refid="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" kindref="member">sprintf()</ref>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3352" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3351" bodyend="3377"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aff2feefaeb946dd453d74ff51c66fe67" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; keycpp::clock</definition>
        <argsstring>()</argsstring>
        <name>clock</name>
        <briefdescription>
<para>Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3384" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3383" bodyend="3396"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac20bd2ef4fb18cbcdb0f462a89447bd7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::pinv</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>pinv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3403" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3402" bodyend="3424"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad70d9156c4b6a75e5b7a4c799f900162" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::removeWhiteSpace</definition>
        <argsstring>(std::string in)</argsstring>
        <name>removeWhiteSpace</name>
        <param>
          <type>std::string</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3427" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3426" bodyend="3445"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac5c0a8bc58229a412ec2068979b6b84e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::importdata</definition>
        <argsstring>(std::string filename)</argsstring>
        <name>importdata</name>
        <param>
          <type>std::string</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Returns a matrix containing the data read from a text file. Values must be white space separated. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3449" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3448" bodyend="3497"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aaadf411a742cc75864477e1f1bc82ce8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::stdev</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3502" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3501" bodyend="3512"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b9edabfd1ccca244f0ea077ab3ba363" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::stdev</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3516" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3515" bodyend="3526"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a68e5d69d730e978061d7aeda2b49441c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::var</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3531" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3530" bodyend="3533"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a391aed253df5e18fbc7f8502cbbe9293" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::var</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3537" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3536" bodyend="3539"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6fe26246d9b85e3a1261e7dc3da3967b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::linsolve2</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A_in, const std::vector&lt; T &gt; &amp;b_in)</argsstring>
        <name>linsolve2</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3543" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3542" bodyend="3597"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a16b58f47ed977cafdc96227468f5f10a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, double *ALPHA, const double *A, const int *LDA, const double *B, const int *LDB, double *BETA, double *C, const int *LDC)</argsstring>
        <name>dgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="16"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a29fb4e46ee1b9cce0fd8bc79a2490c72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *B, const int *LDB, std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *C, const int *LDC)</argsstring>
        <name>zgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="21"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af0676a4a89dbb63f09fc627c05e12699" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const double *ALPHA, const double *A, const int *LDA, const double *X, const int *INCX, const double *BETA, double *Y, const int *INCY)</argsstring>
        <name>dgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="25"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aea174778653491b5fd21dd2960c0f7cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *X, const int *INCX, const std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *Y, const int *INCY)</argsstring>
        <name>zgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="30"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a524691df2a648a59b3be9f2b2362bbe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; &amp;A, const matrix&lt; complex&lt; double &gt; &gt; &amp;B, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Generalized complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="55" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="54" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab2aef1f33c78911d0ebcd77f9c9841fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; &amp;A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="150" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="149" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7cc3fb9ca244e5caac42cf94013ddf94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Double precision eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="241" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="240" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acea0bb8f128ef0cdf55a79c50ceccb83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="351" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="349" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac9cabca49e9650ae8b5aadf5ee2f7f4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="598" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="597" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e5e5bd17f11bc2585161c4229e6eaf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in, std::string method)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="858" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="857" bodyend="898"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a72ae28f3433b8617a1252c7995fc21db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;complex&lt;double&gt;, double&gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="903" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="902" bodyend="1044"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="30"/>
  </compounddef>
</doxygen>
