<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3.1">
  <compounddef id="namespacekeycpp" kind="namespace">
    <compoundname>keycpp</compoundname>
    <innerclass refid="classkeycpp_1_1_figure_exception" prot="public">keycpp::FigureException</innerclass>
    <innerclass refid="classkeycpp_1_1_plots" prot="public">keycpp::Plots</innerclass>
    <innerclass refid="classkeycpp_1_1_figure" prot="public">keycpp::Figure</innerclass>
    <innerclass refid="classkeycpp_1_1_key_cpp_exception" prot="public">keycpp::KeyCppException</innerclass>
    <innerclass refid="structkeycpp_1_1observe" prot="public">keycpp::observe</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___matrix" prot="public">keycpp::Sort_Matrix</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___vector" prot="public">keycpp::Sort_Vector</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__find__type" prot="public">keycpp::matrix_find_type</innerclass>
    <innerclass refid="structkeycpp_1_1_s_v_d__type" prot="public">keycpp::SVD_type</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__size__type" prot="public">keycpp::matrix_size_type</innerclass>
    <innerclass refid="classkeycpp_1_1_matrix_exception" prot="public">keycpp::MatrixException</innerclass>
    <innerclass refid="classkeycpp_1_1matrix" prot="public">keycpp::matrix</innerclass>
    <innerclass refid="classkeycpp_1_1_spline_exception" prot="public">keycpp::SplineException</innerclass>
    <innerclass refid="classkeycpp_1_1_extrap" prot="public">keycpp::Extrap</innerclass>
    <innerclass refid="classkeycpp_1_1_spline" prot="public">keycpp::Spline</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacekeycpp_1ace2501951ab3db3a91c3520ae89750b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zggev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zggev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex generalized eigenvalue solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="46"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aebc5253e80ac15a9bfdc5449ae4f972a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgeev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</argsstring>
        <name>dgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wi</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="51"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c1cca2a162f40fc6c6218c35cadf9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgeev_</definition>
        <argsstring>(const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>w</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VL</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VR</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="56"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aca3be6524e195662cbb74a810305e721" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgecon_</definition>
        <argsstring>(const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</argsstring>
        <name>dgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>iwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="61"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a75e334ffaf1864d7191e9e0b64189783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrf_</definition>
        <argsstring>(const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>dgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="65"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab9c33788a2c083aa5738eda1fe62a261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</argsstring>
        <name>dgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="69"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4507ef954be960fec70ca0f93258d730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::dlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</argsstring>
        <name>dlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="73"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a444e3cdc7e7929414370b6b50ea1218c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgecon_</definition>
        <argsstring>(const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</argsstring>
        <name>zgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex-valued reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18d58d53d8e19a37d74d24da27a64dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrf_</definition>
        <argsstring>(const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>zgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abbe4322276dcdb7d864e85854b5b90f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</argsstring>
        <name>zgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="86"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1477c910b07baef984fe8528c29b2774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::zlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</argsstring>
        <name>zlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="90"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a12719f4b48de048f9642066666a920bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesv_</definition>
        <argsstring>(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</argsstring>
        <name>dgesv_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision linear system solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="94"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af92d0d887ae48cc4222f7167232a7f82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetri_</definition>
        <argsstring>(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</argsstring>
        <name>dgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="97"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4190e125fe33133aafa586089ca6e174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetri_</definition>
        <argsstring>(const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</argsstring>
        <name>zgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="101"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8fe7a71afbb6c5dc049cdd7afff6c0af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</argsstring>
        <name>dgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa5e2f74110f53bd288c15ce1f183f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="111"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6aca656320e1b26861469a979a96066f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; A, const matrix&lt; std::complex&lt; double &gt; &gt; B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="117"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8b42273cb371e35064445ce84e26d944" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="121"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7e4c1a584c274bb164e0e207a13ec63e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a08b7545ff5c1295647680d08f2953875" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; double &gt; A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="127" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="253" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5cc586899ece36154e39201f18e6db55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="128" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="300" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9f68b3d9143ad3582e59dd0a4b1998b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="130"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a46f4a25648e5bad1cf0bd0e7fca7fae0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt; double &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="132" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="437" bodyend="523"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adc96927cda2df7a6e8e2031941c43601" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="133" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="525" bodyend="595"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b74369f5415c3ed45f63995149ad992" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="134"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef5c1f5951e8182a7c4ec9612f3f7e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rand</definition>
        <argsstring>()</argsstring>
        <name>rand</name>
        <briefdescription>
<para>Returns a random double between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="136" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="10" bodyend="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a53e0eb41dbd6cddc6ac15d92d68c7aee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(int N)</argsstring>
        <name>rand</name>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an N x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="137" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="17" bodyend="29"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adbc446e99edbcde1d69bfe2c74dc3c80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(int M, int N)</argsstring>
        <name>rand</name>
        <param>
          <type>int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an M x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="138" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="33" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e8bada51586c0561e1b32ca1ab5f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="157" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="156" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a300d8f6e8992c7b33156492d884bd621" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="171" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="170" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae8a5ac9572fd012881e19f850b0f47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::prod</definition>
        <argsstring>(const std::vector&lt; T &gt; x)</argsstring>
        <name>prod</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns the product of all the elements of the vector x. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="183" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="182" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0b348cee175715d20a1997b471c47d7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::prod</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a vector containing the product of all the elements in each column of the matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="201" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="200" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>diff</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns a vector of differences between adjacent elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="222" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="221" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0cf08572a2b7b23b6be5365053770fa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of row differences between adjacent rows. </para>        </briefdescription>
        <detaileddescription>
<para>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="241" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="240" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad26d6a2ad64185a749c6f2e85aeaf62b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::conj</definition>
        <argsstring>(const std::vector&lt; T &gt; x)</argsstring>
        <name>conj</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="258" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="257" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5cbc9dd508d193697eb9dfbef01f1404" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;double&gt; &gt; keycpp::conj</definition>
        <argsstring>(const matrix&lt; T &gt; x)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="268" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="267" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a76cd22caf522d677271fb915fb3aec37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::real</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>real</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="281" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="280" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a22cc33e0299a65158c81352603bcd35a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::imag</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>imag</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="291" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="290" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a01edbbe2645ae65b6ec2c08b2d4352e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::abs</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>abs</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="301" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="300" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a70d66686c6b209cc8eb64f84977544da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::arg</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>arg</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="311" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="310" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a952e5296774667c3be4e792b5cd980da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const double &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="321" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="320" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4da6882977b2262f8d6f080b0eaf60c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="326" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="325" bodyend="333"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab185edce957f4afd65cb641ec6307376" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="336" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="335" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d5dbf37b71d16d686dd0fdbad82f8fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="346" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="345" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae187563f8f86e256bc1394edcba1b2b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;A, const T &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="359" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="358" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6dcf10b0db68d53d126803e8d6d591fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="372" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="371" bodyend="401"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b523ff3dd5abac240788f6efb2e554e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="404" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="403" bodyend="411"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2e9a06b12f7df18005a3daa3c051b2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="414" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="413" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac2665554c04ea23aad98e77d1618ca6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="424" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="423" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a390125160a7febd08d5c30629f4f698f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="434" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="433" bodyend="444"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3852c35cfcc8caa784465a26d04c68a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="447" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="446" bodyend="457"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a394f23f09cf122a8e8c20a7afd40f58e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="460" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="459" bodyend="467"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1ebc4ddf6e567714f63f0dbb8a984745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="472" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="471" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a159a28c69282a740e381465a0e71bf23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="484" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="483" bodyend="494"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afaf5c65950c36d6a10e2fc42cae7b041" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="499" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="498" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6d906ad1b0afbefd588c619cdb02530a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="511" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="510" bodyend="521"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2d4f2ab79da4b10e9be3af2693904ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="526" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="525" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a24ac535f72f9e72bf2d0fb93b2b0ee01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="538" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="537" bodyend="548"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90a6f9aaec03f1f72bf4013316795c5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eye</definition>
        <argsstring>(const int N)</argsstring>
        <name>eye</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="551" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="550" bodyend="559"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2dc5102775ed955f378432f84fe96987" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; A, const int dim)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements along dimension dim. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements along dimension dim. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer value of the number of elements along the desired dimension. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="570" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="569" bodyend="572"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a028e501a865c86bdf616ea13e87645fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref></type>
        <definition>matrix_size_type keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the size of matrix A. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the size of matrix A in a <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable containing the number of rows and cols. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="582" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="581" bodyend="587"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a86f1406f9fad5a439d8eff01aba8eac6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int M, const int N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="597" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="596" bodyend="600"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a17115c92ffe695fd6ecb002f5ded220a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="609" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="608" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ace6f21832ab61f8f15e5b35e0a5cdb3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int M, const int N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="622" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="621" bodyend="632"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a31175b3ba618b338b185cd02a27addfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="641" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="640" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa2a7959f650bb0b6d214c2a74eed846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::initializer_list&lt; T &gt; &amp;lst, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::initializer_list&lt; T &gt; &amp;</type>
          <declname>lst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="651" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="650" bodyend="678"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e321022a262bb25cbcdc4d3186001b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="681" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="680" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7f3ca84f887fb11aee5b219c03429096" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const matrix&lt; T &gt; A, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="708" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="707" bodyend="753"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a40a637f210b03a3901cafbd6c1a7e83f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const matrix&lt; T &gt; A, int m, int n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="756" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="755" bodyend="772"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a59fbea40dfc2d43cd338812f06c4f064" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, int m, int n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="775" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="774" bodyend="788"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac1ff99e34619478096c271b38df1f3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="796" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="795" bodyend="814"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90d5fd4f9f7c52f16425105995655e9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>times</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="822" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="821" bodyend="837"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacd37d195541b2313b753b6e8839f916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs right array division on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="845" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="844" bodyend="863"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af234cd07a4e1d649629a6b83dbe113ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs right array division on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="871" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="870" bodyend="886"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac57d32902cba2c399475015235aeccec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Performs left array division on matrices B and A. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="894" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="893" bodyend="912"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a86bc7e25833cdf9266c038a4edb0ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Performs left array division on vectors v2 and v1. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="920" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="919" bodyend="935"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8f1cd159623e23abeedd26d34fc500d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::sign</definition>
        <argsstring>(T val)</argsstring>
        <name>sign</name>
        <param>
          <type>T</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="938" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="937" bodyend="940"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abebb8d8939a33f6c3cb00be9278114c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::max</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>max</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="943" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="942" bodyend="955"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8ef49e492f67187d0909c7ae093fee48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::min</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>min</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="958" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="957" bodyend="970"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83c90b0df3a170c845b848593be4cb74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::angle</definition>
        <argsstring>(T x)</argsstring>
        <name>angle</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="973" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="972" bodyend="975"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a13ee1c3dd9cbb21a325260188a7fa860" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::angle</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>angle</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="978" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="977" bodyend="986"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a73269c9db9fe25412819858bd7048ae5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::max</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt; &gt; x)</argsstring>
        <name>max</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="989" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="988" bodyend="1003"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aed77b31791ec78800e98ace1cbc3693d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::max</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1006" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1005" bodyend="1013"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab7577228b38fa6a1911ac65fb80832f3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::min</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt; &gt; x)</argsstring>
        <name>min</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1016" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1015" bodyend="1030"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d8183bfe936dc877f32f86a43daa1b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::min</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1034" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1033" bodyend="1041"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad68697505d1a1a85f30a18b0e9b0eb2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>transpose</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1046" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1045" bodyend="1056"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa148d677899a0da5ab14edfc5057a97b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>transpose</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1061" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1060" bodyend="1068"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a88081df8038d0b630d6a3540aeca8b9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>ctranspose</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1073" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1072" bodyend="1083"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a827218d19d98cf1357032a652a9bf4e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1088" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1087" bodyend="1095"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4aedb589e76ced5d79d62c5f72029adb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sum</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>sum</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the sum of each column of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1100" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1099" bodyend="1107"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad05b888638b5ea7103bdc6ba0882d47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::sum</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>sum</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the sum of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1112" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1111" bodyend="1119"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8a0e8201f775945a0a61d6d645a3456e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::mat2vec</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>mat2vec</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Converts matrix A to a column vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1124" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1123" bodyend="1135"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d3ef9b10b3db438529bafc5e74fa0dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::vec2mat</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>vec2mat</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Converts a column vector to a 1 x length(v1) matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1140" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1139" bodyend="1151"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab57eee495c93eb18ebf8c8ccf4d44e74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::linspace</definition>
        <argsstring>(const T x1, const T x2, const int N)</argsstring>
        <name>linspace</name>
        <param>
          <type>const T</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between x1 and x2. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N equally spaced values between x1 and x2, inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1164" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1163" bodyend="1182"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac92462e3b25414144d4e45fc269d2f13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::logspace</definition>
        <argsstring>(const T x1, const T x2, int N)</argsstring>
        <name>logspace</name>
        <param>
          <type>const T</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between 10^(x1) and 10^(x2). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1197" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1196" bodyend="1213"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4e350b4b11ea4d9962b4daa13cc66e32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::unwrap</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, T tol=pi)</argsstring>
        <name>unwrap</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T</type>
          <declname>tol</declname>
          <defval>pi</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1216" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1215" bodyend="1233"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad1acd03db6a49523cb5dbe751a80917a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::mean</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>mean</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the mean of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1238" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1237" bodyend="1247"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a123211086c4953fe9346acc22b2a67f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, U x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>U</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1250" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1249" bodyend="1366"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a56633eb0878a0dbe6596fb0e74fdc6ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1370" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1369" bodyend="1406"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad6dfc562f4ab516d21be63ab8a9c1b23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, matrix&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1409" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1408" bodyend="1426"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3b44770c6a8c5ba4acb6fe6ead6cc811" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; std::vector&lt; T &gt; &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; T &gt; &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1430" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1429" bodyend="1452"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac5ab894467bbea180c9b283895d5d5d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, matrix&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1455" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1454" bodyend="1472"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4c19f6ff8e0001eca5c63529bd58e664" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; std::vector&lt; U &gt; &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; U &gt; &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1475" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1474" bodyend="1492"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad817c482d12509f0938849890bb4de4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::trapz</definition>
        <argsstring>(std::vector&lt; U &gt; eta, std::vector&lt; T &gt; integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1495" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1494" bodyend="1512"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a379324b1d1cb219fdde96c9678aa5341" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(matrix&lt; U &gt; eta, matrix&lt; T &gt; u, int index=2)</argsstring>
        <name>diffxy</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1516" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1515" bodyend="1553"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5b09f118fe12b83865ff08fe3d3633ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(std::vector&lt; U &gt; eta, matrix&lt; T &gt; u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1556" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1555" bodyend="1593"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3bdbcb862d76b1b1fb5157788b7336ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(std::vector&lt; U &gt; eta, std::vector&lt; T &gt; u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1596" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1595" bodyend="1615"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b17b3d224192fffc838834ff736d572" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::fft</definition>
        <argsstring>(std::vector&lt; T &gt; u, int N=-1)</argsstring>
        <name>fft</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1618" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1617" bodyend="1653"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a880f7df231a78f912b3fb5d301c809f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_ode</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1657" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1656" bodyend="1682"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afcd6ae07fc18f5374868fe314f00108c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, double val)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1685" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1684" bodyend="1687"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a261a9d83dcc8786777d193575b7e1a1c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, std::initializer_list&lt; int &gt; list)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; int &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1690" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1689" bodyend="1692"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6862448bf6e09309e60a6ba7aa0caf9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___matrix" kindref="compound">Sort_Matrix</ref>&lt; T &gt;</type>
        <definition>Sort_Matrix&lt;T&gt; keycpp::sort</definition>
        <argsstring>(matrix&lt; T &gt; A, int dim=2, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dim</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1702" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1701" bodyend="1803"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1be4e97b99a996a01f428fd8ba048fb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___vector" kindref="compound">Sort_Vector</ref>&lt; T &gt;</type>
        <definition>Sort_Vector&lt;T&gt; keycpp::sort</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1813" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1812" bodyend="1860"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6498ae080f530236ae3f7756f81ac78e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::disp</definition>
        <argsstring>(T x)</argsstring>
        <name>disp</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1867" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1866" bodyend="1870"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2eb6a6f7647e6ff700b7992faecd986d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::input</definition>
        <argsstring>(std::string prompt, std::string option)</argsstring>
        <name>input</name>
        <param>
          <type>std::string</type>
          <declname>prompt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>option</declname>
        </param>
        <briefdescription>
<para>Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as &quot;s&quot; because C++ is a statically typed language. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1877" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1876" bodyend="1892"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac056ba33ff8585d5680daf09a45ff8e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::str2num</definition>
        <argsstring>(std::string in)</argsstring>
        <name>str2num</name>
        <param>
          <type>std::string</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Converts a string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1898" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1897" bodyend="1900"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e62ad4a7f9b872d69df78c09e3f7b59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>length</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements in a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1906" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1905" bodyend="1908"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afaef726cb38faec462ac53cff08ab113" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>length</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the length of the largest dimension of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1914" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1913" bodyend="1918"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14d8a9ae8d6988eeff52fa777e75bd20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::numel</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>numel</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1922" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1921" bodyend="1924"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af93acd2c9e3e2e47bbf796143b994a18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; keycpp::find</definition>
        <argsstring>(std::vector&lt; T &gt; v1, int k=-1, std::string start=&quot;&quot;)</argsstring>
        <name>find</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>start</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Finds and returns the indices of non-zero elements of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1930" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1929" bodyend="1989"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5c7bf08adf4c09275f9e16cd510b7357" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__find__type" kindref="compound">matrix_find_type</ref>&lt; T &gt;</type>
        <definition>matrix_find_type&lt;T&gt; keycpp::find</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>find</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Finds and returns the row and column indices and values of non-zero elements of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2004" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2003" bodyend="2028"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9c4772f020269af1ae89c9cb0164d81c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(matrix&lt; T &gt; A, int m, int n)</argsstring>
        <name>reshape</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2032" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2031" bodyend="2055"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab8f45bfa36c10a24c117fb96be879cce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(std::vector&lt; T &gt; v1, int m, int n)</argsstring>
        <name>reshape</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2059" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2058" bodyend="2061"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abcee2445c0961997ba6e9d16070b2f8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::dot</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::vector&lt; U &gt; v2)</argsstring>
        <name>dot</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2067" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2066" bodyend="2082"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a52f48322f62e9bf11da0acb06deadd63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::dot</definition>
        <argsstring>(matrix&lt; T &gt; A, matrix&lt; U &gt; B, int dim=-1)</argsstring>
        <name>dot</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dim</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Computes the dot product between the first non-singleton dimension of A and B. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2088" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2087" bodyend="2115"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1013b624bcc27f0953dfb989bacfe446" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::cross</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::vector&lt; U &gt; v2)</argsstring>
        <name>cross</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2122" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2121" bodyend="2137"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa01035a2b2a07cd56c5e36d5f289b2ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2150" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2149" bodyend="2194"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7e5236252f6a33f3523fb805a2d1727c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; double &gt; A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2196" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="670" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b80bd145aab03a9e79a42d32ca573bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; double, double &gt;</type>
        <definition>SVD_type&lt; double, double &gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; double &gt; A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2197" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="724" bodyend="864"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a867ba604b4e72e41b123f890dd66d854" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2198"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa6d15c3c38ff98e6d9afdd9db4b46c6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; std::complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;std::complex&lt;double&gt;,double&gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;&quot;)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2199"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4a7bb7923c2ff72fdf6a54ee1b891c16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::rank</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>rank</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2206" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2205" bodyend="2209"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a54f9ed89c437774e0f7391fd7d86e005" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::null</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>null</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the nullspace of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2215" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2214" bodyend="2238"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e0536b6efa09624ea3738bbb9975dea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>any</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2244" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2243" bodyend="2256"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adee9ea3e8989009abba313a2f7d44d46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>any</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2262" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2261" bodyend="2271"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c576908958c419fc0cae34ce1a6a5c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>all</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2277" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2276" bodyend="2289"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa8ea92aa5e5e801a2e42f2eefabd659" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>all</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2295" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2294" bodyend="2304"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a092a180cc054e61d0dad651dd24ff990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>finite</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2311" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2310" bodyend="2328"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6640e5ff779655aed8078c5de81af7ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>finite</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2335" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2334" bodyend="2349"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a48b81a22ef851cfac4d2f98eb6d182b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::ceil</definition>
        <argsstring>(std::complex&lt; double &gt; a)</argsstring>
        <name>ceil</name>
        <param>
          <type>std::complex&lt; double &gt;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Rounds the real and imaginary parts of complex&lt;double&gt; a towards positive infinity seperately. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2355" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2354" bodyend="2359"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa10f7052b5450926e1aa055510270d3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>ceil</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of v1 towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2365" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2364" bodyend="2372"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a26cc754af2bdfab23c93e91017b84594" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>ceil</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of A towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2378" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2377" bodyend="2388"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afbf61ceccd7874c0d8b4ae62cd5bbc24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::roots</definition>
        <argsstring>(std::vector&lt; T &gt; p)</argsstring>
        <name>roots</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2395" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2394" bodyend="2404"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a190640edb8e634de02d302d94a29ee17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; A, const matrix&lt; complex&lt; double &gt; &gt; B, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Generalized complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="55" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="54" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeccfac59e68c6dc37cd89626ece3bd70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="150" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="149" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae6d82c320841cd42905abfbba464a45d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Double precision eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="241" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="240" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acea0bb8f128ef0cdf55a79c50ceccb83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="351" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="349" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac9cabca49e9650ae8b5aadf5ee2f7f4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="598" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="597" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af1a41d0919918b5cf62ef28dd68217d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; A_in, std::string method)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="867" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="866" bodyend="916"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a913fb7501259de640e7119a852adafc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;complex&lt;double&gt;, double&gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; complex&lt; double &gt;&gt; A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="921" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="920" bodyend="1062"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="31"/>
  </compounddef>
</doxygen>
