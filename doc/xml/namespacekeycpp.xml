<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3.1">
  <compounddef id="namespacekeycpp" kind="namespace">
    <compoundname>keycpp</compoundname>
    <innerclass refid="classkeycpp_1_1_figure_exception" prot="public">keycpp::FigureException</innerclass>
    <innerclass refid="classkeycpp_1_1_plots" prot="public">keycpp::Plots</innerclass>
    <innerclass refid="classkeycpp_1_1_figure" prot="public">keycpp::Figure</innerclass>
    <innerclass refid="classkeycpp_1_1_key_cpp_exception" prot="public">keycpp::KeyCppException</innerclass>
    <innerclass refid="structkeycpp_1_1observe" prot="public">keycpp::observe</innerclass>
    <innerclass refid="structkeycpp_1_1_o_d_e__type" prot="public">keycpp::ODE_type</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___matrix" prot="public">keycpp::Sort_Matrix</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___vector" prot="public">keycpp::Sort_Vector</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__find__type" prot="public">keycpp::matrix_find_type</innerclass>
    <innerclass refid="classkeycpp_1_1_s_v_d__type" prot="public">keycpp::SVD_type</innerclass>
    <innerclass refid="structkeycpp_1_1tictoc__type" prot="public">keycpp::tictoc_type</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__size__type" prot="public">keycpp::matrix_size_type</innerclass>
    <innerclass refid="classkeycpp_1_1_matrix_exception" prot="public">keycpp::MatrixException</innerclass>
    <innerclass refid="classkeycpp_1_1matrix" prot="public">keycpp::matrix</innerclass>
    <innerclass refid="classkeycpp_1_1_spline_exception" prot="public">keycpp::SplineException</innerclass>
    <innerclass refid="classkeycpp_1_1_extrap" prot="public">keycpp::Extrap</innerclass>
    <innerclass refid="classkeycpp_1_1_spline" prot="public">keycpp::Spline</innerclass>
    <innerclass refid="classkeycpp_1_1_pointer_iterator" prot="public">keycpp::PointerIterator</innerclass>
    <innerclass refid="classkeycpp_1_1vector__k" prot="public">keycpp::vector_k</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacekeycpp_1a8d3ada618b663c38fe93a45de99c4c50" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::pi</definition>
        <argsstring></argsstring>
        <name>pi</name>
        <initializer>= 3.1415926535897932384626433832795</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="42" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1a685afaae59aa4c6da87f11c00699c5d8" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::eps</definition>
        <argsstring></argsstring>
        <name>eps</name>
        <initializer>= std::numeric_limits&lt;double&gt;::epsilon()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="43" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1ac45d63b1cbd35b140f7d057d03b626df" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::Inf</definition>
        <argsstring></argsstring>
        <name>Inf</name>
        <initializer>= std::numeric_limits&lt;double&gt;::infinity()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="44" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1a740d5b86942262cbcf119cd58a50f4fe" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::NaN</definition>
        <argsstring></argsstring>
        <name>NaN</name>
        <initializer>= std::numeric_limits&lt;double&gt;::quiet_NaN()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="45" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="45" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacekeycpp_1a5b72a83172512bb554f5e443b9b366bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt; T &gt; keycpp::real</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>real</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="32" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="398" bodyend="401"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61efb014b42cd8b02a81b4520c41ab2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::real</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>real</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="33" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="403" bodyend="406"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a752e14fae8ca75a5702c89207a7cd983" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>imag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="34" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="408" bodyend="411"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad902a14fdaa4b744a8a11220f5be0161" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>imag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="35" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="413" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0bf7cb9cbc44ac0b9e37ea84a7c460cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="752" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="751" bodyend="754"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0fd09e7b19e9c22430bb0e1b00a33067" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1, std::string property2, double val2)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="757" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="756" bodyend="759"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae195fde461203ab0b36e03c693f9d346" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string arguments, double val, double lw, double ps, std::string legend_entry)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>arguments</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lw</declname>
        </param>
        <param>
          <type>double</type>
          <declname>ps</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>legend_entry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="762" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="761" bodyend="764"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e50932cc54f92bdd7e38c6438f4f1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::ddot_</definition>
        <argsstring>(const int *N, const double *a, const int *inca, const double *b, const int *incb)</argsstring>
        <name>ddot_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="55"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2ce99b4fe4a13b9c70ada81761eb0ca2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zdotu_</definition>
        <argsstring>(std::complex&lt; double &gt; *result, const int *N, const std::complex&lt; double &gt; *a, const int *inca, const std::complex&lt; double &gt; *b, const int *incb)</argsstring>
        <name>zdotu_</name>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="58"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae99c5b242a21ba683701ccb6ab6534b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::daxpy_</definition>
        <argsstring>(const int *N, const double *alpha, const double *x, const int *incx, double *y, const int *incy)</argsstring>
        <name>daxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="61"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6460fa334239dde761d8f737b9438fed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zaxpy_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, const std::complex&lt; double &gt; *x, const int *incx, std::complex&lt; double &gt; *y, const int *incy)</argsstring>
        <name>zaxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="64"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d249dd978770119c1b91d88009fefbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dscal_</definition>
        <argsstring>(const int *N, const double *alpha, double *x, const int *incx)</argsstring>
        <name>dscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="67"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad9dd69d0d355e4805a832813199f1dff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zscal_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *x, const int *incx)</argsstring>
        <name>zscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="70"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ace2501951ab3db3a91c3520ae89750b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zggev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zggev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex generalized eigenvalue solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="77"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aebc5253e80ac15a9bfdc5449ae4f972a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgeev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</argsstring>
        <name>dgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wi</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c1cca2a162f40fc6c6218c35cadf9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgeev_</definition>
        <argsstring>(const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>w</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VL</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VR</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="87"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aca3be6524e195662cbb74a810305e721" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgecon_</definition>
        <argsstring>(const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</argsstring>
        <name>dgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>iwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="92"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a75e334ffaf1864d7191e9e0b64189783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrf_</definition>
        <argsstring>(const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>dgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="96"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab9c33788a2c083aa5738eda1fe62a261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</argsstring>
        <name>dgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4507ef954be960fec70ca0f93258d730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::dlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</argsstring>
        <name>dlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a444e3cdc7e7929414370b6b50ea1218c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgecon_</definition>
        <argsstring>(const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</argsstring>
        <name>zgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex-valued reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="109"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18d58d53d8e19a37d74d24da27a64dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrf_</definition>
        <argsstring>(const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>zgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="113"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abbe4322276dcdb7d864e85854b5b90f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</argsstring>
        <name>zgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="117"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1477c910b07baef984fe8528c29b2774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::zlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</argsstring>
        <name>zlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="121"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a12719f4b48de048f9642066666a920bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesv_</definition>
        <argsstring>(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</argsstring>
        <name>dgesv_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision linear system solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af92d0d887ae48cc4222f7167232a7f82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetri_</definition>
        <argsstring>(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</argsstring>
        <name>dgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="128"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4190e125fe33133aafa586089ca6e174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetri_</definition>
        <argsstring>(const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</argsstring>
        <name>zgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="132"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8fe7a71afbb6c5dc049cdd7afff6c0af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</argsstring>
        <name>dgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="137"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa5e2f74110f53bd288c15ce1f183f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="142"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a516e693670ca88debd44ca9a48b2f225" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, const matrix&lt; std::complex&lt; double &gt; &gt; &amp;B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Generalized complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="148" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3643" bodyend="3732"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae24a17765339d2464a0cccb476782bff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="152" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3741" bodyend="3825"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a42950497e518f5882a0689bb78fa667f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="156"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3905cfc35dbd146f5dbf7bcb5729c2c2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="158" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3848" bodyend="3893"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d9a9dd04453e5a417f7a9eb8ae4391b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="159" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3895" bodyend="3942"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa0c91a82f4eadf681f9a690d6f309665" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="161" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3944" bodyend="4019"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a13a89a2c6d30c991f4de63ca8f62c0e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt; double &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, const vector_k&lt; double &gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="163" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4022" bodyend="4096"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adc96927cda2df7a6e8e2031941c43601" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="164" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4098" bodyend="4168"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9085342fc708fd5babae39321da3b89a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt; std::complex&lt; double &gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="165" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4170" bodyend="4240"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef5c1f5951e8182a7c4ec9612f3f7e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rand</definition>
        <argsstring>()</argsstring>
        <name>rand</name>
        <briefdescription>
<para>Returns a random double between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="167" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3599" bodyend="3602"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac224964eb5e1a55c3f7d58f0e9b71d3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5c4b142a4101e9bb1df9f19efaf7d2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="169"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae90693acdaf666bd23bf861f2c0d28c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="173" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="172" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c6542964c7aaaccbee336567f64c03c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="187" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="186" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3a1ba458353cfecef659b40e446baaf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="198" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="197" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a48fb1c8a89210ed78554ecd0bed92a59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="212" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="211" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5afc215befa38bf47fb52cff33794ebe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="223" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="222" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afc7610588aa92335352b2796ebdd359d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="237" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="236" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae14b016d01024e738c3110299ee58666" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="248" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="247" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a31115adc10089fbbc732d59362890af2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="262" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="261" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e8bada51586c0561e1b32ca1ab5f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="288" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="287" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a86f8946c126102b4467b70da16766b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="302" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="301" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1add55ad2a40111d6368744a3d4144f25a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::prod</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns the product of all the elements of the vector x. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="314" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="313" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af5471fc9074471701bde9e68eb7971b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::prod</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a vector containing the product of all the elements in each column of the matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="332" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="331" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a52c37ec9c41349fd6bd862b8ebdd01bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns a vector of differences between adjacent elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="353" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="352" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abb4e57814fd30b7b8d4845bbc16c73e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of row differences between adjacent rows. </para>        </briefdescription>
        <detaileddescription>
<para>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="372" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="371" bodyend="386"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a436cfe206bb34dfe613ac495e792b155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="389" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="388" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0f000b392fbefccdb089383bb6a20151" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="394" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="393" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83cec179e95af014706ce54194efd1b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="419" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="418" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa48f282087263edb46886e9390b9a833" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="424" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="423" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1f83b48bfedf753904dfea9dde554a4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="429" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="428" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae0edec63f48a81c576da0c0ffc768af9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="434" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="433" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a952e5296774667c3be4e792b5cd980da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const double &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="439" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="438" bodyend="441"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8faa7912f1f198c5185cb6a36cfd2fb2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="444" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="443" bodyend="446"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa865f0bd18bdefcf413b1c3dd286b998" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="449" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="448" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae416b3cc307c30afdb62f0ed37b70e05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="468" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="467" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ade9508aa24d2496bd63dcdb72229c8b0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="486" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="485" bodyend="500"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a68fe0fe851bce021be6a0609da7df82d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="503" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="502" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af28312b8c309091f03e373e1ae5f3d46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="513" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="512" bodyend="520"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adff86e062c6497110b7505b0ef715c2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="523" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="522" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b4a64905c9d681c174b2dfcfba272c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="536" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="535" bodyend="546"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a520b72efca1fbe800845b21a84d2d472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="551" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="550" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1222c1fe6037feb8eacf0d2bd5152751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="561" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="560" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71a8f2ebc458f06e29b17ecc28ed000d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="571" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="570" bodyend="581"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bc853f9410d964ef9f163ce53ea4828" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="584" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="583" bodyend="594"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a891589b60d1c968b44986f3b7d56586b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="597" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="596" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2a6e4104db7159c74673aacae14286ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="616" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="615" bodyend="630"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a95c0f9757ba86c696c6c5bfa874c8a49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="634" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="633" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d5dbf37b71d16d686dd0fdbad82f8fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="651" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="650" bodyend="661"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae187563f8f86e256bc1394edcba1b2b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;A, const T &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="664" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="663" bodyend="674"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a43db361f4a3128d89ad6a1db86686c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="677" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="676" bodyend="706"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6e4d2d791a5cbcbcf90de5da2250b4c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const vector_k&lt; U &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="709" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="708" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac7a042d0e04e0c610b5798017c8196d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const double &amp;a, const vector_k&lt; double &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="720" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="719" bodyend="725"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a06de45116e1111f3aca66cd18565e9ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="729" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="728" bodyend="734"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a05f53ae281350225540bf5b4f4d1259b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="737" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="736" bodyend="744"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad7f693a660597bd39cdca67ea4000a81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="748" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="747" bodyend="753"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab34753e2fc26c9fab1fcbee6700c691b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="757" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="756" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8afc5fb1383ec8d667f52ac3778df34c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="765" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="764" bodyend="772"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a18d99849477754b35d0a3187ceb60508" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="776" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="775" bodyend="782"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a77245a0566dc6436443ad15187512ef0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="786" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="785" bodyend="792"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a390125160a7febd08d5c30629f4f698f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="795" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="794" bodyend="805"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5daa1c95786fd3745687914963e7229e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="808" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="807" bodyend="811"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5b10f703c72875b9f5e2ecc5c7696f9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="814" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="813" bodyend="824"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3852c35cfcc8caa784465a26d04c68a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="827" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="826" bodyend="837"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afce3d5f6cf95bb68e12f3f80ff146ed8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="840" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="839" bodyend="847"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acf439f423c568a970ddc8cde5940a0e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="851" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="850" bodyend="857"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aef7e4ab9c187ffa93e45ec90e2d1d5d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="861" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="860" bodyend="867"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aafc0089bdf204385c1e627755c5070b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="870" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="869" bodyend="880"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa5daf45d6627feee18402005fcd83cfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="883" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="882" bodyend="890"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3fad354ed572051e939cc71209c112ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="896" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="895" bodyend="898"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aea600162295a122a2371d75f80f764c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="903" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="902" bodyend="905"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a62fe1fbcb9ed4e33c5b31dc2c77bdbc4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="911" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="910" bodyend="913"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab89a85c0315b92a6844a77e352b5d50b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="918" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="917" bodyend="920"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a917607e20e487553be913b7ccaa4736d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="926" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="925" bodyend="928"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1d9cd34e13780fffeb1de19287f5636d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="933" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="932" bodyend="935"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acd9678129c9effcca74b8fff47876b1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="941" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="940" bodyend="943"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af8995aedb4c636b77717bb09b37487be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cos of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="948" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="947" bodyend="950"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a25563b8ed483cdd3bbbaf647beb76ba8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="956" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="955" bodyend="958"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90f340395d16b059204d507250945f35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="963" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="962" bodyend="965"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abae345d963258d8db3de7630a21f7231" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="971" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="970" bodyend="973"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7310a65b84d58bffa91cd81d14fbf81a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="978" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="977" bodyend="980"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a877d94927f5459e9cdaa50c11e8ffd3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="986" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="985" bodyend="988"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1c98db9af87a464e8258138f98d9c029" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="993" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="992" bodyend="995"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae1811725cd4c1026bf8c9fa426694a6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1001" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1000" bodyend="1003"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c07a37d969167a8eafc372d39e84a22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1008" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1007" bodyend="1010"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71aba9c7d78e9bd5c0e7638e6fc526ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1016" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1015" bodyend="1018"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a159ccc6344c3e6dc8c3206890afd47d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1023" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1022" bodyend="1025"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4de772a2b10be65e2997cbb1f0f08853" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1031" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1030" bodyend="1033"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a25e9b69ef51cf53cc780fd5a99bcde1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1038" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1037" bodyend="1040"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abb06bdc0fc2627f8f5390e0b1da588c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1046" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1045" bodyend="1048"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a22e3ee37c7d6c67e9951d9546082b8b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1053" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1052" bodyend="1055"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71377e5dee3f47b001950fe0a1858722" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1061" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1060" bodyend="1063"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad67d2e26dfbe947035bcfdceda54f957" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1068" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1067" bodyend="1070"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3f3de1f36299e80f237c0e9669b9ee1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1076" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1075" bodyend="1078"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1b4681da0aec9ca45280970b47fd55d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1083" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1082" bodyend="1085"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a68ebe3cd64dbf2c0d09f33f5e7951317" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1091" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1090" bodyend="1093"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18fc1ec8072b5fdfd260346c66b2301" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1098" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1097" bodyend="1100"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9364d5d2e2a67359845a437550963985" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1106" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1105" bodyend="1108"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a506e11389a9ed0bfbd27f41a75df0719" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1113" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1112" bodyend="1115"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a06e575bbcbc7b7f0f97f70348699c172" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1121" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1120" bodyend="1123"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a89b9e24c6952c5216ed82d09e5683118" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1128" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1127" bodyend="1130"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa4b7e86c9291f2ca9c5aacdb8e08f9ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1136" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1135" bodyend="1138"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a38b52fad75e8cf7db8b8d3ee7d1a7412" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1143" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1142" bodyend="1145"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5bcff39b329c05d8feded07f03c211e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1151" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1150" bodyend="1153"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9238ebdadb19806695736975e6dcdf4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1158" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1157" bodyend="1160"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9642e67bdae5228a94fca58334c8f812" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1166" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1165" bodyend="1168"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad5290a246f96df2efa1ffc0f80685478" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1173" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1172" bodyend="1175"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af8482452959bd0ad0cee0e5704ae7851" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1181" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1180" bodyend="1183"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6bc00b1e07523727e7ae0e20ec1cf834" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1188" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1187" bodyend="1190"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8ae33fb19a521ab1ec1f22e7c39ca076" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eye</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>eye</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1193" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1192" bodyend="1201"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2824156817719ffe96a842dd0ef27ae5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;dim)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements along dimension dim. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements along dimension dim. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer value of the number of elements along the desired dimension. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1212" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1211" bodyend="1214"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae713df143a5e71da166f450e01a536e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref></type>
        <definition>matrix_size_type keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the size of matrix A. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the size of matrix A in a <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable containing the number of rows and cols. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1224" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1223" bodyend="1229"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5699c522088657287bf0ac01173b716c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1239" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1238" bodyend="1242"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac00f5a8f1eba98722c1aac6b637a18c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1251" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1250" bodyend="1254"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a388f91a0ccf34978ef9403ccd0c680bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1264" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1263" bodyend="1274"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af40d69ddd09826dae133a479cff545b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1283" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1282" bodyend="1290"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bb3ea9a842383b82c889179f25be9ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::initializer_list&lt; T &gt; &amp;</type>
          <declname>lst</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1293" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1292" bodyend="1320"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae9ef181e938a4d835bb1cfb049479117" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1323" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1322" bodyend="1347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a282ba9ffa45fecd5880534415b116cc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1350" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1349" bodyend="1395"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab56165975dd12a86b498134da71bde29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1398" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1397" bodyend="1414"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab202ed201891fd28216e6d21599d5895" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const vector_k&lt; T &gt; v1, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1417" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1416" bodyend="1430"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac1ff99e34619478096c271b38df1f3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1438" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1437" bodyend="1456"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aab613a4c8cc04981045fdea358931780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1464" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1463" bodyend="1479"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacd37d195541b2313b753b6e8839f916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs right array division on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1487" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1486" bodyend="1505"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab299ba9f0640c2f95fe2393f2eef6ed2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs right array division on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1513" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1512" bodyend="1528"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac57d32902cba2c399475015235aeccec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Performs left array division on matrices B and A. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1536" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1535" bodyend="1554"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acee6d21e4a11f11422cc5f47d37c0e72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v2, const vector_k&lt; U &gt; &amp;v1)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Performs left array division on vectors v2 and v1. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1562" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1561" bodyend="1577"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a87f2917e6a7c8e20d010aea0d8480668" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::sign</definition>
        <argsstring>(const T &amp;val)</argsstring>
        <name>sign</name>
        <param>
          <type>const T &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1580" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1579" bodyend="1582"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aaa2e17334911e8a447a5ef6c0cc54c3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::angle</definition>
        <argsstring>(const std::complex&lt; T &gt; &amp;x)</argsstring>
        <name>angle</name>
        <param>
          <type>const std::complex&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1585" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1584" bodyend="1587"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab4fe7e0308538622ae7d0b3a45182e0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>angle</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1591" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1590" bodyend="1593"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a05899b620c8859f8832ad3132efce6b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>angle</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1597" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1596" bodyend="1599"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5a9aef54bbe0cd6e85d9a41842a57f05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::max</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1602" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1601" bodyend="1614"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61e3069eeec7219d10f997367701e488" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::max</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1617" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1616" bodyend="1631"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9d09b9019cc0bd9ad23b814e8a50fe25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::max</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1634" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1633" bodyend="1641"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3f6e11da7ff0d018261f1d66703672af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::min</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1644" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1643" bodyend="1656"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa56d65d68004f40352c8e33bffb0e0eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::min</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1659" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1658" bodyend="1673"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a51bbe7de3141b751cc3ce36cdfb51000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::min</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1677" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1676" bodyend="1684"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7fd5ce0385e9cc7bed5b44ed8475e8aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>transpose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1689" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1688" bodyend="1699"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a24d241b78ac9d5764e08c3f03bdffd07" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>transpose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1704" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1703" bodyend="1711"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14503c0419f365433d88fa081d473210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1716" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1715" bodyend="1726"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9fc1e2c9bf6ee79ee28a6f25b7b55b23" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::ctranspose&lt; double &gt;</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>ctranspose&lt; double &gt;</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1731" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1730" bodyend="1733"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a60ac98094acdd80972dfd34d307489dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1738" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1737" bodyend="1745"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d3157bfc97800f25010c32280dde212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::sum</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the sum of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1750" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1749" bodyend="1757"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a022f7e64d039d6d8289e36edd440fc86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sum</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the sum of each column of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1762" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1761" bodyend="1769"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a049d8e50ce9c2c5e0b7a0ad95cc559b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::mat2vec</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>mat2vec</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Converts matrix A to a column vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1774" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1773" bodyend="1785"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6fb905e99ba06b2a005547e7f5d0f54f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::vec2mat</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>vec2mat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Converts a column vector to a 1 x length(v1) matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1790" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1789" bodyend="1801"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab690e7da060fb0e4c42e53cf65d76c7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::linspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const size_t &amp;N)</argsstring>
        <name>linspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between x1 and x2. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N equally spaced values between x1 and x2, inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1814" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1813" bodyend="1832"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e1c37fd71074c56e963be121e5de0f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::logspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const int &amp;N)</argsstring>
        <name>logspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between 10^(x1) and 10^(x2). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1847" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1846" bodyend="1863"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14be2eba762e42f7d04b9330d41c3f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::unwrap</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const T &amp;tol=pi)</argsstring>
        <name>unwrap</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>tol</declname>
          <defval>pi</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1866" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1865" bodyend="1883"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae2909bfb67450be6a6d53a62752a2106" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::mean</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>mean</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the mean of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1888" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1887" bodyend="1897"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a17458d17162284844399c9cc52be09ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1900" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1899" bodyend="2016"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af195484fa3f7653204623e2adc85d595" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2020" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2019" bodyend="2056"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b00eb8d7f354173545ef98ad9da47cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const matrix&lt; T &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2059" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2058" bodyend="2076"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4c080370a07cc78709cc7992b208567e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; vector_k&lt; T &gt; &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2080" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2079" bodyend="2102"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a50ca6544bccf005c1ac48b21facd349c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const matrix&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2105" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2104" bodyend="2122"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a63750d1400cd9787c78e2f1b8812e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const vector_k&lt; vector_k&lt; U &gt; &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2125" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2124" bodyend="2142"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a257d22daacd12b862ef18d5405ebf375" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::trapz</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const vector_k&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2145" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2144" bodyend="2162"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2fb57de964e3ede762e18ed0ad165ea1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::trapz</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2165" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2164" bodyend="2197"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7124131346b73357a9e7d8e7c4ae9cc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u, const int &amp;index=2)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>index</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2201" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2200" bodyend="2238"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae3bec60fc5a78f2c532ea1d1ad1d336" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2241" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2240" bodyend="2278"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2cab711aeb1a50fe342f7c01f9e0d74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const vector_k&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2281" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2280" bodyend="2300"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a354a712337d461286e6202d01200d615" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::fft</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;u, int N=-1)</argsstring>
        <name>fft</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2303" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2302" bodyend="2338"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa643664371f940c36634f2ce6b843ea2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_o_d_e__type" kindref="compound">ODE_type</ref>&lt; U, T &gt;</type>
        <definition>ODE_type&lt;U,T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, const std::initializer_list&lt; U &gt; &amp;x_span, vector_k&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type>const std::initializer_list&lt; U &gt; &amp;</type>
          <declname>x_span</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2368" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2367" bodyend="2398"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af93c8220d8d4d454f7fa57fe7db70aa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, vector_k&lt; U &gt; x_ode, vector_k&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt;</type>
          <declname>x_ode</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2402" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2401" bodyend="2428"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afcd6ae07fc18f5374868fe314f00108c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, double val)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2431" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2430" bodyend="2433"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae67eb981ff22ef79a4ee90a9a40ae21f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, std::initializer_list&lt; size_t &gt; list)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; size_t &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2436" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2435" bodyend="2438"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af9dec3da4533a1db21a6c6c4fe8e740a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::print</definition>
        <argsstring>(Figure &amp;h, std::string pterm, std::string pfilename)</argsstring>
        <name>print</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pterm</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pfilename</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2441" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2440" bodyend="2443"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abe567d1c5cdf91722dfbe5da89e859e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___matrix" kindref="compound">Sort_Matrix</ref>&lt; T &gt;</type>
        <definition>Sort_Matrix&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const size_t &amp;dim=2, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>dim</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2453" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2452" bodyend="2554"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0ab724c8ffc30f7beac54280a4ee81eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___vector" kindref="compound">Sort_Vector</ref>&lt; T &gt;</type>
        <definition>Sort_Vector&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2564" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2563" bodyend="2611"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af4a2245da139cf6cf2e03426476b3b88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::disp</definition>
        <argsstring>(const T &amp;x, std::ostream &amp;outStream=std::cout)</argsstring>
        <name>disp</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>outStream</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
<para>Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2618" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2617" bodyend="2621"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aba69db64fe38ad271de1939d3f1a5520" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::input</definition>
        <argsstring>(const std::string &amp;prompt, std::string option)</argsstring>
        <name>input</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prompt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>option</declname>
        </param>
        <briefdescription>
<para>Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as &quot;s&quot; because C++ is a statically typed language. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2628" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2627" bodyend="2643"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bca7924aad17a920f2f5f0606e6d9a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::str2num</definition>
        <argsstring>(const std::string &amp;in)</argsstring>
        <name>str2num</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Converts a std::string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2649" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2648" bodyend="2651"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa605bad9095a6c529656926dc4fb35cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::length</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>length</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements in a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2657" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2656" bodyend="2659"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9c30ad952d4422425a171c12bdf33947" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::length</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>length</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the length of the largest dimension of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2665" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2664" bodyend="2669"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adcbcd3d38aa0721f2556422eb06cad7d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::numel</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>numel</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2673" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2672" bodyend="2675"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afbcf6804c0bcef12904db8880c451cea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; size_t &gt;</type>
        <definition>vector_k&lt;size_t&gt; keycpp::find</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const size_t &amp;k=-1, std::string start=&quot;&quot;)</argsstring>
        <name>find</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>k</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>start</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Finds and returns the indices of non-zero elements of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2681" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2680" bodyend="2740"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a97f0fc27cf8489f3f556fb1a0c975115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__find__type" kindref="compound">matrix_find_type</ref>&lt; T &gt;</type>
        <definition>matrix_find_type&lt;T&gt; keycpp::find</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>find</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Finds and returns the row and column indices and values of non-zero elements of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2755" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2754" bodyend="2779"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8e6462a878df6e022bd4f9aa6f953983" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const size_t &amp;m, const size_t &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2783" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2782" bodyend="2806"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e3e21956e9f34310b243bc45d68b238" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const size_t &amp;m, const size_t &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2810" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2809" bodyend="2812"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a04dabe064e99dd423157829c4b133261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::dot</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2818" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2817" bodyend="2833"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3b8c1401db056696103c4ad8f1aa48ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::dot</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2839" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2838" bodyend="2850"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3499b51e89dfda97b0dcf5dc2461926a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::dot</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2856" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2855" bodyend="2869"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0d4eac6fbefd72947d7fe26fada6c221" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::dot</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B, const size_t &amp;dim=-1)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>dim</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Computes the dot product between the first non-singleton dimension of A and B. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2875" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2874" bodyend="2902"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa590a6946f71f4c1b2e575bdb791f00f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::cross</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>cross</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2909" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2908" bodyend="2924"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a78ea0301dbb858bbfdf2646a857a1ec6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2939" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2938" bodyend="2983"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb34bdd249af3ce92341cdda62f95f65" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2985" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4242" bodyend="4283"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a838fc93d66e1ab63d68d04781086d81a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; double, double &gt;</type>
        <definition>SVD_type&lt; double, double &gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2986" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4287" bodyend="4428"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad211ab5ae14ac9710265c662f70f20ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2987" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4430" bodyend="4471"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad610adca37ac4c85df23b899d29d5dfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; std::complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt; std::complex&lt; double &gt;, double &gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2988" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4475" bodyend="4618"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb9efbc77cc58fa22403ea7ae5f4555c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::rank</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>rank</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2995" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2994" bodyend="2998"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8f497e2da901adba0e1257be943595a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::null</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>null</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the nullspace of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3004" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3003" bodyend="3027"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a70b89ab3e8f66f86c47c3bde004d4487" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>any</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3033" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3032" bodyend="3039"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ade6d308fd22d34ad4860e5fcd22ccb39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>any</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3045" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3044" bodyend="3057"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af40fa7667b60f30a3b0912464d382d57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>any</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3063" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3062" bodyend="3072"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aab77d82d9cc7d1fcca87967048f09e0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>all</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3078" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3077" bodyend="3084"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0ebd51ca90981278382a922c04ee7a75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>all</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3090" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3089" bodyend="3102"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9fe10fe179c6988a6f72e3715197457c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>all</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3108" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3107" bodyend="3117"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a97c154d91210f0af72e5047649ab2fb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>finite</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3124" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3123" bodyend="3135"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8879482fc9af1a809453e1719948263b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>finite</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3142" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3141" bodyend="3152"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83702fd83d07f4e3822abdcba5819dcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>finite</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3159" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3158" bodyend="3166"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a852be6145adcca15ceaeb5a138651e20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isinf</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isinf</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3173" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3172" bodyend="3175"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abf12e8a9c04720e074328bb1d34dce04" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isinf</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3182" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3181" bodyend="3192"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af104a680d8727dc0653925a834764ab4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isinf</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3199" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3198" bodyend="3206"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad3b16064066dc041be364e6fbefa173a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isnan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3213" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3212" bodyend="3223"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad91dbdf14632d313a304d3ddbadf935f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isnan</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isnan</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3230" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3229" bodyend="3232"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac54a98797b243f8f8b13b897cdeeba1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isnan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3239" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3238" bodyend="3246"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acc2de8926c54a2048a0d8965e7d70995" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isempty</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if matrix is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3252" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3251" bodyend="3254"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aef3406643c82187b13c5ab0b6da788b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isempty</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if vector is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3260" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3259" bodyend="3262"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a81a8c955cdbeb60181f6bf7d6553ac53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isreal</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3268" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3267" bodyend="3274"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a62d7118882bac24ab403ffb5f8ee7034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isreal</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3280" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3279" bodyend="3292"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5db41667f15caabbbdf37362e2f1990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isreal</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3298" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3297" bodyend="3307"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a005c1190f7087fb1d2545c38c080fd1a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::ceil</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>ceil</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Rounds the real and imaginary parts of std::complex&lt;double&gt; a towards positive infinity seperately. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3313" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3312" bodyend="3317"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abc86c63af2d6788c45ac99a1f3b14ad8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>ceil</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of v1 towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3323" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3322" bodyend="3330"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bba31744fef3693901a075fda07857c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ceil</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of A towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3336" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3335" bodyend="3346"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae7de6c3e5c495e91b1b1de7d716e7a5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::polyval</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;p, const U &amp;x)</argsstring>
        <name>polyval</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3350" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3349" bodyend="3359"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a21cb545ca871d88bcd449b61bd8bdbfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::roots</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;p)</argsstring>
        <name>roots</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3366" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3365" bodyend="3375"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6069a9eec0edfa1d401230013d98765e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref></type>
        <definition>tictoc_type keycpp::tic</definition>
        <argsstring>()</argsstring>
        <name>tic</name>
        <briefdescription>
<para>Start the timer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3387" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3386" bodyend="3391"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afe03fbbb5126729fb4b9367097acb1d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::toc</definition>
        <argsstring>(tictoc_type &amp;Timer)</argsstring>
        <name>toc</name>
        <param>
          <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref> &amp;</type>
          <declname>Timer</declname>
        </param>
        <briefdescription>
<para>Stop the timer. The number of elapsed seconds is returned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3396" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3395" bodyend="3400"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::sprintf</definition>
        <argsstring>(const std::string &amp;fmt,...)</argsstring>
        <name>sprintf</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Overload of the C++ function <ref refid="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" kindref="member">sprintf()</ref>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3406" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3405" bodyend="3435"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a806f0afebdf1131be26a05d7a4a23044" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; size_t &gt;</type>
        <definition>vector_k&lt;size_t&gt; keycpp::clock</definition>
        <argsstring>()</argsstring>
        <name>clock</name>
        <briefdescription>
<para>Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3442" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3441" bodyend="3454"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac20bd2ef4fb18cbcdb0f462a89447bd7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::pinv</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>pinv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3461" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3460" bodyend="3482"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad70d9156c4b6a75e5b7a4c799f900162" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::removeWhiteSpace</definition>
        <argsstring>(std::string in)</argsstring>
        <name>removeWhiteSpace</name>
        <param>
          <type>std::string</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3485" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3484" bodyend="3503"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac5c0a8bc58229a412ec2068979b6b84e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::importdata</definition>
        <argsstring>(std::string filename)</argsstring>
        <name>importdata</name>
        <param>
          <type>std::string</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Returns a matrix containing the data read from a text file. Values must be white space separated. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3507" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3506" bodyend="3553"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61234b7bb0f3126b3db82634675c2951" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::stdev</definition>
        <argsstring>(vector_k&lt; T &gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3558" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3557" bodyend="3568"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abdec07a4c4dd0fc5de230a753bf59066" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::stdev</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3572" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3571" bodyend="3582"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a553528cf7a020895037ce3b1a828a04c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::var</definition>
        <argsstring>(vector_k&lt; T &gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3587" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3586" bodyend="3589"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af3249effde70a573fbd8881dc4629e04" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::var</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3593" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3592" bodyend="3595"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab99a9561cf5654ae722a0879b41d9d73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const unsigned int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an N x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3607" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3606" bodyend="3618"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af6413232f2de6f8ac96efde6531c3055" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const unsigned int &amp;M, const unsigned int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an M x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3623" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3622" bodyend="3634"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa14e19e286b30265734236c0af2f9e78" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Double precision eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3836" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3835" bodyend="3846"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a16b58f47ed977cafdc96227468f5f10a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, double *ALPHA, const double *A, const int *LDA, const double *B, const int *LDB, double *BETA, double *C, const int *LDC)</argsstring>
        <name>dgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a29fb4e46ee1b9cce0fd8bc79a2490c72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *B, const int *LDB, std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *C, const int *LDC)</argsstring>
        <name>zgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af0676a4a89dbb63f09fc627c05e12699" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const double *ALPHA, const double *A, const int *LDA, const double *X, const int *INCX, const double *BETA, double *Y, const int *INCY)</argsstring>
        <name>dgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="26"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aea174778653491b5fd21dd2960c0f7cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *X, const int *INCX, const std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *Y, const int *INCY)</argsstring>
        <name>zgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="31"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adfb32fd99bb09455f5a124df4560ab0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator==</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="124" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="123" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9358d5f3f08dd8ed262697b7e8b2a4f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator!=</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="128" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="127" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a689a724b505d52660e42e1148eba1a9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator&lt;</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="132" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="131" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7330eaaa701d2308c19f84adda097685" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator&gt;</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="136" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="135" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9b02f40e92cad47b419ac09207518b9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator&lt;=</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="140" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="139" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af6e928cddf953cbdd90b0cd6f3802b24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::operator&gt;=</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="144" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="143" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad88546738baf0a658bbe540827343939" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt;::difference_type</type>
        <definition>PointerIterator&lt;T&gt;::difference_type keycpp::operator-</definition>
        <argsstring>(const PointerIterator&lt; T &gt; &amp;r1, const PointerIterator&lt; T &gt; &amp;r2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1_pointer_iterator" kindref="compound">PointerIterator</ref>&lt; T &gt; &amp;</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/vector_k.h" line="149" bodyfile="/media/Storage/Research/open_source/keycpp/include/vector_k.h" bodystart="147" bodyend="149"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="31"/>
  </compounddef>
</doxygen>
