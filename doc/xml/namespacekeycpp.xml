<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3.1">
  <compounddef id="namespacekeycpp" kind="namespace">
    <compoundname>keycpp</compoundname>
    <innerclass refid="classkeycpp_1_1_figure_exception" prot="public">keycpp::FigureException</innerclass>
    <innerclass refid="classkeycpp_1_1_plots" prot="public">keycpp::Plots</innerclass>
    <innerclass refid="classkeycpp_1_1_figure" prot="public">keycpp::Figure</innerclass>
    <innerclass refid="classkeycpp_1_1_key_cpp_exception" prot="public">keycpp::KeyCppException</innerclass>
    <innerclass refid="structkeycpp_1_1observe" prot="public">keycpp::observe</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___matrix" prot="public">keycpp::Sort_Matrix</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___vector" prot="public">keycpp::Sort_Vector</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__find__type" prot="public">keycpp::matrix_find_type</innerclass>
    <innerclass refid="structkeycpp_1_1_s_v_d__type" prot="public">keycpp::SVD_type</innerclass>
    <innerclass refid="structkeycpp_1_1tictoc__type" prot="public">keycpp::tictoc_type</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__size__type" prot="public">keycpp::matrix_size_type</innerclass>
    <innerclass refid="classkeycpp_1_1_matrix_exception" prot="public">keycpp::MatrixException</innerclass>
    <innerclass refid="classkeycpp_1_1matrix" prot="public">keycpp::matrix</innerclass>
    <innerclass refid="classkeycpp_1_1_spline_exception" prot="public">keycpp::SplineException</innerclass>
    <innerclass refid="classkeycpp_1_1_extrap" prot="public">keycpp::Extrap</innerclass>
    <innerclass refid="classkeycpp_1_1_spline" prot="public">keycpp::Spline</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacekeycpp_1ace2501951ab3db3a91c3520ae89750b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zggev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zggev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex generalized eigenvalue solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="49"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aebc5253e80ac15a9bfdc5449ae4f972a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgeev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</argsstring>
        <name>dgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wi</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c1cca2a162f40fc6c6218c35cadf9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgeev_</definition>
        <argsstring>(const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>w</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VL</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VR</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="59"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aca3be6524e195662cbb74a810305e721" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgecon_</definition>
        <argsstring>(const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</argsstring>
        <name>dgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>iwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="64"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a75e334ffaf1864d7191e9e0b64189783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrf_</definition>
        <argsstring>(const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>dgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="68"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab9c33788a2c083aa5738eda1fe62a261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</argsstring>
        <name>dgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4507ef954be960fec70ca0f93258d730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::dlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</argsstring>
        <name>dlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="76"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a444e3cdc7e7929414370b6b50ea1218c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgecon_</definition>
        <argsstring>(const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</argsstring>
        <name>zgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex-valued reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="81"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18d58d53d8e19a37d74d24da27a64dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrf_</definition>
        <argsstring>(const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>zgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="85"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abbe4322276dcdb7d864e85854b5b90f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</argsstring>
        <name>zgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="89"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1477c910b07baef984fe8528c29b2774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::zlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</argsstring>
        <name>zlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="93"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a12719f4b48de048f9642066666a920bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesv_</definition>
        <argsstring>(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</argsstring>
        <name>dgesv_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision linear system solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="97"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af92d0d887ae48cc4222f7167232a7f82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetri_</definition>
        <argsstring>(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</argsstring>
        <name>dgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4190e125fe33133aafa586089ca6e174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetri_</definition>
        <argsstring>(const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</argsstring>
        <name>zgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8fe7a71afbb6c5dc049cdd7afff6c0af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</argsstring>
        <name>dgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="109"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa5e2f74110f53bd288c15ce1f183f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="114"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6aca656320e1b26861469a979a96066f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; A, const matrix&lt; std::complex&lt; double &gt; &gt; B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="120"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8b42273cb371e35064445ce84e26d944" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="124"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7e4c1a584c274bb164e0e207a13ec63e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="128"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a08b7545ff5c1295647680d08f2953875" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; double &gt; A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="130" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="253" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5cc586899ece36154e39201f18e6db55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="131" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="300" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9f68b3d9143ad3582e59dd0a4b1998b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="133"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a46f4a25648e5bad1cf0bd0e7fca7fae0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt; double &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="135" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="437" bodyend="523"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adc96927cda2df7a6e8e2031941c43601" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="136" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="525" bodyend="595"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b74369f5415c3ed45f63995149ad992" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="137"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef5c1f5951e8182a7c4ec9612f3f7e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rand</definition>
        <argsstring>()</argsstring>
        <name>rand</name>
        <briefdescription>
<para>Returns a random double between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="139" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="10" bodyend="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a53e0eb41dbd6cddc6ac15d92d68c7aee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(int N)</argsstring>
        <name>rand</name>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an N x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="140" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="17" bodyend="29"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adbc446e99edbcde1d69bfe2c74dc3c80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::rand</definition>
        <argsstring>(int M, int N)</argsstring>
        <name>rand</name>
        <param>
          <type>int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an M x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="141" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="33" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e8bada51586c0561e1b32ca1ab5f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="160" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="159" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a300d8f6e8992c7b33156492d884bd621" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="174" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="173" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae8a5ac9572fd012881e19f850b0f47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::prod</definition>
        <argsstring>(const std::vector&lt; T &gt; x)</argsstring>
        <name>prod</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns the product of all the elements of the vector x. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="186" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="185" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0b348cee175715d20a1997b471c47d7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::prod</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a vector containing the product of all the elements in each column of the matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="204" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="203" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>diff</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns a vector of differences between adjacent elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="225" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="224" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0cf08572a2b7b23b6be5365053770fa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of row differences between adjacent rows. </para>        </briefdescription>
        <detaileddescription>
<para>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="244" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="243" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad26d6a2ad64185a749c6f2e85aeaf62b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::conj</definition>
        <argsstring>(const std::vector&lt; T &gt; x)</argsstring>
        <name>conj</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="261" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="260" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5cbc9dd508d193697eb9dfbef01f1404" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;double&gt; &gt; keycpp::conj</definition>
        <argsstring>(const matrix&lt; T &gt; x)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="271" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="270" bodyend="281"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a76cd22caf522d677271fb915fb3aec37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::real</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>real</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="284" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="283" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a22cc33e0299a65158c81352603bcd35a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::imag</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>imag</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="294" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="293" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a01edbbe2645ae65b6ec2c08b2d4352e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::abs</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>abs</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="304" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="303" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a70d66686c6b209cc8eb64f84977544da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::arg</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>arg</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="314" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="313" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a952e5296774667c3be4e792b5cd980da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const double &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="324" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="323" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4da6882977b2262f8d6f080b0eaf60c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="329" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="328" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab185edce957f4afd65cb641ec6307376" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="339" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="338" bodyend="346"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d5dbf37b71d16d686dd0fdbad82f8fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="349" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="348" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae187563f8f86e256bc1394edcba1b2b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;A, const T &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="362" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="361" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6dcf10b0db68d53d126803e8d6d591fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="375" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="374" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b523ff3dd5abac240788f6efb2e554e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="407" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="406" bodyend="414"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2e9a06b12f7df18005a3daa3c051b2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="417" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="416" bodyend="424"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac2665554c04ea23aad98e77d1618ca6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="427" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="426" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a390125160a7febd08d5c30629f4f698f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="437" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="436" bodyend="447"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3852c35cfcc8caa784465a26d04c68a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="450" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="449" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a394f23f09cf122a8e8c20a7afd40f58e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="463" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="462" bodyend="470"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1ebc4ddf6e567714f63f0dbb8a984745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="475" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="474" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a159a28c69282a740e381465a0e71bf23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="487" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="486" bodyend="497"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afaf5c65950c36d6a10e2fc42cae7b041" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="502" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="501" bodyend="509"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6d906ad1b0afbefd588c619cdb02530a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="514" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="513" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2d4f2ab79da4b10e9be3af2693904ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const std::vector&lt; T &gt; v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="529" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="528" bodyend="536"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a24ac535f72f9e72bf2d0fb93b2b0ee01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a matrix containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="541" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="540" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90a6f9aaec03f1f72bf4013316795c5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eye</definition>
        <argsstring>(const int N)</argsstring>
        <name>eye</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="554" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="553" bodyend="562"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2dc5102775ed955f378432f84fe96987" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; A, const int dim)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements along dimension dim. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements along dimension dim. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer value of the number of elements along the desired dimension. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="573" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="572" bodyend="575"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a028e501a865c86bdf616ea13e87645fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref></type>
        <definition>matrix_size_type keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; A)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the size of matrix A. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the size of matrix A in a <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable containing the number of rows and cols. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="585" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="584" bodyend="590"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a86f1406f9fad5a439d8eff01aba8eac6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int M, const int N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="600" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="599" bodyend="603"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a17115c92ffe695fd6ecb002f5ded220a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="612" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="611" bodyend="615"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ace6f21832ab61f8f15e5b35e0a5cdb3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int M, const int N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="625" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="624" bodyend="635"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a31175b3ba618b338b185cd02a27addfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="644" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="643" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa2a7959f650bb0b6d214c2a74eed846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::initializer_list&lt; T &gt; &amp;lst, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::initializer_list&lt; T &gt; &amp;</type>
          <declname>lst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="654" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="653" bodyend="681"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e321022a262bb25cbcdc4d3186001b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="684" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="683" bodyend="708"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7f3ca84f887fb11aee5b219c03429096" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const matrix&lt; T &gt; A, int d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="711" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="710" bodyend="756"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a40a637f210b03a3901cafbd6c1a7e83f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const matrix&lt; T &gt; A, int m, int n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="759" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="758" bodyend="775"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a59fbea40dfc2d43cd338812f06c4f064" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, int m, int n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="778" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="777" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac1ff99e34619478096c271b38df1f3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="799" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="798" bodyend="817"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90d5fd4f9f7c52f16425105995655e9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>times</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="825" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="824" bodyend="840"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacd37d195541b2313b753b6e8839f916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs right array division on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="848" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="847" bodyend="866"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af234cd07a4e1d649629a6b83dbe113ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs right array division on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="874" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="873" bodyend="889"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac57d32902cba2c399475015235aeccec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Performs left array division on matrices B and A. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="897" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="896" bodyend="915"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a86bc7e25833cdf9266c038a4edb0ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>const std::vector&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Performs left array division on vectors v2 and v1. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="923" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="922" bodyend="938"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8f1cd159623e23abeedd26d34fc500d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::sign</definition>
        <argsstring>(T val)</argsstring>
        <name>sign</name>
        <param>
          <type>T</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="941" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="940" bodyend="943"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abebb8d8939a33f6c3cb00be9278114c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::max</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>max</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="946" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="945" bodyend="958"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8ef49e492f67187d0909c7ae093fee48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::min</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>min</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="961" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="960" bodyend="973"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83c90b0df3a170c845b848593be4cb74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::angle</definition>
        <argsstring>(T x)</argsstring>
        <name>angle</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="976" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="975" bodyend="978"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a13ee1c3dd9cbb21a325260188a7fa860" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; double &gt;</type>
        <definition>std::vector&lt;double&gt; keycpp::angle</definition>
        <argsstring>(std::vector&lt; T &gt; x)</argsstring>
        <name>angle</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="981" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="980" bodyend="989"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a73269c9db9fe25412819858bd7048ae5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::max</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt; &gt; x)</argsstring>
        <name>max</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="992" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="991" bodyend="1006"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aed77b31791ec78800e98ace1cbc3693d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::max</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1009" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1008" bodyend="1016"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab7577228b38fa6a1911ac65fb80832f3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::min</definition>
        <argsstring>(std::vector&lt; std::complex&lt; double &gt; &gt; x)</argsstring>
        <name>min</name>
        <param>
          <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1019" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1018" bodyend="1033"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d8183bfe936dc877f32f86a43daa1b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::min</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1037" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1036" bodyend="1044"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad68697505d1a1a85f30a18b0e9b0eb2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>transpose</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1049" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1048" bodyend="1059"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa148d677899a0da5ab14edfc5057a97b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>transpose</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1064" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1063" bodyend="1071"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a88081df8038d0b630d6a3540aeca8b9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>ctranspose</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1076" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1075" bodyend="1086"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6f5c30b22d7f6eb02fb9b7ebfb6d50ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::ctranspose&lt; double &gt;</definition>
        <argsstring>(matrix&lt; double &gt; A)</argsstring>
        <name>ctranspose&lt; double &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1091" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1090" bodyend="1093"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a827218d19d98cf1357032a652a9bf4e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1098" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1097" bodyend="1105"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad05b888638b5ea7103bdc6ba0882d47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::sum</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>sum</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the sum of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1110" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1109" bodyend="1117"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4aedb589e76ced5d79d62c5f72029adb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::sum</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>sum</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the sum of each column of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1122" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1121" bodyend="1129"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8a0e8201f775945a0a61d6d645a3456e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::mat2vec</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>mat2vec</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Converts matrix A to a column vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1134" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1133" bodyend="1145"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d3ef9b10b3db438529bafc5e74fa0dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::vec2mat</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>vec2mat</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Converts a column vector to a 1 x length(v1) matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1150" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1149" bodyend="1161"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab57eee495c93eb18ebf8c8ccf4d44e74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::linspace</definition>
        <argsstring>(const T x1, const T x2, const int N)</argsstring>
        <name>linspace</name>
        <param>
          <type>const T</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between x1 and x2. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N equally spaced values between x1 and x2, inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1174" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1173" bodyend="1192"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac92462e3b25414144d4e45fc269d2f13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::logspace</definition>
        <argsstring>(const T x1, const T x2, int N)</argsstring>
        <name>logspace</name>
        <param>
          <type>const T</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between 10^(x1) and 10^(x2). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1207" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1206" bodyend="1223"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4e350b4b11ea4d9962b4daa13cc66e32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::unwrap</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1, T tol=pi)</argsstring>
        <name>unwrap</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T</type>
          <declname>tol</declname>
          <defval>pi</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1226" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1225" bodyend="1243"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad1acd03db6a49523cb5dbe751a80917a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::mean</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v1)</argsstring>
        <name>mean</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the mean of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1248" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1247" bodyend="1257"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a123211086c4953fe9346acc22b2a67f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, U x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>U</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1260" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1259" bodyend="1376"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a56633eb0878a0dbe6596fb0e74fdc6ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1380" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1379" bodyend="1416"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad6dfc562f4ab516d21be63ab8a9c1b23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, matrix&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1419" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1418" bodyend="1436"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3b44770c6a8c5ba4acb6fe6ead6cc811" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; std::vector&lt; T &gt; &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; T &gt; &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1440" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1439" bodyend="1462"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac5ab894467bbea180c9b283895d5d5d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, matrix&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1465" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1464" bodyend="1482"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4c19f6ff8e0001eca5c63529bd58e664" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; std::vector&lt; U &gt; &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; U &gt; &gt;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1485" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1484" bodyend="1502"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad817c482d12509f0938849890bb4de4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::trapz</definition>
        <argsstring>(std::vector&lt; U &gt; eta, std::vector&lt; T &gt; integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1505" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1504" bodyend="1522"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a379324b1d1cb219fdde96c9678aa5341" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(matrix&lt; U &gt; eta, matrix&lt; T &gt; u, int index=2)</argsstring>
        <name>diffxy</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1526" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1525" bodyend="1563"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5b09f118fe12b83865ff08fe3d3633ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(std::vector&lt; U &gt; eta, matrix&lt; T &gt; u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1566" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1565" bodyend="1603"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3bdbcb862d76b1b1fb5157788b7336ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(std::vector&lt; U &gt; eta, std::vector&lt; T &gt; u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1606" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1605" bodyend="1625"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b17b3d224192fffc838834ff736d572" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;std::complex&lt;double&gt; &gt; keycpp::fft</definition>
        <argsstring>(std::vector&lt; T &gt; u, int N=-1)</argsstring>
        <name>fft</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1628" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1627" bodyend="1663"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a880f7df231a78f912b3fb5d301c809f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>x_ode</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1667" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1666" bodyend="1692"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afcd6ae07fc18f5374868fe314f00108c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, double val)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1695" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1694" bodyend="1697"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a261a9d83dcc8786777d193575b7e1a1c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, std::initializer_list&lt; int &gt; list)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; int &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1700" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1699" bodyend="1702"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6862448bf6e09309e60a6ba7aa0caf9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___matrix" kindref="compound">Sort_Matrix</ref>&lt; T &gt;</type>
        <definition>Sort_Matrix&lt;T&gt; keycpp::sort</definition>
        <argsstring>(matrix&lt; T &gt; A, int dim=2, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dim</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1712" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1711" bodyend="1813"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1be4e97b99a996a01f428fd8ba048fb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___vector" kindref="compound">Sort_Vector</ref>&lt; T &gt;</type>
        <definition>Sort_Vector&lt;T&gt; keycpp::sort</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1823" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1822" bodyend="1870"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6498ae080f530236ae3f7756f81ac78e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::disp</definition>
        <argsstring>(T x)</argsstring>
        <name>disp</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1877" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1876" bodyend="1880"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2eb6a6f7647e6ff700b7992faecd986d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::input</definition>
        <argsstring>(std::string prompt, std::string option)</argsstring>
        <name>input</name>
        <param>
          <type>std::string</type>
          <declname>prompt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>option</declname>
        </param>
        <briefdescription>
<para>Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as &quot;s&quot; because C++ is a statically typed language. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1887" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1886" bodyend="1902"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac056ba33ff8585d5680daf09a45ff8e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::str2num</definition>
        <argsstring>(std::string in)</argsstring>
        <name>str2num</name>
        <param>
          <type>std::string</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Converts a string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1908" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1907" bodyend="1910"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e62ad4a7f9b872d69df78c09e3f7b59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>length</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements in a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1916" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1915" bodyend="1918"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afaef726cb38faec462ac53cff08ab113" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::length</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>length</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the length of the largest dimension of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1924" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1923" bodyend="1928"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14d8a9ae8d6988eeff52fa777e75bd20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::numel</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>numel</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1932" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1931" bodyend="1934"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af93acd2c9e3e2e47bbf796143b994a18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; keycpp::find</definition>
        <argsstring>(std::vector&lt; T &gt; v1, int k=-1, std::string start=&quot;&quot;)</argsstring>
        <name>find</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>start</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Finds and returns the indices of non-zero elements of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1940" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1939" bodyend="1999"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5c7bf08adf4c09275f9e16cd510b7357" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__find__type" kindref="compound">matrix_find_type</ref>&lt; T &gt;</type>
        <definition>matrix_find_type&lt;T&gt; keycpp::find</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>find</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Finds and returns the row and column indices and values of non-zero elements of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2014" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2013" bodyend="2038"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9c4772f020269af1ae89c9cb0164d81c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(matrix&lt; T &gt; A, int m, int n)</argsstring>
        <name>reshape</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2042" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2041" bodyend="2065"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab8f45bfa36c10a24c117fb96be879cce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(std::vector&lt; T &gt; v1, int m, int n)</argsstring>
        <name>reshape</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2069" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2068" bodyend="2071"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abcee2445c0961997ba6e9d16070b2f8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::dot</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::vector&lt; U &gt; v2)</argsstring>
        <name>dot</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2077" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2076" bodyend="2092"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a52f48322f62e9bf11da0acb06deadd63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::dot</definition>
        <argsstring>(matrix&lt; T &gt; A, matrix&lt; U &gt; B, int dim=-1)</argsstring>
        <name>dot</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dim</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Computes the dot product between the first non-singleton dimension of A and B. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2098" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2097" bodyend="2125"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1013b624bcc27f0953dfb989bacfe446" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::cross</definition>
        <argsstring>(std::vector&lt; T &gt; v1, std::vector&lt; U &gt; v2)</argsstring>
        <name>cross</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::vector&lt; U &gt;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2132" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2131" bodyend="2147"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa01035a2b2a07cd56c5e36d5f289b2ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const std::vector&lt; T &gt; v1, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2160" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2159" bodyend="2204"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7e5236252f6a33f3523fb805a2d1727c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; double &gt; A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2206" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="670" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b80bd145aab03a9e79a42d32ca573bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; double, double &gt;</type>
        <definition>SVD_type&lt; double, double &gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; double &gt; A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2207" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="724" bodyend="864"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a867ba604b4e72e41b123f890dd66d854" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2208"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa6d15c3c38ff98e6d9afdd9db4b46c6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; std::complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;std::complex&lt;double&gt;,double&gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;&quot;)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2209"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4a7bb7923c2ff72fdf6a54ee1b891c16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::rank</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>rank</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2216" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2215" bodyend="2219"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a54f9ed89c437774e0f7391fd7d86e005" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::null</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>null</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the nullspace of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2225" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2224" bodyend="2248"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1dfbed1464b07ba22748542ce66de1cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(T a)</argsstring>
        <name>any</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2254" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2253" bodyend="2260"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e0536b6efa09624ea3738bbb9975dea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>any</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2266" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2265" bodyend="2278"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adee9ea3e8989009abba313a2f7d44d46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>any</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2284" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2283" bodyend="2293"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab07f0a090e6135757d3483270b799454" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(T a)</argsstring>
        <name>all</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2299" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2298" bodyend="2305"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c576908958c419fc0cae34ce1a6a5c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>all</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2311" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2310" bodyend="2323"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa8ea92aa5e5e801a2e42f2eefabd659" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>all</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2329" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2328" bodyend="2338"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a672bb23cdf28919a10b079dd88daf9cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(T a)</argsstring>
        <name>finite</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2345" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2344" bodyend="2356"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a092a180cc054e61d0dad651dd24ff990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>finite</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2363" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2362" bodyend="2373"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6640e5ff779655aed8078c5de81af7ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>finite</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2380" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2379" bodyend="2387"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aad386cc17ed36e85bfabfdda0839cf37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(T a)</argsstring>
        <name>isinf</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2394" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2393" bodyend="2405"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5509d3411ee687acf00877d8ea778679" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>isinf</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2412" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2411" bodyend="2422"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9eda7f3fa78584067175d39938bb6357" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>isinf</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2429" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2428" bodyend="2436"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac349e60ff1e46b3d3767d0dc7637fc1e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(T a)</argsstring>
        <name>isnan</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2443" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2442" bodyend="2454"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab0029f014e47906bcd76adf477fb7101" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>isnan</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2461" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2460" bodyend="2471"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a813517958b7e5d86ba3b56c4f9ad0d19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>isnan</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2478" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2477" bodyend="2485"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad7106f0902ce8169152f5cc485cfc6cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>isempty</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if matrix is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2491" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2490" bodyend="2493"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2850064955d23acf9c30c3d845ddf175" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>isempty</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if vector is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2499" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2498" bodyend="2501"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa9254f7e1962dc694a08e9727a3a5a41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(T a)</argsstring>
        <name>isreal</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2507" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2506" bodyend="2513"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c7c18cc2902b575919c8fb8cee94020" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>isreal</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2519" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2518" bodyend="2531"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5945708a5829731b4049dc72c8f63678" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>isreal</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2537" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2536" bodyend="2546"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a48b81a22ef851cfac4d2f98eb6d182b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::ceil</definition>
        <argsstring>(std::complex&lt; double &gt; a)</argsstring>
        <name>ceil</name>
        <param>
          <type>std::complex&lt; double &gt;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Rounds the real and imaginary parts of complex&lt;double&gt; a towards positive infinity seperately. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2552" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2551" bodyend="2556"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa10f7052b5450926e1aa055510270d3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(std::vector&lt; T &gt; v1)</argsstring>
        <name>ceil</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of v1 towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2562" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2561" bodyend="2569"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a26cc754af2bdfab23c93e91017b84594" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>ceil</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of A towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2575" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2574" bodyend="2585"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afbf61ceccd7874c0d8b4ae62cd5bbc24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; T &gt;</type>
        <definition>std::vector&lt;T&gt; keycpp::roots</definition>
        <argsstring>(std::vector&lt; T &gt; p)</argsstring>
        <name>roots</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2592" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2591" bodyend="2601"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6069a9eec0edfa1d401230013d98765e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref></type>
        <definition>tictoc_type keycpp::tic</definition>
        <argsstring>()</argsstring>
        <name>tic</name>
        <briefdescription>
<para>Start the timer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2613" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2612" bodyend="2617"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afe03fbbb5126729fb4b9367097acb1d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::toc</definition>
        <argsstring>(tictoc_type &amp;Timer)</argsstring>
        <name>toc</name>
        <param>
          <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref> &amp;</type>
          <declname>Timer</declname>
        </param>
        <briefdescription>
<para>Stop the timer. The number of elapsed seconds is returned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2622" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2621" bodyend="2626"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7000bb4c8f066438ada598f0f810ba6c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::sprintf</definition>
        <argsstring>(const std::string fmt,...)</argsstring>
        <name>sprintf</name>
        <param>
          <type>const std::string</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Overload of the C++ function <ref refid="namespacekeycpp_1a7000bb4c8f066438ada598f0f810ba6c" kindref="member">sprintf()</ref>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2632" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2631" bodyend="2657"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aff2feefaeb946dd453d74ff51c66fe67" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; keycpp::clock</definition>
        <argsstring>()</argsstring>
        <name>clock</name>
        <briefdescription>
<para>Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2664" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2663" bodyend="2676"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5bb5afeca1d51f6349d1fa1d64a2f4d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::pinv</definition>
        <argsstring>(matrix&lt; T &gt; A)</argsstring>
        <name>pinv</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2683" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2682" bodyend="2704"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a190640edb8e634de02d302d94a29ee17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; A, const matrix&lt; complex&lt; double &gt; &gt; B, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Generalized complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="55" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="54" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeccfac59e68c6dc37cd89626ece3bd70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt; &gt; A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="150" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="149" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae6d82c320841cd42905abfbba464a45d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>vector&lt;complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; A, matrix&lt; complex&lt; double &gt; &gt; *vr_return, matrix&lt; complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Double precision eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="241" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="240" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acea0bb8f128ef0cdf55a79c50ceccb83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; complex&lt; double &gt; &gt;</type>
        <definition>std::vector&lt;complex&lt;double&gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const std::vector&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="351" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="349" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac9cabca49e9650ae8b5aadf5ee2f7f4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt;complex&lt;double&gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="598" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="597" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af1a41d0919918b5cf62ef28dd68217d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; complex&lt; double &gt;&gt; A_in, std::string method)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="867" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="866" bodyend="916"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a913fb7501259de640e7119a852adafc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt;complex&lt;double&gt;, double&gt; keycpp::svd</definition>
        <argsstring>(matrix&lt; complex&lt; double &gt;&gt; A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; complex&lt; double &gt;&gt;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" line="921" bodyfile="/media/Storage/Research/open_source/keycpp/src/keycpp.cpp" bodystart="920" bodyend="1062"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="30"/>
  </compounddef>
</doxygen>
