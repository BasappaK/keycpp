<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3.1">
  <compounddef id="namespacekeycpp" kind="namespace">
    <compoundname>keycpp</compoundname>
    <innerclass refid="classkeycpp_1_1_figure_exception" prot="public">keycpp::FigureException</innerclass>
    <innerclass refid="classkeycpp_1_1_plots" prot="public">keycpp::Plots</innerclass>
    <innerclass refid="classkeycpp_1_1_figure" prot="public">keycpp::Figure</innerclass>
    <innerclass refid="classkeycpp_1_1_key_cpp_exception" prot="public">keycpp::KeyCppException</innerclass>
    <innerclass refid="structkeycpp_1_1observe" prot="public">keycpp::observe</innerclass>
    <innerclass refid="structkeycpp_1_1_o_d_e__type" prot="public">keycpp::ODE_type</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___matrix" prot="public">keycpp::Sort_Matrix</innerclass>
    <innerclass refid="structkeycpp_1_1_sort___vector" prot="public">keycpp::Sort_Vector</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__find__type" prot="public">keycpp::matrix_find_type</innerclass>
    <innerclass refid="classkeycpp_1_1_s_v_d__type" prot="public">keycpp::SVD_type</innerclass>
    <innerclass refid="structkeycpp_1_1tictoc__type" prot="public">keycpp::tictoc_type</innerclass>
    <innerclass refid="structkeycpp_1_1matrix__size__type" prot="public">keycpp::matrix_size_type</innerclass>
    <innerclass refid="classkeycpp_1_1_matrix_exception" prot="public">keycpp::MatrixException</innerclass>
    <innerclass refid="classkeycpp_1_1matrix" prot="public">keycpp::matrix</innerclass>
    <innerclass refid="classkeycpp_1_1_spline_exception" prot="public">keycpp::SplineException</innerclass>
    <innerclass refid="classkeycpp_1_1_extrap" prot="public">keycpp::Extrap</innerclass>
    <innerclass refid="classkeycpp_1_1_spline" prot="public">keycpp::Spline</innerclass>
    <innerclass refid="classkeycpp_1_1vector__k" prot="public">keycpp::vector_k</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacekeycpp_1a8d3ada618b663c38fe93a45de99c4c50" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::pi</definition>
        <argsstring></argsstring>
        <name>pi</name>
        <initializer>= 3.1415926535897932384626433832795</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="41" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1a685afaae59aa4c6da87f11c00699c5d8" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::eps</definition>
        <argsstring></argsstring>
        <name>eps</name>
        <initializer>= std::numeric_limits&lt;double&gt;::epsilon()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="42" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1ac45d63b1cbd35b140f7d057d03b626df" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::Inf</definition>
        <argsstring></argsstring>
        <name>Inf</name>
        <initializer>= std::numeric_limits&lt;double&gt;::infinity()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="43" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacekeycpp_1a740d5b86942262cbcf119cd58a50f4fe" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double keycpp::NaN</definition>
        <argsstring></argsstring>
        <name>NaN</name>
        <initializer>= std::numeric_limits&lt;double&gt;::quiet_NaN()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="44" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacekeycpp_1a5b72a83172512bb554f5e443b9b366bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt; T &gt; keycpp::real</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>real</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="32" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="397" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61efb014b42cd8b02a81b4520c41ab2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::real</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>real</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="33" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="402" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a752e14fae8ca75a5702c89207a7cd983" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>imag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="34" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="407" bodyend="410"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad902a14fdaa4b744a8a11220f5be0161" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt; T &gt; keycpp::imag</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>imag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="35" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="412" bodyend="415"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0bf7cb9cbc44ac0b9e37ea84a7c460cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="752" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="751" bodyend="754"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0fd09e7b19e9c22430bb0e1b00a33067" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string format, std::string property1, double val1, std::string property2, double val2)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>format</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="757" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="756" bodyend="759"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae195fde461203ab0b36e03c693f9d346" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::Figure::plot&lt; std::complex&lt; double &gt; &gt;</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; y, std::string arguments, double val, double lw, double ps, std::string legend_entry)</argsstring>
        <name>Figure::plot&lt; std::complex&lt; double &gt; &gt;</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>arguments</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lw</declname>
        </param>
        <param>
          <type>double</type>
          <declname>ps</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>legend_entry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="762" bodyfile="/media/Storage/Research/open_source/keycpp/include/Figure.h" bodystart="761" bodyend="764"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e50932cc54f92bdd7e38c6438f4f1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::ddot_</definition>
        <argsstring>(const int *N, const double *a, const int *inca, const double *b, const int *incb)</argsstring>
        <name>ddot_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2ce99b4fe4a13b9c70ada81761eb0ca2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zdotu_</definition>
        <argsstring>(std::complex&lt; double &gt; *result, const int *N, const std::complex&lt; double &gt; *a, const int *inca, const std::complex&lt; double &gt; *b, const int *incb)</argsstring>
        <name>zdotu_</name>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>inca</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incb</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double dot product function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="57"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae99c5b242a21ba683701ccb6ab6534b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::daxpy_</definition>
        <argsstring>(const int *N, const double *alpha, const double *x, const int *incx, double *y, const int *incy)</argsstring>
        <name>daxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="60"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6460fa334239dde761d8f737b9438fed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zaxpy_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, const std::complex&lt; double &gt; *x, const int *incx, std::complex&lt; double &gt; *y, const int *incy)</argsstring>
        <name>zaxpy_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incy</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double vector addition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="63"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d249dd978770119c1b91d88009fefbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dscal_</definition>
        <argsstring>(const int *N, const double *alpha, double *x, const int *incx)</argsstring>
        <name>dscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="66"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad9dd69d0d355e4805a832813199f1dff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zscal_</definition>
        <argsstring>(const int *N, const std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *x, const int *incx)</argsstring>
        <name>zscal_</name>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>incx</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double scalar-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="69"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ace2501951ab3db3a91c3520ae89750b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zggev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zggev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex generalized eigenvalue solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="76"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aebc5253e80ac15a9bfdc5449ae4f972a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgeev_</definition>
        <argsstring>(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</argsstring>
        <name>dgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>wi</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vl</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>vr</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="81"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8c1cca2a162f40fc6c6218c35cadf9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgeev_</definition>
        <argsstring>(const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgeev_</name>
        <param>
          <type>const char *</type>
          <declname>jobvl</declname>
        </param>
        <param>
          <type>const char *</type>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>w</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VL</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvl</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VR</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvr</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex eigenvalue solver for a general matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="86"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aca3be6524e195662cbb74a810305e721" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgecon_</definition>
        <argsstring>(const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</argsstring>
        <name>dgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>iwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="91"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a75e334ffaf1864d7191e9e0b64189783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrf_</definition>
        <argsstring>(const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>dgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="95"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab9c33788a2c083aa5738eda1fe62a261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</argsstring>
        <name>dgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="99"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4507ef954be960fec70ca0f93258d730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::dlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</argsstring>
        <name>dlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="103"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a444e3cdc7e7929414370b6b50ea1218c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgecon_</definition>
        <argsstring>(const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</argsstring>
        <name>zgecon_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>anorm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rcond</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex-valued reciprocal condition number estimator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="108"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18d58d53d8e19a37d74d24da27a64dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrf_</definition>
        <argsstring>(const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</argsstring>
        <name>zgetrf_</name>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lpiv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU decomposition function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="112"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abbe4322276dcdb7d864e85854b5b90f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetrs_</definition>
        <argsstring>(const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</argsstring>
        <name>zgetrs_</name>
        <param>
          <type>const char *</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex LU solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="116"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1477c910b07baef984fe8528c29b2774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::zlange_</definition>
        <argsstring>(const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</argsstring>
        <name>zlange_</name>
        <param>
          <type>const char *</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex norm function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="120"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a12719f4b48de048f9642066666a920bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesv_</definition>
        <argsstring>(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</argsstring>
        <name>dgesv_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>nrhs</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldb</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision linear system solver. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="124"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af92d0d887ae48cc4222f7167232a7f82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgetri_</definition>
        <argsstring>(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</argsstring>
        <name>dgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="127"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4190e125fe33133aafa586089ca6e174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgetri_</definition>
        <argsstring>(const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</argsstring>
        <name>zgetri_</name>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ipiv</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex matrix inverse function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="131"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8fe7a71afbb6c5dc049cdd7afff6c0af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</argsstring>
        <name>dgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s double precision SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="136"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afa5e2f74110f53bd288c15ce1f183f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgesvd_</definition>
        <argsstring>(const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</argsstring>
        <name>zgesvd_</name>
        <param>
          <type>const char *</type>
          <declname>jobu</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>jobvt</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lda</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>S</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>U</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldu</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>VT</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>ldvt</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>lwork</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>rwork</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to LAPACK&apos;s complex SVD function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="141"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a516e693670ca88debd44ca9a48b2f225" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, const matrix&lt; std::complex&lt; double &gt; &gt; &amp;B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Generalized complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="147" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3643" bodyend="3732"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae24a17765339d2464a0cccb476782bff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Complex-valued eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="151" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3741" bodyend="3825"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a42950497e518f5882a0689bb78fa667f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vr_return</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; *</type>
          <declname>vl_return</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3905cfc35dbd146f5dbf7bcb5729c2c2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="157" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3848" bodyend="3893"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4d9a9dd04453e5a417f7a9eb8ae4391b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rcond</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A)</argsstring>
        <name>rcond</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="158" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3895" bodyend="3942"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa0c91a82f4eadf681f9a690d6f309665" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt; std::complex&lt; double &gt; &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="160" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3944" bodyend="4019"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a13a89a2c6d30c991f4de63ca8f62c0e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt; double &gt; keycpp::linsolve</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, const vector_k&lt; double &gt; &amp;b_in)</argsstring>
        <name>linsolve</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>b_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="162" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4022" bodyend="4096"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adc96927cda2df7a6e8e2031941c43601" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt; double &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="163" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4098" bodyend="4168"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9085342fc708fd5babae39321da3b89a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>matrix&lt; std::complex&lt; double &gt; &gt; keycpp::inv</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</argsstring>
        <name>inv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="164" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4170" bodyend="4240"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5ef5c1f5951e8182a7c4ec9612f3f7e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::rand</definition>
        <argsstring>()</argsstring>
        <name>rand</name>
        <briefdescription>
<para>Returns a random double between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="166" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3599" bodyend="3602"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac224964eb5e1a55c3f7d58f0e9b71d3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="167"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5c4b142a4101e9bb1df9f19efaf7d2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae90693acdaf666bd23bf861f2c0d28c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="172" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="171" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c6542964c7aaaccbee336567f64c03c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, T(*f)(const T &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const T &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="186" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="185" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3a1ba458353cfecef659b40e446baaf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="197" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="196" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a48fb1c8a89210ed78554ecd0bed92a59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, T(*f)(T))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="211" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="210" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5afc215befa38bf47fb52cff33794ebe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="222" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="221" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afc7610588aa92335352b2796ebdd359d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(const std::complex&lt; T &gt; &amp;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(const std::complex&lt; T &gt; &amp;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="236" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="235" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae14b016d01024e738c3110299ee58666" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="247" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="246" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a31115adc10089fbbc732d59362890af2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::eop</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(std::complex&lt; T &gt;))</argsstring>
        <name>eop</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>T(*)(std::complex&lt; T &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="261" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="260" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a55e8bada51586c0561e1b32ca1ab5f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="287" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="286" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a86f8946c126102b4467b70da16766b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; keycpp::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="301" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="300" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1add55ad2a40111d6368744a3d4144f25a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::prod</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns the product of all the elements of the vector x. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="313" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="312" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af5471fc9074471701bde9e68eb7971b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::prod</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>prod</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a vector containing the product of all the elements in each column of the matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="331" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="330" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a52c37ec9c41349fd6bd862b8ebdd01bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns a vector of differences between adjacent elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="352" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="351" bodyend="363"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abb4e57814fd30b7b8d4845bbc16c73e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diff</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>diff</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of row differences between adjacent rows. </para>        </briefdescription>
        <detaileddescription>
<para>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="371" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="370" bodyend="385"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a436cfe206bb34dfe613ac495e792b155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="388" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="387" bodyend="390"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0f000b392fbefccdb089383bb6a20151" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>matrix&lt;std::complex&lt;T&gt; &gt; keycpp::conj</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>conj</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="393" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="392" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83cec179e95af014706ce54194efd1b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="418" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="417" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa48f282087263edb46886e9390b9a833" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="423" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="422" bodyend="425"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1f83b48bfedf753904dfea9dde554a4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="428" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="427" bodyend="430"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae0edec63f48a81c576da0c0ffc768af9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::abs</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>abs</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="433" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="432" bodyend="435"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a952e5296774667c3be4e792b5cd980da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const double &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="438" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="437" bodyend="440"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8faa7912f1f198c5185cb6a36cfd2fb2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::csqrt</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="443" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="442" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa865f0bd18bdefcf413b1c3dd286b998" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="448" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="447" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae416b3cc307c30afdb62f0ed37b70e05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="467" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="466" bodyend="481"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ade9508aa24d2496bd63dcdb72229c8b0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="485" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="484" bodyend="499"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a68fe0fe851bce021be6a0609da7df82d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="502" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="501" bodyend="509"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af28312b8c309091f03e373e1ae5f3d46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v2)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="512" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="511" bodyend="519"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adff86e062c6497110b7505b0ef715c2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="522" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="521" bodyend="532"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4b4a64905c9d681c174b2dfcfba272c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator+</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="535" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="534" bodyend="545"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a520b72efca1fbe800845b21a84d2d472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="550" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="549" bodyend="557"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1222c1fe6037feb8eacf0d2bd5152751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="560" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="559" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71a8f2ebc458f06e29b17ecc28ed000d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="570" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="569" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bc853f9410d964ef9f163ce53ea4828" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="583" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="582" bodyend="593"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a891589b60d1c968b44986f3b7d56586b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="596" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="595" bodyend="611"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2a6e4104db7159c74673aacae14286ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="615" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="614" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a95c0f9757ba86c696c6c5bfa874c8a49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="633" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="632" bodyend="647"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8d5dbf37b71d16d686dd0fdbad82f8fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="650" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="649" bodyend="660"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae187563f8f86e256bc1394edcba1b2b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;A, const T &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="663" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="662" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a43db361f4a3128d89ad6a1db86686c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="676" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="675" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6e4d2d791a5cbcbcf90de5da2250b4c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const T &amp;a, const vector_k&lt; U &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="708" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="707" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac7a042d0e04e0c610b5798017c8196d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const double &amp;a, const vector_k&lt; double &gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="719" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="718" bodyend="724"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a06de45116e1111f3aca66cd18565e9ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator*</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="728" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="727" bodyend="733"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a05f53ae281350225540bf5b4f4d1259b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="736" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="735" bodyend="743"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad7f693a660597bd39cdca67ea4000a81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="747" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="746" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab34753e2fc26c9fab1fcbee6700c691b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator*</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="756" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="755" bodyend="761"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8afc5fb1383ec8d667f52ac3778df34c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="764" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="763" bodyend="771"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a18d99849477754b35d0a3187ceb60508" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="775" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="774" bodyend="781"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a77245a0566dc6436443ad15187512ef0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator-</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="785" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="784" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a390125160a7febd08d5c30629f4f698f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator-</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="794" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="793" bodyend="804"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5daa1c95786fd3745687914963e7229e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="807" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="806" bodyend="810"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5b10f703c72875b9f5e2ecc5c7696f9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::operator+</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="813" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="812" bodyend="823"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3852c35cfcc8caa784465a26d04c68a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="826" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="825" bodyend="836"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afce3d5f6cf95bb68e12f3f80ff146ed8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const U &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="839" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="838" bodyend="846"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acf439f423c568a970ddc8cde5940a0e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt;</type>
        <definition>vector_k&lt;double&gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const double &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="850" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="849" bodyend="856"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aef7e4ab9c187ffa93e45ec90e2d1d5d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::operator/</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="860" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="859" bodyend="866"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aafc0089bdf204385c1e627755c5070b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="869" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="868" bodyend="879"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa5daf45d6627feee18402005fcd83cfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::operator/</definition>
        <argsstring>(const U &amp;a, const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>operator/</name>
        <param>
          <type>const U &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="882" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="881" bodyend="889"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3fad354ed572051e939cc71209c112ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="895" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="894" bodyend="897"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aea600162295a122a2371d75f80f764c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="902" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="901" bodyend="904"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a62fe1fbcb9ed4e33c5b31dc2c77bdbc4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="910" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="909" bodyend="912"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab89a85c0315b92a6844a77e352b5d50b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="917" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="916" bodyend="919"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a917607e20e487553be913b7ccaa4736d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="925" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="924" bodyend="927"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1d9cd34e13780fffeb1de19287f5636d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="932" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="931" bodyend="934"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acd9678129c9effcca74b8fff47876b1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="940" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="939" bodyend="942"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af8995aedb4c636b77717bb09b37487be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::cos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>cos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the cos of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="947" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="946" bodyend="949"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a25563b8ed483cdd3bbbaf647beb76ba8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="955" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="954" bodyend="957"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a90f340395d16b059204d507250945f35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="962" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="961" bodyend="964"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abae345d963258d8db3de7630a21f7231" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="970" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="969" bodyend="972"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7310a65b84d58bffa91cd81d14fbf81a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::tan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>tan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the tangent of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="977" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="976" bodyend="979"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a877d94927f5459e9cdaa50c11e8ffd3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="985" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="984" bodyend="987"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1c98db9af87a464e8258138f98d9c029" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="992" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="991" bodyend="994"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae1811725cd4c1026bf8c9fa426694a6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1000" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="999" bodyend="1002"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6c07a37d969167a8eafc372d39e84a22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::acos</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>acos</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc cosine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1007" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1006" bodyend="1009"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71aba9c7d78e9bd5c0e7638e6fc526ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1015" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1014" bodyend="1017"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a159ccc6344c3e6dc8c3206890afd47d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1022" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1021" bodyend="1024"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4de772a2b10be65e2997cbb1f0f08853" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1030" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1029" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a25e9b69ef51cf53cc780fd5a99bcde1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::asin</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>asin</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the arc sine of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1037" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1036" bodyend="1039"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abb06bdc0fc2627f8f5390e0b1da588c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1045" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1044" bodyend="1047"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a22e3ee37c7d6c67e9951d9546082b8b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1052" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1051" bodyend="1054"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a71377e5dee3f47b001950fe0a1858722" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1060" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1059" bodyend="1062"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad67d2e26dfbe947035bcfdceda54f957" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::exp</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>exp</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the exponential of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1067" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1066" bodyend="1069"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3f3de1f36299e80f237c0e9669b9ee1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1075" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1074" bodyend="1077"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1b4681da0aec9ca45280970b47fd55d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1082" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1081" bodyend="1084"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a68ebe3cd64dbf2c0d09f33f5e7951317" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1090" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1089" bodyend="1092"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab18fc1ec8072b5fdfd260346c66b2301" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the natural logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1097" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1096" bodyend="1099"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9364d5d2e2a67359845a437550963985" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1105" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1104" bodyend="1107"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a506e11389a9ed0bfbd27f41a75df0719" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1112" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1111" bodyend="1114"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a06e575bbcbc7b7f0f97f70348699c172" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1120" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1119" bodyend="1122"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a89b9e24c6952c5216ed82d09e5683118" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::log10</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>log10</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the base 10 logarithm of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1127" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1126" bodyend="1129"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa4b7e86c9291f2ca9c5aacdb8e08f9ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1135" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1134" bodyend="1137"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a38b52fad75e8cf7db8b8d3ee7d1a7412" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1142" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1141" bodyend="1144"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5bcff39b329c05d8feded07f03c211e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1150" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1149" bodyend="1152"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9238ebdadb19806695736975e6dcdf4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the sqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1157" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1156" bodyend="1159"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9642e67bdae5228a94fca58334c8f812" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1165" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1164" bodyend="1167"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad5290a246f96df2efa1ffc0f80685478" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1172" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1171" bodyend="1174"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af8482452959bd0ad0cee0e5704ae7851" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;T&gt; &gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1180" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1179" bodyend="1182"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6bc00b1e07523727e7ae0e20ec1cf834" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::csqrt</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>csqrt</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Return a vector containing the csqrt of each element of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1187" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1186" bodyend="1189"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8ae33fb19a521ab1ec1f22e7c39ca076" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::eye</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>eye</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1192" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1191" bodyend="1200"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2824156817719ffe96a842dd0ef27ae5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;dim)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements along dimension dim. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements along dimension dim. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer value of the number of elements along the desired dimension. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1211" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1210" bodyend="1213"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae713df143a5e71da166f450e01a536e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref></type>
        <definition>matrix_size_type keycpp::size</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>size</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the size of matrix A. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the size of matrix A in a <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix for which you want to know the size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structkeycpp_1_1matrix__size__type" kindref="compound">matrix_size_type</ref> variable containing the number of rows and cols. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1223" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1222" bodyend="1228"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5699c522088657287bf0ac01173b716c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1238" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1237" bodyend="1241"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac00f5a8f1eba98722c1aac6b637a18c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::zeros</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>zeros</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all zeros. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all zeros. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing zeros for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1250" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1249" bodyend="1253"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a388f91a0ccf34978ef9403ccd0c680bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;M, const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a matrix of size M x N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a matrix of size M x N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">M</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An M x N matrix containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1263" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1262" bodyend="1273"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af40d69ddd09826dae133a479cff545b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::ones</definition>
        <argsstring>(const int &amp;N)</argsstring>
        <name>ones</name>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns a vector of length N containing all ones. </para>        </briefdescription>
        <detaileddescription>
<para>Returns a vector of length N containing all ones. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of length N containing ones for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1282" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1281" bodyend="1289"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bb3ea9a842383b82c889179f25be9ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const std::initializer_list&lt; T &gt; &amp;</type>
          <declname>lst</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1292" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1291" bodyend="1319"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae9ef181e938a4d835bb1cfb049479117" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1322" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1321" bodyend="1346"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a282ba9ffa45fecd5880534415b116cc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diag</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;d=0)</argsstring>
        <name>diag</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>d</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1349" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1348" bodyend="1394"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab56165975dd12a86b498134da71bde29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1397" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1396" bodyend="1413"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab202ed201891fd28216e6d21599d5895" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::repmat</definition>
        <argsstring>(const vector_k&lt; T &gt; v1, const int &amp;m, const int &amp;n)</argsstring>
        <name>repmat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1416" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1415" bodyend="1429"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac1ff99e34619478096c271b38df1f3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1437" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1436" bodyend="1455"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aab613a4c8cc04981045fdea358931780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>times</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs array multiplication on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1463" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1462" bodyend="1478"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aacd37d195541b2313b753b6e8839f916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Performs right array division on matrices A and B. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1486" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1485" bodyend="1504"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab299ba9f0640c2f95fe2393f2eef6ed2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>rdivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Performs right array division on vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1512" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1511" bodyend="1527"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac57d32902cba2c399475015235aeccec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>matrix&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Performs left array division on matrices B and A. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1535" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1534" bodyend="1553"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acee6d21e4a11f11422cc5f47d37c0e72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v2, const vector_k&lt; U &gt; &amp;v1)</argsstring>
        <name>ldivide</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Performs left array division on vectors v2 and v1. </para>        </briefdescription>
        <detaileddescription>
<para>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1561" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1560" bodyend="1576"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a87f2917e6a7c8e20d010aea0d8480668" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::sign</definition>
        <argsstring>(const T &amp;val)</argsstring>
        <name>sign</name>
        <param>
          <type>const T &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1579" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1578" bodyend="1581"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aaa2e17334911e8a447a5ef6c0cc54c3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::angle</definition>
        <argsstring>(const std::complex&lt; T &gt; &amp;x)</argsstring>
        <name>angle</name>
        <param>
          <type>const std::complex&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1584" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1583" bodyend="1586"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab4fe7e0308538622ae7d0b3a45182e0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; T &gt;&gt; &amp;v1)</argsstring>
        <name>angle</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1590" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1589" bodyend="1592"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a05899b620c8859f8832ad3132efce6b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::angle</definition>
        <argsstring>(const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</argsstring>
        <name>angle</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; T &gt;&gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1596" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1595" bodyend="1598"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a5a9aef54bbe0cd6e85d9a41842a57f05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::max</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1601" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1600" bodyend="1613"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61e3069eeec7219d10f997367701e488" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::max</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1616" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1615" bodyend="1630"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9d09b9019cc0bd9ad23b814e8a50fe25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::max</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>max</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1633" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1632" bodyend="1640"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3f6e11da7ff0d018261f1d66703672af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::min</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1643" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1642" bodyend="1655"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa56d65d68004f40352c8e33bffb0e0eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::min</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt; &gt; &amp;x)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1658" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1657" bodyend="1672"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a51bbe7de3141b751cc3ce36cdfb51000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::min</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>min</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1676" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1675" bodyend="1683"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7fd5ce0385e9cc7bed5b44ed8475e8aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>transpose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1688" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1687" bodyend="1698"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a24d241b78ac9d5764e08c3f03bdffd07" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::transpose</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>transpose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1703" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1702" bodyend="1710"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14503c0419f365433d88fa081d473210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1715" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1714" bodyend="1725"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9fc1e2c9bf6ee79ee28a6f25b7b55b23" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::ctranspose&lt; double &gt;</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A)</argsstring>
        <name>ctranspose&lt; double &gt;</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1730" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1729" bodyend="1732"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a60ac98094acdd80972dfd34d307489dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ctranspose</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>ctranspose</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the complex-conjugate transpose of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1737" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1736" bodyend="1744"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7d3157bfc97800f25010c32280dde212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::sum</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the sum of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1749" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1748" bodyend="1756"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a022f7e64d039d6d8289e36edd440fc86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::sum</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the sum of each column of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1761" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1760" bodyend="1768"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a049d8e50ce9c2c5e0b7a0ad95cc559b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::mat2vec</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>mat2vec</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Converts matrix A to a column vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1773" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1772" bodyend="1784"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6fb905e99ba06b2a005547e7f5d0f54f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::vec2mat</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>vec2mat</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Converts a column vector to a 1 x length(v1) matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1789" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1788" bodyend="1800"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab690e7da060fb0e4c42e53cf65d76c7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::linspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const size_t &amp;N)</argsstring>
        <name>linspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values equally spaced between x1 and x2, inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between x1 and x2. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N equally spaced values between x1 and x2, inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1813" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1812" bodyend="1831"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9e1c37fd71074c56e963be121e5de0f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::logspace</definition>
        <argsstring>(const T &amp;x1, const T &amp;x2, const int &amp;N)</argsstring>
        <name>logspace</name>
        <param>
          <type>const T &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>x2</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </para>        </briefdescription>
        <detaileddescription>
<para>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x1</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the minimum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">x2</parametername>
</parameternamelist>
<parameterdescription>
<para>The base 10 logarithm of the maximum value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values between 10^(x1) and 10^(x2). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1846" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1845" bodyend="1862"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a14be2eba762e42f7d04b9330d41c3f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::unwrap</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const T &amp;tol=pi)</argsstring>
        <name>unwrap</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>tol</declname>
          <defval>pi</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1865" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1864" bodyend="1882"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae2909bfb67450be6a6d53a62752a2106" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::mean</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>mean</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Computes the mean of vector v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1887" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1886" bodyend="1896"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a17458d17162284844399c9cc52be09ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="1899" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="1898" bodyend="2015"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af195484fa3f7653204623e2adc85d595" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2019" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2018" bodyend="2055"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6b00eb8d7f354173545ef98ad9da47cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const matrix&lt; T &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2058" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2057" bodyend="2075"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4c080370a07cc78709cc7992b208567e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; vector_k&lt; T &gt; &gt; &amp;y, const vector_k&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2079" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2078" bodyend="2101"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a50ca6544bccf005c1ac48b21facd349c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const matrix&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2104" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2103" bodyend="2121"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7a63750d1400cd9787c78e2f1b8812e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::interp1</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;x, const vector_k&lt; T &gt; &amp;y, const vector_k&lt; vector_k&lt; U &gt; &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</argsstring>
        <name>interp1</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &gt; &amp;</type>
          <declname>x_interp</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;linear&quot;</defval>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref></type>
          <declname>extrap</declname>
          <defval><ref refid="classkeycpp_1_1_extrap" kindref="compound">Extrap</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2124" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2123" bodyend="2141"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a257d22daacd12b862ef18d5405ebf375" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::trapz</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const vector_k&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2144" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2143" bodyend="2161"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a2fb57de964e3ede762e18ed0ad165ea1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::trapz</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;integrand)</argsstring>
        <name>trapz</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>integrand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2164" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2163" bodyend="2196"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a7124131346b73357a9e7d8e7c4ae9cc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const matrix&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u, const int &amp;index=2)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>const int &amp;</type>
          <declname>index</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2200" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2199" bodyend="2237"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aae3bec60fc5a78f2c532ea1d1ad1d336" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2240" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2239" bodyend="2277"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa2cab711aeb1a50fe342f7c01f9e0d74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::diffxy</definition>
        <argsstring>(const vector_k&lt; U &gt; &amp;eta, const vector_k&lt; T &gt; &amp;u)</argsstring>
        <name>diffxy</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>eta</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2280" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2279" bodyend="2299"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a354a712337d461286e6202d01200d615" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::fft</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;u, int N=-1)</argsstring>
        <name>fft</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>int</type>
          <declname>N</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2302" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2301" bodyend="2337"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa643664371f940c36634f2ce6b843ea2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_o_d_e__type" kindref="compound">ODE_type</ref>&lt; U, T &gt;</type>
        <definition>ODE_type&lt;U,T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, const std::initializer_list&lt; U &gt; &amp;x_span, vector_k&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type>const std::initializer_list&lt; U &gt; &amp;</type>
          <declname>x_span</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2367" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2366" bodyend="2397"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af93c8220d8d4d454f7fa57fe7db70aa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ode45</definition>
        <argsstring>(F odeClass, vector_k&lt; U &gt; x_ode, vector_k&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</argsstring>
        <name>ode45</name>
        <param>
          <type>F</type>
          <declname>odeClass</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt;</type>
          <declname>x_ode</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>ICs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>abs_tol</declname>
          <defval>1.0e-10</defval>
        </param>
        <param>
          <type>double</type>
          <declname>rel_tol</declname>
          <defval>1.0e-6</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2401" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2400" bodyend="2429"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afcd6ae07fc18f5374868fe314f00108c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, double val)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2432" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2431" bodyend="2434"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae67eb981ff22ef79a4ee90a9a40ae21f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::set</definition>
        <argsstring>(Figure &amp;h, std::string property, std::initializer_list&lt; size_t &gt; list)</argsstring>
        <name>set</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>property</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; size_t &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2437" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2436" bodyend="2439"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af9dec3da4533a1db21a6c6c4fe8e740a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::print</definition>
        <argsstring>(Figure &amp;h, std::string pterm, std::string pfilename)</argsstring>
        <name>print</name>
        <param>
          <type><ref refid="classkeycpp_1_1_figure" kindref="compound">Figure</ref> &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pterm</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>pfilename</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2442" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2441" bodyend="2444"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abe567d1c5cdf91722dfbe5da89e859e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___matrix" kindref="compound">Sort_Matrix</ref>&lt; T &gt;</type>
        <definition>Sort_Matrix&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const size_t &amp;dim=2, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>dim</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2454" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2453" bodyend="2555"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0ab724c8ffc30f7beac54280a4ee81eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1_sort___vector" kindref="compound">Sort_Vector</ref>&lt; T &gt;</type>
        <definition>Sort_Vector&lt;T&gt; keycpp::sort</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, std::string method=&quot;ascend&quot;)</argsstring>
        <name>sort</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;ascend&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2565" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2564" bodyend="2612"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af4a2245da139cf6cf2e03426476b3b88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void keycpp::disp</definition>
        <argsstring>(const T &amp;x, std::ostream &amp;outStream=std::cout)</argsstring>
        <name>disp</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>outStream</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
<para>Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2619" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2618" bodyend="2622"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aba69db64fe38ad271de1939d3f1a5520" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::input</definition>
        <argsstring>(const std::string &amp;prompt, std::string option)</argsstring>
        <name>input</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prompt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>option</declname>
        </param>
        <briefdescription>
<para>Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as &quot;s&quot; because C++ is a statically typed language. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2629" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2628" bodyend="2644"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bca7924aad17a920f2f5f0606e6d9a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::str2num</definition>
        <argsstring>(const std::string &amp;in)</argsstring>
        <name>str2num</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Converts a std::string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2650" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2649" bodyend="2652"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa605bad9095a6c529656926dc4fb35cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::length</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>length</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the number of elements in a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2658" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2657" bodyend="2660"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9c30ad952d4422425a171c12bdf33947" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::length</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>length</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the length of the largest dimension of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2666" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2665" bodyend="2670"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1adcbcd3d38aa0721f2556422eb06cad7d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t keycpp::numel</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>numel</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2674" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2673" bodyend="2676"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afbcf6804c0bcef12904db8880c451cea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; size_t &gt;</type>
        <definition>vector_k&lt;size_t&gt; keycpp::find</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const size_t &amp;k=-1, std::string start=&quot;&quot;)</argsstring>
        <name>find</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>k</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>start</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Finds and returns the indices of non-zero elements of v1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2682" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2681" bodyend="2741"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a97f0fc27cf8489f3f556fb1a0c975115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structkeycpp_1_1matrix__find__type" kindref="compound">matrix_find_type</ref>&lt; T &gt;</type>
        <definition>matrix_find_type&lt;T&gt; keycpp::find</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>find</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Finds and returns the row and column indices and values of non-zero elements of A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2756" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2755" bodyend="2780"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8e6462a878df6e022bd4f9aa6f953983" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const size_t &amp;m, const size_t &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2784" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2783" bodyend="2807"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a1e3e21956e9f34310b243bc45d68b238" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::reshape</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const size_t &amp;m, const size_t &amp;n)</argsstring>
        <name>reshape</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2811" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2810" bodyend="2813"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a04dabe064e99dd423157829c4b133261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::dot</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2819" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2818" bodyend="2834"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3b8c1401db056696103c4ad8f1aa48ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::dot</definition>
        <argsstring>(const vector_k&lt; double &gt; &amp;v1, const vector_k&lt; double &gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; double &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2840" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2839" bodyend="2851"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a3499b51e89dfda97b0dcf5dc2461926a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
        </templateparamlist>
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::dot</definition>
        <argsstring>(const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v1, const vector_k&lt; std::complex&lt; double &gt;&gt; &amp;v2)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product between vectors v1 and v2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2857" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2856" bodyend="2870"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0d4eac6fbefd72947d7fe26fada6c221" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::dot</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B, const size_t &amp;dim=-1)</argsstring>
        <name>dot</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; U &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const size_t &amp;</type>
          <declname>dim</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Computes the dot product between the first non-singleton dimension of A and B. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2876" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2875" bodyend="2903"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa590a6946f71f4c1b2e575bdb791f00f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;))&gt;</type>
        <definition>vector_k&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::cross</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, const vector_k&lt; U &gt; &amp;v2)</argsstring>
        <name>cross</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; U &gt; &amp;</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2910" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2909" bodyend="2925"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a78ea0301dbb858bbfdf2646a857a1ec6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2940" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2939" bodyend="2984"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb34bdd249af3ce92341cdda62f95f65" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2986" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4242" bodyend="4283"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a838fc93d66e1ab63d68d04781086d81a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; double, double &gt;</type>
        <definition>SVD_type&lt; double, double &gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2987" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4287" bodyend="4428"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad211ab5ae14ac9710265c662f70f20ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::norm</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;2&quot;)</argsstring>
        <name>norm</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;2&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2988" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4430" bodyend="4471"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad610adca37ac4c85df23b899d29d5dfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1_s_v_d__type" kindref="compound">SVD_type</ref>&lt; std::complex&lt; double &gt;, double &gt;</type>
        <definition>SVD_type&lt; std::complex&lt; double &gt;, double &gt; keycpp::svd</definition>
        <argsstring>(const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt;&gt; &amp;</type>
          <declname>A_in</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>method</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Computes the singular value decomposition of matrix A_in. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2989" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="4475" bodyend="4618"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aeb9efbc77cc58fa22403ea7ae5f4555c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int keycpp::rank</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>rank</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="2996" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="2995" bodyend="2999"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8f497e2da901adba0e1257be943595a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::null</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>null</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Computes the nullspace of matrix A. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3005" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3004" bodyend="3028"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a70b89ab3e8f66f86c47c3bde004d4487" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>any</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3034" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3033" bodyend="3040"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ade6d308fd22d34ad4860e5fcd22ccb39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>any</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3046" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3045" bodyend="3058"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af40fa7667b60f30a3b0912464d382d57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::any</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>any</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if any elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3064" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3063" bodyend="3073"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aab77d82d9cc7d1fcca87967048f09e0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>all</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3079" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3078" bodyend="3085"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a0ebd51ca90981278382a922c04ee7a75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>all</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3091" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3090" bodyend="3103"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9fe10fe179c6988a6f72e3715197457c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::all</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>all</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are nonzero. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3109" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3108" bodyend="3118"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a97c154d91210f0af72e5047649ab2fb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>finite</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3125" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3124" bodyend="3136"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a8879482fc9af1a809453e1719948263b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>finite</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3143" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3142" bodyend="3153"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a83702fd83d07f4e3822abdcba5819dcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::finite</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>finite</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are finite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3160" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3159" bodyend="3167"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a852be6145adcca15ceaeb5a138651e20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isinf</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isinf</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3174" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3173" bodyend="3176"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abf12e8a9c04720e074328bb1d34dce04" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isinf</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3183" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3182" bodyend="3193"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af104a680d8727dc0653925a834764ab4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isinf</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isinf</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3200" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3199" bodyend="3207"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad3b16064066dc041be364e6fbefa173a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isnan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns matrix containing boolean values that are true if corresponding elements of A are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3214" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3213" bodyend="3224"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad91dbdf14632d313a304d3ddbadf935f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isnan</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isnan</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns boolean value that is true if a is NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3231" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3230" bodyend="3233"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac54a98797b243f8f8b13b897cdeeba1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isnan</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isnan</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3240" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3239" bodyend="3247"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1acc2de8926c54a2048a0d8965e7d70995" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; bool &gt;</type>
        <definition>matrix&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isempty</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if matrix is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3253" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3252" bodyend="3255"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aef3406643c82187b13c5ab0b6da788b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; bool &gt;</type>
        <definition>vector_k&lt;bool&gt; keycpp::isempty</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isempty</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if vector is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3261" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3260" bodyend="3263"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a81a8c955cdbeb60181f6bf7d6553ac53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const T &amp;a)</argsstring>
        <name>isreal</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if a is real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3269" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3268" bodyend="3275"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a62d7118882bac24ab403ffb5f8ee7034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>isreal</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of A are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3281" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3280" bodyend="3293"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae5db41667f15caabbbdf37362e2f1990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool keycpp::isreal</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>isreal</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns true if all elements of v1 are real. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3299" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3298" bodyend="3308"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a005c1190f7087fb1d2545c38c080fd1a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::complex&lt; double &gt;</type>
        <definition>std::complex&lt;double&gt; keycpp::ceil</definition>
        <argsstring>(const std::complex&lt; double &gt; &amp;a)</argsstring>
        <name>ceil</name>
        <param>
          <type>const std::complex&lt; double &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Rounds the real and imaginary parts of std::complex&lt;double&gt; a towards positive infinity seperately. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3314" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3313" bodyend="3318"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abc86c63af2d6788c45ac99a1f3b14ad8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;v1)</argsstring>
        <name>ceil</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of v1 towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3324" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3323" bodyend="3331"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a4bba31744fef3693901a075fda07857c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::ceil</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>ceil</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Rounds the elements of A towards positive infinity. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3337" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3336" bodyend="3347"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ae7de6c3e5c495e91b1b1de7d716e7a5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;()*std::declval&lt; U &gt;())</type>
        <definition>decltype(std::declval&lt;T&gt;()*std::declval&lt;U&gt;()) keycpp::polyval</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;p, const U &amp;x)</argsstring>
        <name>polyval</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3351" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3350" bodyend="3360"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a21cb545ca871d88bcd449b61bd8bdbfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
        <definition>vector_k&lt;T&gt; keycpp::roots</definition>
        <argsstring>(const vector_k&lt; T &gt; &amp;p)</argsstring>
        <name>roots</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3367" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3366" bodyend="3376"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a6069a9eec0edfa1d401230013d98765e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref></type>
        <definition>tictoc_type keycpp::tic</definition>
        <argsstring>()</argsstring>
        <name>tic</name>
        <briefdescription>
<para>Start the timer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3388" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3387" bodyend="3392"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1afe03fbbb5126729fb4b9367097acb1d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::toc</definition>
        <argsstring>(tictoc_type &amp;Timer)</argsstring>
        <name>toc</name>
        <param>
          <type><ref refid="structkeycpp_1_1tictoc__type" kindref="compound">tictoc_type</ref> &amp;</type>
          <declname>Timer</declname>
        </param>
        <briefdescription>
<para>Stop the timer. The number of elapsed seconds is returned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3397" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3396" bodyend="3401"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::sprintf</definition>
        <argsstring>(const std::string &amp;fmt,...)</argsstring>
        <name>sprintf</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Overload of the C++ function <ref refid="namespacekeycpp_1a9d70a761d33bbc2bdec6b4e0eb43d517" kindref="member">sprintf()</ref>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3407" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3406" bodyend="3435"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a806f0afebdf1131be26a05d7a4a23044" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; size_t &gt;</type>
        <definition>vector_k&lt;size_t&gt; keycpp::clock</definition>
        <argsstring>()</argsstring>
        <name>clock</name>
        <briefdescription>
<para>Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3442" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3441" bodyend="3454"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac20bd2ef4fb18cbcdb0f462a89447bd7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt;</type>
        <definition>matrix&lt;T&gt; keycpp::pinv</definition>
        <argsstring>(const matrix&lt; T &gt; &amp;A)</argsstring>
        <name>pinv</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; T &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3461" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3460" bodyend="3482"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ad70d9156c4b6a75e5b7a4c799f900162" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string keycpp::removeWhiteSpace</definition>
        <argsstring>(std::string in)</argsstring>
        <name>removeWhiteSpace</name>
        <param>
          <type>std::string</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3485" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3484" bodyend="3503"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ac5c0a8bc58229a412ec2068979b6b84e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::importdata</definition>
        <argsstring>(std::string filename)</argsstring>
        <name>importdata</name>
        <param>
          <type>std::string</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Returns a matrix containing the data read from a text file. Values must be white space separated. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3507" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3506" bodyend="3553"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a61234b7bb0f3126b3db82634675c2951" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::stdev</definition>
        <argsstring>(vector_k&lt; T &gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3558" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3557" bodyend="3568"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1abdec07a4c4dd0fc5de230a753bf59066" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::stdev</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>stdev</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the standard deviation of inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3572" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3571" bodyend="3582"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a553528cf7a020895037ce3b1a828a04c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T keycpp::var</definition>
        <argsstring>(vector_k&lt; T &gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; T &gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3587" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3586" bodyend="3589"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af3249effde70a573fbd8881dc4629e04" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double keycpp::var</definition>
        <argsstring>(vector_k&lt; std::complex&lt; double &gt;&gt; v1)</argsstring>
        <name>var</name>
        <param>
          <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt;&gt;</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Returns the variance (square of standard deviation) for inputed vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3593" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3592" bodyend="3595"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1ab99a9561cf5654ae722a0879b41d9d73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const unsigned int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an N x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3607" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3606" bodyend="3618"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af6413232f2de6f8ac96efde6531c3055" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt;</type>
        <definition>matrix&lt;double&gt; keycpp::rand</definition>
        <argsstring>(const unsigned int &amp;M, const unsigned int &amp;N)</argsstring>
        <name>rand</name>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Returns an M x N matrix of random doubles between 0 and 1.0. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3623" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3622" bodyend="3634"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aa14e19e286b30265734236c0af2f9e78" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classkeycpp_1_1vector__k" kindref="compound">vector_k</ref>&lt; std::complex&lt; double &gt; &gt;</type>
        <definition>vector_k&lt;std::complex&lt;double&gt; &gt; keycpp::eig</definition>
        <argsstring>(const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</argsstring>
        <name>eig</name>
        <param>
          <type>const <ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; double &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vr_return</declname>
        </param>
        <param>
          <type><ref refid="classkeycpp_1_1matrix" kindref="compound">matrix</ref>&lt; std::complex&lt; double &gt; &gt; *</type>
          <declname>vl_return</declname>
        </param>
        <briefdescription>
<para>Double precision eigenvalue solver using LAPACK function call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/keycpp.h" line="3836" bodyfile="/media/Storage/Research/open_source/keycpp/include/keycpp.h" bodystart="3835" bodyend="3846"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a16b58f47ed977cafdc96227468f5f10a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, double *ALPHA, const double *A, const int *LDA, const double *B, const int *LDB, double *BETA, double *C, const int *LDC)</argsstring>
        <name>dgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1a29fb4e46ee1b9cce0fd8bc79a2490c72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemm_</definition>
        <argsstring>(const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *B, const int *LDB, std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *C, const int *LDC)</argsstring>
        <name>zgemm_</name>
        <param>
          <type>const char *</type>
          <declname>TRANSA</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>TRANSB</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>K</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDB</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>C</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDC</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-matrix multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1af0676a4a89dbb63f09fc627c05e12699" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::dgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const double *ALPHA, const double *A, const int *LDA, const double *X, const int *INCX, const double *BETA, double *Y, const int *INCY)</argsstring>
        <name>dgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="26"/>
      </memberdef>
      <memberdef kind="function" id="namespacekeycpp_1aea174778653491b5fd21dd2960c0f7cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void keycpp::zgemv_</definition>
        <argsstring>(const char *TRANS, const int *M, const int *N, const std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *X, const int *INCX, const std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *Y, const int *INCY)</argsstring>
        <name>zgemv_</name>
        <param>
          <type>const char *</type>
          <declname>TRANS</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>M</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>N</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>ALPHA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>LDA</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>X</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCX</declname>
        </param>
        <param>
          <type>const std::complex&lt; double &gt; *</type>
          <declname>BETA</declname>
        </param>
        <param>
          <type>std::complex&lt; double &gt; *</type>
          <declname>Y</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>INCY</declname>
        </param>
        <briefdescription>
<para>This provides a C interface to BLAS&apos;s complex double matrix-vector multiplication function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/media/Storage/Research/open_source/keycpp/include/Matrix.h" line="31"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/media/Storage/Research/open_source/keycpp/include/Figure.h" line="31"/>
  </compounddef>
</doxygen>
