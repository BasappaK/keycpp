<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>KeyCpp -- A MATLAB-like library for C++: keycpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-42949208-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KeyCpp -- A MATLAB-like library for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">keycpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library.  
</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_figure_exception.html">FigureException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_plots.html">Plots</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_figure.html">Figure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_key_cpp_exception.html">KeyCppException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1observe.html">observe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_o_d_e__type.html">ODE_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___matrix.html">Sort_Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___vector.html">Sort_Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1matrix__find__type.html">matrix_find_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_s_v_d__type.html">SVD_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1tictoc__type.html">tictoc_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for using the <a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e" title="Start the timer.">tic()</a> and toc(tictoc_type Timer) commands.  <a href="structkeycpp_1_1tictoc__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_matrix_exception.html">MatrixException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_spline_exception.html">SplineException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_spline.html">Spline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae84fcdbb1d5010c9e67a02851edd4460"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae84fcdbb1d5010c9e67a02851edd4460"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae84fcdbb1d5010c9e67a02851edd4460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:ae84fcdbb1d5010c9e67a02851edd4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab8937a6378526f7514c6124fb9991a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ab8937a6378526f7514c6124fb9991a"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a6ab8937a6378526f7514c6124fb9991a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a6ab8937a6378526f7514c6124fb9991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70fdb60acaa9b85c49cdd36ac68a6ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac70fdb60acaa9b85c49cdd36ac68a6ae"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac70fdb60acaa9b85c49cdd36ac68a6ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:ac70fdb60acaa9b85c49cdd36ac68a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d42394a53ae81f292d1e3de4383cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a026d42394a53ae81f292d1e3de4383cb"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a026d42394a53ae81f292d1e3de4383cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a026d42394a53ae81f292d1e3de4383cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b60f7fefe3931699f4d587a241c12e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90b60f7fefe3931699f4d587a241c12e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a90b60f7fefe3931699f4d587a241c12e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Figure::plot&lt; std::complex&lt; double &gt; &gt;</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;, 1 &gt; y, std::string format, std::string property1, double val1)</td></tr>
<tr class="separator:a90b60f7fefe3931699f4d587a241c12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83249f0263926905c67d2a177495eef8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83249f0263926905c67d2a177495eef8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a83249f0263926905c67d2a177495eef8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Figure::plot&lt; std::complex&lt; double &gt; &gt;</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;, 1 &gt; y, std::string format, std::string property1, double val1, std::string property2, double val2)</td></tr>
<tr class="separator:a83249f0263926905c67d2a177495eef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7368f9a35fb8dbc5c29420fb9677ea30"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7368f9a35fb8dbc5c29420fb9677ea30"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7368f9a35fb8dbc5c29420fb9677ea30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Figure::plot&lt; std::complex&lt; double &gt; &gt;</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;, 1 &gt; y, std::string arguments, double val, double lw, double ps, std::string legend_entry)</td></tr>
<tr class="separator:a7368f9a35fb8dbc5c29420fb9677ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55e50932cc54f92bdd7e38c6438f4f1f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a55e50932cc54f92bdd7e38c6438f4f1f">ddot_</a> (const int *N, const double *a, const int *inca, const double *b, const int *incb)</td></tr>
<tr class="memdesc:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double dot product function. <br/></td></tr>
<tr class="separator:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce99b4fe4a13b9c70ada81761eb0ca2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2ce99b4fe4a13b9c70ada81761eb0ca2">zdotu_</a> (std::complex&lt; double &gt; *result, const int *N, const std::complex&lt; double &gt; *a, const int *inca, const std::complex&lt; double &gt; *b, const int *incb)</td></tr>
<tr class="memdesc:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double dot product function. <br/></td></tr>
<tr class="separator:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99c5b242a21ba683701ccb6ab6534b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae99c5b242a21ba683701ccb6ab6534b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae99c5b242a21ba683701ccb6ab6534b1">daxpy_</a> (const int *N, const double *alpha, const double *x, const int *incx, double *y, const int *incy)</td></tr>
<tr class="memdesc:ae99c5b242a21ba683701ccb6ab6534b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double vector addition function. <br/></td></tr>
<tr class="separator:ae99c5b242a21ba683701ccb6ab6534b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6460fa334239dde761d8f737b9438fed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6460fa334239dde761d8f737b9438fed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6460fa334239dde761d8f737b9438fed">zaxpy_</a> (const int *N, const std::complex&lt; double &gt; *alpha, const std::complex&lt; double &gt; *x, const int *incx, std::complex&lt; double &gt; *y, const int *incy)</td></tr>
<tr class="memdesc:a6460fa334239dde761d8f737b9438fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double vector addition function. <br/></td></tr>
<tr class="separator:a6460fa334239dde761d8f737b9438fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d249dd978770119c1b91d88009fefbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d249dd978770119c1b91d88009fefbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7d249dd978770119c1b91d88009fefbd">dscal_</a> (const int *N, const double *alpha, double *x, const int *incx)</td></tr>
<tr class="memdesc:a7d249dd978770119c1b91d88009fefbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double scalar-vector multiplication function. <br/></td></tr>
<tr class="separator:a7d249dd978770119c1b91d88009fefbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd69d0d355e4805a832813199f1dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9dd69d0d355e4805a832813199f1dff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad9dd69d0d355e4805a832813199f1dff">zscal_</a> (const int *N, const std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *x, const int *incx)</td></tr>
<tr class="memdesc:ad9dd69d0d355e4805a832813199f1dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double scalar-vector multiplication function. <br/></td></tr>
<tr class="separator:ad9dd69d0d355e4805a832813199f1dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2501951ab3db3a91c3520ae89750b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2501951ab3db3a91c3520ae89750b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace2501951ab3db3a91c3520ae89750b1">zggev_</a> (const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:ace2501951ab3db3a91c3520ae89750b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex generalized eigenvalue solver. <br/></td></tr>
<tr class="separator:ace2501951ab3db3a91c3520ae89750b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc5253e80ac15a9bfdc5449ae4f972a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aebc5253e80ac15a9bfdc5449ae4f972a">dgeev_</a> (const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1cca2a162f40fc6c6218c35cadf9f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8c1cca2a162f40fc6c6218c35cadf9f2">zgeev_</a> (const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3be6524e195662cbb74a810305e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3be6524e195662cbb74a810305e721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aca3be6524e195662cbb74a810305e721">dgecon_</a> (const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</td></tr>
<tr class="memdesc:aca3be6524e195662cbb74a810305e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:aca3be6524e195662cbb74a810305e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e334ffaf1864d7191e9e0b64189783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e334ffaf1864d7191e9e0b64189783"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a75e334ffaf1864d7191e9e0b64189783">dgetrf_</a> (const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:a75e334ffaf1864d7191e9e0b64189783"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU decomposition function. <br/></td></tr>
<tr class="separator:a75e334ffaf1864d7191e9e0b64189783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c33788a2c083aa5738eda1fe62a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c33788a2c083aa5738eda1fe62a261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab9c33788a2c083aa5738eda1fe62a261">dgetrs_</a> (const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:ab9c33788a2c083aa5738eda1fe62a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU solver. <br/></td></tr>
<tr class="separator:ab9c33788a2c083aa5738eda1fe62a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507ef954be960fec70ca0f93258d730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4507ef954be960fec70ca0f93258d730"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4507ef954be960fec70ca0f93258d730">dlange_</a> (const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a4507ef954be960fec70ca0f93258d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision norm function. <br/></td></tr>
<tr class="separator:a4507ef954be960fec70ca0f93258d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e3cdc7e7929414370b6b50ea1218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444e3cdc7e7929414370b6b50ea1218c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a444e3cdc7e7929414370b6b50ea1218c">zgecon_</a> (const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</td></tr>
<tr class="memdesc:a444e3cdc7e7929414370b6b50ea1218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex-valued reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:a444e3cdc7e7929414370b6b50ea1218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18d58d53d8e19a37d74d24da27a64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18d58d53d8e19a37d74d24da27a64dd">zgetrf_</a> (const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:ab18d58d53d8e19a37d74d24da27a64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU decomposition function. <br/></td></tr>
<tr class="separator:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4322276dcdb7d864e85854b5b90f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe4322276dcdb7d864e85854b5b90f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abbe4322276dcdb7d864e85854b5b90f2">zgetrs_</a> (const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:abbe4322276dcdb7d864e85854b5b90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU solver. <br/></td></tr>
<tr class="separator:abbe4322276dcdb7d864e85854b5b90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477c910b07baef984fe8528c29b2774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1477c910b07baef984fe8528c29b2774"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1477c910b07baef984fe8528c29b2774">zlange_</a> (const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a1477c910b07baef984fe8528c29b2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex norm function. <br/></td></tr>
<tr class="separator:a1477c910b07baef984fe8528c29b2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12719f4b48de048f9642066666a920bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12719f4b48de048f9642066666a920bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a12719f4b48de048f9642066666a920bd">dgesv_</a> (const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</td></tr>
<tr class="memdesc:a12719f4b48de048f9642066666a920bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision linear system solver. <br/></td></tr>
<tr class="separator:a12719f4b48de048f9642066666a920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0d887ae48cc4222f7167232a7f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92d0d887ae48cc4222f7167232a7f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af92d0d887ae48cc4222f7167232a7f82">dgetri_</a> (const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:af92d0d887ae48cc4222f7167232a7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision matrix inverse function. <br/></td></tr>
<tr class="separator:af92d0d887ae48cc4222f7167232a7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190e125fe33133aafa586089ca6e174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4190e125fe33133aafa586089ca6e174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4190e125fe33133aafa586089ca6e174">zgetri_</a> (const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a4190e125fe33133aafa586089ca6e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex matrix inverse function. <br/></td></tr>
<tr class="separator:a4190e125fe33133aafa586089ca6e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7a71afbb6c5dc049cdd7afff6c0af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8fe7a71afbb6c5dc049cdd7afff6c0af">dgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision SVD function. <br/></td></tr>
<tr class="separator:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5e2f74110f53bd288c15ce1f183f9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afa5e2f74110f53bd288c15ce1f183f9b">zgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:afa5e2f74110f53bd288c15ce1f183f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex SVD function. <br/></td></tr>
<tr class="separator:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516e693670ca88debd44ca9a48b2f225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a516e693670ca88debd44ca9a48b2f225">eig</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; &amp;B, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vr_return, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:a516e693670ca88debd44ca9a48b2f225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized complex-valued eigenvalue solver using LAPACK function call.  <a href="#a516e693670ca88debd44ca9a48b2f225">More...</a><br/></td></tr>
<tr class="separator:a516e693670ca88debd44ca9a48b2f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24a17765339d2464a0cccb476782bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae24a17765339d2464a0cccb476782bff">eig</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; &amp;A, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vr_return, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:ae24a17765339d2464a0cccb476782bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex-valued eigenvalue solver using LAPACK function call.  <a href="#ae24a17765339d2464a0cccb476782bff">More...</a><br/></td></tr>
<tr class="separator:ae24a17765339d2464a0cccb476782bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42950497e518f5882a0689bb78fa667f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42950497e518f5882a0689bb78fa667f"></a>
<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eig</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</td></tr>
<tr class="separator:a42950497e518f5882a0689bb78fa667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3905cfc35dbd146f5dbf7bcb5729c2c2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rcond</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A)</td></tr>
<tr class="separator:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d9a9dd04453e5a417f7a9eb8ae4391b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rcond</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c91a82f4eadf681f9a690d6f309665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c91a82f4eadf681f9a690d6f309665"></a>
<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linsolve</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:aa0c91a82f4eadf681f9a690d6f309665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a89a2c6d30c991f4de63ca8f62c0e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a89a2c6d30c991f4de63ca8f62c0e1"></a>
<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linsolve</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;b_in)</td></tr>
<tr class="separator:a13a89a2c6d30c991f4de63ca8f62c0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96927cda2df7a6e8e2031941c43601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96927cda2df7a6e8e2031941c43601"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:adc96927cda2df7a6e8e2031941c43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9085342fc708fd5babae39321da3b89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9085342fc708fd5babae39321da3b89a"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a9085342fc708fd5babae39321da3b89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef5c1f5951e8182a7c4ec9612f3f7e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5ef5c1f5951e8182a7c4ec9612f3f7e1">rand</a> ()</td></tr>
<tr class="memdesc:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double between 0 and 1.0. <br/></td></tr>
<tr class="separator:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224964eb5e1a55c3f7d58f0e9b71d3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac224964eb5e1a55c3f7d58f0e9b71d3d"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rand</b> (const int &amp;N)</td></tr>
<tr class="separator:ac224964eb5e1a55c3f7d58f0e9b71d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c4b142a4101e9bb1df9f19efaf7d2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c4b142a4101e9bb1df9f19efaf7d2f"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rand</b> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="separator:ae5c4b142a4101e9bb1df9f19efaf7d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe17126168656af54ae76ab6c487407"><td class="memTemplParams" colspan="2">template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:acfe17126168656af54ae76ab6c487407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; size_t, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#acfe17126168656af54ae76ab6c487407">size</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:acfe17126168656af54ae76ab6c487407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of matrix A.  <a href="#acfe17126168656af54ae76ab6c487407">More...</a><br/></td></tr>
<tr class="separator:acfe17126168656af54ae76ab6c487407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac999bd518fb456aa9a4fbd2c04f007de"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A, T(*f)(const T &amp;))</td></tr>
<tr class="separator:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0865e2c884915d6ed0e3ef7bf73438b0"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</td></tr>
<tr class="separator:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6542964c7aaaccbee336567f64c03c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c6542964c7aaaccbee336567f64c03c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c6542964c7aaaccbee336567f64c03c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, T(*f)(const T &amp;))</td></tr>
<tr class="separator:a6c6542964c7aaaccbee336567f64c03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e135aeca12d58b9a084413bf571783"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46e135aeca12d58b9a084413bf571783"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a46e135aeca12d58b9a084413bf571783"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A, T(*f)(T))</td></tr>
<tr class="separator:a46e135aeca12d58b9a084413bf571783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb1c8a89210ed78554ecd0bed92a59"><td class="memTemplParams" colspan="2"><a class="anchor" id="a48fb1c8a89210ed78554ecd0bed92a59"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a48fb1c8a89210ed78554ecd0bed92a59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, T(*f)(T))</td></tr>
<tr class="separator:a48fb1c8a89210ed78554ecd0bed92a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7610588aa92335352b2796ebdd359d"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc7610588aa92335352b2796ebdd359d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afc7610588aa92335352b2796ebdd359d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(const std::complex&lt; T &gt; &amp;))</td></tr>
<tr class="separator:afc7610588aa92335352b2796ebdd359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2309a6456fab18ec68a436f269d32d8f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2309a6456fab18ec68a436f269d32d8f"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a2309a6456fab18ec68a436f269d32d8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</td></tr>
<tr class="separator:a2309a6456fab18ec68a436f269d32d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31115adc10089fbbc732d59362890af2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31115adc10089fbbc732d59362890af2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a31115adc10089fbbc732d59362890af2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eop</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(std::complex&lt; T &gt;))</td></tr>
<tr class="separator:a31115adc10089fbbc732d59362890af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc9a2ec3fa602bd1bad9cd9ea14038e"><td class="memTemplParams" colspan="2"><a class="anchor" id="abdc9a2ec3fa602bd1bad9cd9ea14038e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:abdc9a2ec3fa602bd1bad9cd9ea14038e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:abdc9a2ec3fa602bd1bad9cd9ea14038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f8946c126102b4467b70da16766b7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86f8946c126102b4467b70da16766b7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a86f8946c126102b4467b70da16766b7a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a86f8946c126102b4467b70da16766b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add55ad2a40111d6368744a3d4144f25a"><td class="memTemplParams" colspan="2"><a class="anchor" id="add55ad2a40111d6368744a3d4144f25a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:add55ad2a40111d6368744a3d4144f25a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#add55ad2a40111d6368744a3d4144f25a">prod</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:add55ad2a40111d6368744a3d4144f25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements of the vector x. <br/></td></tr>
<tr class="separator:add55ad2a40111d6368744a3d4144f25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5471fc9074471701bde9e68eb7971b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5471fc9074471701bde9e68eb7971b4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af5471fc9074471701bde9e68eb7971b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af5471fc9074471701bde9e68eb7971b4">prod</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:af5471fc9074471701bde9e68eb7971b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the product of all the elements in each column of the matrix A. <br/></td></tr>
<tr class="separator:af5471fc9074471701bde9e68eb7971b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52c37ec9c41349fd6bd862b8ebdd01bb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a52c37ec9c41349fd6bd862b8ebdd01bb">diff</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of differences between adjacent elements. <br/></td></tr>
<tr class="separator:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abb4e57814fd30b7b8d4845bbc16c73e9">diff</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of row differences between adjacent rows.  <a href="#abb4e57814fd30b7b8d4845bbc16c73e9">More...</a><br/></td></tr>
<tr class="separator:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436cfe206bb34dfe613ac495e792b155"><td class="memTemplParams" colspan="2"><a class="anchor" id="a436cfe206bb34dfe613ac495e792b155"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a436cfe206bb34dfe613ac495e792b155"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a436cfe206bb34dfe613ac495e792b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c63d9cf20e676efbcefd445698aca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a422c63d9cf20e676efbcefd445698aca"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a422c63d9cf20e676efbcefd445698aca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a422c63d9cf20e676efbcefd445698aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8f2e43eea5a213e424a068054c2f63"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb8f2e43eea5a213e424a068054c2f63"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb8f2e43eea5a213e424a068054c2f63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:afb8f2e43eea5a213e424a068054c2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8755f394a54bc0255a526c5e870e28"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b8755f394a54bc0255a526c5e870e28"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b8755f394a54bc0255a526c5e870e28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a1b8755f394a54bc0255a526c5e870e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cec179e95af014706ce54194efd1b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83cec179e95af014706ce54194efd1b9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a83cec179e95af014706ce54194efd1b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a83cec179e95af014706ce54194efd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f282087263edb46886e9390b9a833"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa48f282087263edb46886e9390b9a833"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa48f282087263edb46886e9390b9a833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:aa48f282087263edb46886e9390b9a833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaeb417b7e61b4bbe200edc1315c7d2e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d77410749bcf5a36793e3754e357b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f7d77410749bcf5a36793e3754e357b"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a6f7d77410749bcf5a36793e3754e357b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a6f7d77410749bcf5a36793e3754e357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e5296774667c3be4e792b5cd980da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952e5296774667c3be4e792b5cd980da"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>csqrt</b> (const double &amp;a)</td></tr>
<tr class="separator:a952e5296774667c3be4e792b5cd980da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa7912f1f198c5185cb6a36cfd2fb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8faa7912f1f198c5185cb6a36cfd2fb2"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>csqrt</b> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="separator:a8faa7912f1f198c5185cb6a36cfd2fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa865f0bd18bdefcf413b1c3dd286b998"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa865f0bd18bdefcf413b1c3dd286b998"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa865f0bd18bdefcf413b1c3dd286b998"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:aa865f0bd18bdefcf413b1c3dd286b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae416b3cc307c30afdb62f0ed37b70e05"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae416b3cc307c30afdb62f0ed37b70e05"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae416b3cc307c30afdb62f0ed37b70e05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v2)</td></tr>
<tr class="separator:ae416b3cc307c30afdb62f0ed37b70e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9508aa24d2496bd63dcdb72229c8b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade9508aa24d2496bd63dcdb72229c8b0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ade9508aa24d2496bd63dcdb72229c8b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v2)</td></tr>
<tr class="separator:ade9508aa24d2496bd63dcdb72229c8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fe0fe851bce021be6a0609da7df82d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68fe0fe851bce021be6a0609da7df82d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a68fe0fe851bce021be6a0609da7df82d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a68fe0fe851bce021be6a0609da7df82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28312b8c309091f03e373e1ae5f3d46"><td class="memTemplParams" colspan="2"><a class="anchor" id="af28312b8c309091f03e373e1ae5f3d46"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af28312b8c309091f03e373e1ae5f3d46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="separator:af28312b8c309091f03e373e1ae5f3d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff86e062c6497110b7505b0ef715c2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="adff86e062c6497110b7505b0ef715c2c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adff86e062c6497110b7505b0ef715c2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:adff86e062c6497110b7505b0ef715c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b4a64905c9d681c174b2dfcfba272c4"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b72efca1fbe800845b21a84d2d472"><td class="memTemplParams" colspan="2"><a class="anchor" id="a520b72efca1fbe800845b21a84d2d472"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a520b72efca1fbe800845b21a84d2d472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a520b72efca1fbe800845b21a84d2d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1222c1fe6037feb8eacf0d2bd5152751"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1222c1fe6037feb8eacf0d2bd5152751"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1222c1fe6037feb8eacf0d2bd5152751"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="separator:a1222c1fe6037feb8eacf0d2bd5152751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e48a344f24985b26ddcd3584c6b3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af05e48a344f24985b26ddcd3584c6b3f"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:af05e48a344f24985b26ddcd3584c6b3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:af05e48a344f24985b26ddcd3584c6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca75edcfed33360ce11172c32968d04"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaca75edcfed33360ce11172c32968d04"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:aaca75edcfed33360ce11172c32968d04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:aaca75edcfed33360ce11172c32968d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891589b60d1c968b44986f3b7d56586b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a891589b60d1c968b44986f3b7d56586b"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a891589b60d1c968b44986f3b7d56586b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:a891589b60d1c968b44986f3b7d56586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e4104db7159c74673aacae14286ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a6e4104db7159c74673aacae14286ef"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2a6e4104db7159c74673aacae14286ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v2)</td></tr>
<tr class="separator:a2a6e4104db7159c74673aacae14286ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c0f9757ba86c696c6c5bfa874c8a49"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95c0f9757ba86c696c6c5bfa874c8a49"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a95c0f9757ba86c696c6c5bfa874c8a49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v2)</td></tr>
<tr class="separator:a95c0f9757ba86c696c6c5bfa874c8a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb730e3fdb0eb44a13913518ce0afc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0fb730e3fdb0eb44a13913518ce0afc1"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a0fb730e3fdb0eb44a13913518ce0afc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T &amp;a, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, dim &gt; &amp;A)</td></tr>
<tr class="separator:a0fb730e3fdb0eb44a13913518ce0afc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b89b71e7516e560bb2be49b30aedd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a650b89b71e7516e560bb2be49b30aedd"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a650b89b71e7516e560bb2be49b30aedd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, dim &gt; &amp;A, const T &amp;a)</td></tr>
<tr class="separator:a650b89b71e7516e560bb2be49b30aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43db361f4a3128d89ad6a1db86686c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a43db361f4a3128d89ad6a1db86686c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7a43db361f4a3128d89ad6a1db86686c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a7a43db361f4a3128d89ad6a1db86686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4d2d791a5cbcbcf90de5da2250b4c8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e4d2d791a5cbcbcf90de5da2250b4c8"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6e4d2d791a5cbcbcf90de5da2250b4c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v1)</td></tr>
<tr class="separator:a6e4d2d791a5cbcbcf90de5da2250b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a042d0e04e0c610b5798017c8196d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7a042d0e04e0c610b5798017c8196d9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac7a042d0e04e0c610b5798017c8196d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const double &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1)</td></tr>
<tr class="separator:ac7a042d0e04e0c610b5798017c8196d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06de45116e1111f3aca66cd18565e9ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a06de45116e1111f3aca66cd18565e9ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a06de45116e1111f3aca66cd18565e9ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const std::complex&lt; double &gt; &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a06de45116e1111f3aca66cd18565e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f53ae281350225540bf5b4f4d1259b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05f53ae281350225540bf5b4f4d1259b"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a05f53ae281350225540bf5b4f4d1259b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a05f53ae281350225540bf5b4f4d1259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f693a660597bd39cdca67ea4000a81"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7f693a660597bd39cdca67ea4000a81"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad7f693a660597bd39cdca67ea4000a81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1, const double &amp;a)</td></tr>
<tr class="separator:ad7f693a660597bd39cdca67ea4000a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34753e2fc26c9fab1fcbee6700c691b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab34753e2fc26c9fab1fcbee6700c691b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab34753e2fc26c9fab1fcbee6700c691b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="separator:ab34753e2fc26c9fab1fcbee6700c691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afc5fb1383ec8d667f52ac3778df34c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8afc5fb1383ec8d667f52ac3778df34c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8afc5fb1383ec8d667f52ac3778df34c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a8afc5fb1383ec8d667f52ac3778df34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d99849477754b35d0a3187ceb60508"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18d99849477754b35d0a3187ceb60508"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a18d99849477754b35d0a3187ceb60508"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1)</td></tr>
<tr class="separator:a18d99849477754b35d0a3187ceb60508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77245a0566dc6436443ad15187512ef0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a77245a0566dc6436443ad15187512ef0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a77245a0566dc6436443ad15187512ef0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a77245a0566dc6436443ad15187512ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b0a62473683f833921698fbf6f5ed2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6b0a62473683f833921698fbf6f5ed2"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:ac6b0a62473683f833921698fbf6f5ed2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:ac6b0a62473683f833921698fbf6f5ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daa1c95786fd3745687914963e7229e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5daa1c95786fd3745687914963e7229e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5daa1c95786fd3745687914963e7229e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a5daa1c95786fd3745687914963e7229e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b10f703c72875b9f5e2ecc5c7696f9c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb5672c8d698032875766c42cd52547"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bb5672c8d698032875766c42cd52547"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a4bb5672c8d698032875766c42cd52547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:a4bb5672c8d698032875766c42cd52547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3d5f6cf95bb68e12f3f80ff146ed8"><td class="memTemplParams" colspan="2"><a class="anchor" id="afce3d5f6cf95bb68e12f3f80ff146ed8"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afce3d5f6cf95bb68e12f3f80ff146ed8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:afce3d5f6cf95bb68e12f3f80ff146ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf439f423c568a970ddc8cde5940a0e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="acf439f423c568a970ddc8cde5940a0e8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acf439f423c568a970ddc8cde5940a0e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1, const double &amp;a)</td></tr>
<tr class="separator:acf439f423c568a970ddc8cde5940a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7e4ab9c187ffa93e45ec90e2d1d5d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef7e4ab9c187ffa93e45ec90e2d1d5d4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef7e4ab9c187ffa93e45ec90e2d1d5d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1, const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="separator:aef7e4ab9c187ffa93e45ec90e2d1d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f5fa68e3f7fb39690f9e5c93bafc5c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88f5fa68e3f7fb39690f9e5c93bafc5c"></a>
template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a88f5fa68e3f7fb39690f9e5c93bafc5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:a88f5fa68e3f7fb39690f9e5c93bafc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5daf45d6627feee18402005fcd83cfd"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5daf45d6627feee18402005fcd83cfd"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa5daf45d6627feee18402005fcd83cfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const U &amp;a, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:aa5daf45d6627feee18402005fcd83cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad354ed572051e939cc71209c112ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fad354ed572051e939cc71209c112ab"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3fad354ed572051e939cc71209c112ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3fad354ed572051e939cc71209c112ab">sin</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a3fad354ed572051e939cc71209c112ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:a3fad354ed572051e939cc71209c112ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea600162295a122a2371d75f80f764c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea600162295a122a2371d75f80f764c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aea600162295a122a2371d75f80f764c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aea600162295a122a2371d75f80f764c5">sin</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:aea600162295a122a2371d75f80f764c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:aea600162295a122a2371d75f80f764c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18a3ebbda3c25527ae280f5c5725ff4e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a18a3ebbda3c25527ae280f5c5725ff4e">sin</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb234b850e34f9331031d39084fdbb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aedb234b850e34f9331031d39084fdbb0"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:aedb234b850e34f9331031d39084fdbb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aedb234b850e34f9331031d39084fdbb0">sin</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:aedb234b850e34f9331031d39084fdbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:aedb234b850e34f9331031d39084fdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917607e20e487553be913b7ccaa4736d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a917607e20e487553be913b7ccaa4736d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a917607e20e487553be913b7ccaa4736d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a917607e20e487553be913b7ccaa4736d">cos</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a917607e20e487553be913b7ccaa4736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:a917607e20e487553be913b7ccaa4736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9cd34e13780fffeb1de19287f5636d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d9cd34e13780fffeb1de19287f5636d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1d9cd34e13780fffeb1de19287f5636d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1d9cd34e13780fffeb1de19287f5636d">cos</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a1d9cd34e13780fffeb1de19287f5636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:a1d9cd34e13780fffeb1de19287f5636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a918a1ad9493c25e0afb4d2a37af24d25"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a918a1ad9493c25e0afb4d2a37af24d25">cos</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a918a1ad9493c25e0afb4d2a37af24d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of A. <br/></td></tr>
<tr class="separator:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ae0fcbeee4b61db0483546cf76021"><td class="memTemplParams" colspan="2"><a class="anchor" id="a882ae0fcbeee4b61db0483546cf76021"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a882ae0fcbeee4b61db0483546cf76021"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a882ae0fcbeee4b61db0483546cf76021">cos</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a882ae0fcbeee4b61db0483546cf76021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cos of each element of A. <br/></td></tr>
<tr class="separator:a882ae0fcbeee4b61db0483546cf76021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25563b8ed483cdd3bbbaf647beb76ba8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25563b8ed483cdd3bbbaf647beb76ba8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a25563b8ed483cdd3bbbaf647beb76ba8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a25563b8ed483cdd3bbbaf647beb76ba8">tan</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a25563b8ed483cdd3bbbaf647beb76ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of v1. <br/></td></tr>
<tr class="separator:a25563b8ed483cdd3bbbaf647beb76ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f340395d16b059204d507250945f35"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90f340395d16b059204d507250945f35"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a90f340395d16b059204d507250945f35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a90f340395d16b059204d507250945f35">tan</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a90f340395d16b059204d507250945f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of v1. <br/></td></tr>
<tr class="separator:a90f340395d16b059204d507250945f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae345d963258d8db3de7630a21f7231"><td class="memTemplParams" colspan="2"><a class="anchor" id="abae345d963258d8db3de7630a21f7231"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abae345d963258d8db3de7630a21f7231"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abae345d963258d8db3de7630a21f7231">tan</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:abae345d963258d8db3de7630a21f7231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:abae345d963258d8db3de7630a21f7231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7310a65b84d58bffa91cd81d14fbf81a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7310a65b84d58bffa91cd81d14fbf81a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7310a65b84d58bffa91cd81d14fbf81a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7310a65b84d58bffa91cd81d14fbf81a">tan</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7310a65b84d58bffa91cd81d14fbf81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:a7310a65b84d58bffa91cd81d14fbf81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877d94927f5459e9cdaa50c11e8ffd3c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a877d94927f5459e9cdaa50c11e8ffd3c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a877d94927f5459e9cdaa50c11e8ffd3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a877d94927f5459e9cdaa50c11e8ffd3c">acos</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a877d94927f5459e9cdaa50c11e8ffd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of v1. <br/></td></tr>
<tr class="separator:a877d94927f5459e9cdaa50c11e8ffd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98db9af87a464e8258138f98d9c029"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c98db9af87a464e8258138f98d9c029"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c98db9af87a464e8258138f98d9c029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1c98db9af87a464e8258138f98d9c029">acos</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a1c98db9af87a464e8258138f98d9c029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of v1. <br/></td></tr>
<tr class="separator:a1c98db9af87a464e8258138f98d9c029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1811725cd4c1026bf8c9fa426694a6d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1811725cd4c1026bf8c9fa426694a6d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae1811725cd4c1026bf8c9fa426694a6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae1811725cd4c1026bf8c9fa426694a6d">acos</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:ae1811725cd4c1026bf8c9fa426694a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of A. <br/></td></tr>
<tr class="separator:ae1811725cd4c1026bf8c9fa426694a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c07a37d969167a8eafc372d39e84a22"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c07a37d969167a8eafc372d39e84a22"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c07a37d969167a8eafc372d39e84a22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6c07a37d969167a8eafc372d39e84a22">acos</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6c07a37d969167a8eafc372d39e84a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of A. <br/></td></tr>
<tr class="separator:a6c07a37d969167a8eafc372d39e84a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aba9c7d78e9bd5c0e7638e6fc526ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71aba9c7d78e9bd5c0e7638e6fc526ad"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a71aba9c7d78e9bd5c0e7638e6fc526ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a71aba9c7d78e9bd5c0e7638e6fc526ad">asin</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a71aba9c7d78e9bd5c0e7638e6fc526ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of v1. <br/></td></tr>
<tr class="separator:a71aba9c7d78e9bd5c0e7638e6fc526ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159ccc6344c3e6dc8c3206890afd47d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a159ccc6344c3e6dc8c3206890afd47d4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a159ccc6344c3e6dc8c3206890afd47d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a159ccc6344c3e6dc8c3206890afd47d4">asin</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a159ccc6344c3e6dc8c3206890afd47d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of v1. <br/></td></tr>
<tr class="separator:a159ccc6344c3e6dc8c3206890afd47d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de772a2b10be65e2997cbb1f0f08853"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4de772a2b10be65e2997cbb1f0f08853"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4de772a2b10be65e2997cbb1f0f08853"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4de772a2b10be65e2997cbb1f0f08853">asin</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a4de772a2b10be65e2997cbb1f0f08853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of A. <br/></td></tr>
<tr class="separator:a4de772a2b10be65e2997cbb1f0f08853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e9b69ef51cf53cc780fd5a99bcde1b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25e9b69ef51cf53cc780fd5a99bcde1b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a25e9b69ef51cf53cc780fd5a99bcde1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a25e9b69ef51cf53cc780fd5a99bcde1b">asin</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a25e9b69ef51cf53cc780fd5a99bcde1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of A. <br/></td></tr>
<tr class="separator:a25e9b69ef51cf53cc780fd5a99bcde1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb06bdc0fc2627f8f5390e0b1da588c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb06bdc0fc2627f8f5390e0b1da588c3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb06bdc0fc2627f8f5390e0b1da588c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abb06bdc0fc2627f8f5390e0b1da588c3">exp</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:abb06bdc0fc2627f8f5390e0b1da588c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:abb06bdc0fc2627f8f5390e0b1da588c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e3ee37c7d6c67e9951d9546082b8b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22e3ee37c7d6c67e9951d9546082b8b8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22e3ee37c7d6c67e9951d9546082b8b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a22e3ee37c7d6c67e9951d9546082b8b8">exp</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a22e3ee37c7d6c67e9951d9546082b8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:a22e3ee37c7d6c67e9951d9546082b8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0302faeef7172f537f3473216c0cf33b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0302faeef7172f537f3473216c0cf33b"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a0302faeef7172f537f3473216c0cf33b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0302faeef7172f537f3473216c0cf33b">exp</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a0302faeef7172f537f3473216c0cf33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a0302faeef7172f537f3473216c0cf33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89087f62a5d5d136ad88493b920953ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89087f62a5d5d136ad88493b920953ac"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a89087f62a5d5d136ad88493b920953ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a89087f62a5d5d136ad88493b920953ac">exp</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a89087f62a5d5d136ad88493b920953ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a89087f62a5d5d136ad88493b920953ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3de1f36299e80f237c0e9669b9ee1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f3de1f36299e80f237c0e9669b9ee1d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f3de1f36299e80f237c0e9669b9ee1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3f3de1f36299e80f237c0e9669b9ee1d">log</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a3f3de1f36299e80f237c0e9669b9ee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a3f3de1f36299e80f237c0e9669b9ee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4681da0aec9ca45280970b47fd55d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b4681da0aec9ca45280970b47fd55d6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b4681da0aec9ca45280970b47fd55d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1b4681da0aec9ca45280970b47fd55d6">log</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a1b4681da0aec9ca45280970b47fd55d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a1b4681da0aec9ca45280970b47fd55d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ebe3cd64dbf2c0d09f33f5e7951317"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68ebe3cd64dbf2c0d09f33f5e7951317"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a68ebe3cd64dbf2c0d09f33f5e7951317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a68ebe3cd64dbf2c0d09f33f5e7951317">log</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a68ebe3cd64dbf2c0d09f33f5e7951317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:a68ebe3cd64dbf2c0d09f33f5e7951317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18fc1ec8072b5fdfd260346c66b2301"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab18fc1ec8072b5fdfd260346c66b2301"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab18fc1ec8072b5fdfd260346c66b2301"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18fc1ec8072b5fdfd260346c66b2301">log</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab18fc1ec8072b5fdfd260346c66b2301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:ab18fc1ec8072b5fdfd260346c66b2301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9364d5d2e2a67359845a437550963985"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9364d5d2e2a67359845a437550963985"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9364d5d2e2a67359845a437550963985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9364d5d2e2a67359845a437550963985">log10</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a9364d5d2e2a67359845a437550963985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a9364d5d2e2a67359845a437550963985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506e11389a9ed0bfbd27f41a75df0719"><td class="memTemplParams" colspan="2"><a class="anchor" id="a506e11389a9ed0bfbd27f41a75df0719"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a506e11389a9ed0bfbd27f41a75df0719"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a506e11389a9ed0bfbd27f41a75df0719">log10</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a506e11389a9ed0bfbd27f41a75df0719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a506e11389a9ed0bfbd27f41a75df0719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e575bbcbc7b7f0f97f70348699c172"><td class="memTemplParams" colspan="2"><a class="anchor" id="a06e575bbcbc7b7f0f97f70348699c172"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a06e575bbcbc7b7f0f97f70348699c172"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a06e575bbcbc7b7f0f97f70348699c172">log10</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a06e575bbcbc7b7f0f97f70348699c172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:a06e575bbcbc7b7f0f97f70348699c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b9e24c6952c5216ed82d09e5683118"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89b9e24c6952c5216ed82d09e5683118"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a89b9e24c6952c5216ed82d09e5683118"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a89b9e24c6952c5216ed82d09e5683118">log10</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a89b9e24c6952c5216ed82d09e5683118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:a89b9e24c6952c5216ed82d09e5683118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b7e86c9291f2ca9c5aacdb8e08f9ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4b7e86c9291f2ca9c5aacdb8e08f9ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4b7e86c9291f2ca9c5aacdb8e08f9ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa4b7e86c9291f2ca9c5aacdb8e08f9ff">sqrt</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:aa4b7e86c9291f2ca9c5aacdb8e08f9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of v1. <br/></td></tr>
<tr class="separator:aa4b7e86c9291f2ca9c5aacdb8e08f9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b52fad75e8cf7db8b8d3ee7d1a7412"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38b52fad75e8cf7db8b8d3ee7d1a7412"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a38b52fad75e8cf7db8b8d3ee7d1a7412"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a38b52fad75e8cf7db8b8d3ee7d1a7412">sqrt</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a38b52fad75e8cf7db8b8d3ee7d1a7412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of v1. <br/></td></tr>
<tr class="separator:a38b52fad75e8cf7db8b8d3ee7d1a7412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bcff39b329c05d8feded07f03c211e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae5bcff39b329c05d8feded07f03c211e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5bcff39b329c05d8feded07f03c211e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae5bcff39b329c05d8feded07f03c211e">sqrt</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:ae5bcff39b329c05d8feded07f03c211e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:ae5bcff39b329c05d8feded07f03c211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9238ebdadb19806695736975e6dcdf4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9238ebdadb19806695736975e6dcdf4c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9238ebdadb19806695736975e6dcdf4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9238ebdadb19806695736975e6dcdf4c">sqrt</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9238ebdadb19806695736975e6dcdf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:a9238ebdadb19806695736975e6dcdf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642e67bdae5228a94fca58334c8f812"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9642e67bdae5228a94fca58334c8f812"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9642e67bdae5228a94fca58334c8f812"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9642e67bdae5228a94fca58334c8f812">csqrt</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a9642e67bdae5228a94fca58334c8f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of v1. <br/></td></tr>
<tr class="separator:a9642e67bdae5228a94fca58334c8f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5290a246f96df2efa1ffc0f80685478"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5290a246f96df2efa1ffc0f80685478"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad5290a246f96df2efa1ffc0f80685478"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad5290a246f96df2efa1ffc0f80685478">csqrt</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ad5290a246f96df2efa1ffc0f80685478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of v1. <br/></td></tr>
<tr class="separator:ad5290a246f96df2efa1ffc0f80685478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8482452959bd0ad0cee0e5704ae7851"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8482452959bd0ad0cee0e5704ae7851"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af8482452959bd0ad0cee0e5704ae7851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af8482452959bd0ad0cee0e5704ae7851">csqrt</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:af8482452959bd0ad0cee0e5704ae7851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:af8482452959bd0ad0cee0e5704ae7851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc00b1e07523727e7ae0e20ec1cf834"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6bc00b1e07523727e7ae0e20ec1cf834"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6bc00b1e07523727e7ae0e20ec1cf834"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6bc00b1e07523727e7ae0e20ec1cf834">csqrt</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6bc00b1e07523727e7ae0e20ec1cf834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:a6bc00b1e07523727e7ae0e20ec1cf834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ae33fb19a521ab1ec1f22e7c39ca076"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eye</b> (const int &amp;N)</td></tr>
<tr class="separator:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824156817719ffe96a842dd0ef27ae5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2824156817719ffe96a842dd0ef27ae5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2824156817719ffe96a842dd0ef27ae5">size</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const int &amp;dim)</td></tr>
<tr class="memdesc:a2824156817719ffe96a842dd0ef27ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements along dimension dim.  <a href="#a2824156817719ffe96a842dd0ef27ae5">More...</a><br/></td></tr>
<tr class="separator:a2824156817719ffe96a842dd0ef27ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5699c522088657287bf0ac01173b716c">zeros</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a5699c522088657287bf0ac01173b716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all zeros.  <a href="#a5699c522088657287bf0ac01173b716c">More...</a><br/></td></tr>
<tr class="separator:a5699c522088657287bf0ac01173b716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f5a8f1eba98722c1aac6b637a18c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00f5a8f1eba98722c1aac6b637a18c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac00f5a8f1eba98722c1aac6b637a18c7">zeros</a> (const int &amp;N)</td></tr>
<tr class="memdesc:ac00f5a8f1eba98722c1aac6b637a18c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of length N containing all zeros.  <a href="#ac00f5a8f1eba98722c1aac6b637a18c7">More...</a><br/></td></tr>
<tr class="separator:ac00f5a8f1eba98722c1aac6b637a18c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a388f91a0ccf34978ef9403ccd0c680bf">ones</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a388f91a0ccf34978ef9403ccd0c680bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all ones.  <a href="#a388f91a0ccf34978ef9403ccd0c680bf">More...</a><br/></td></tr>
<tr class="separator:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40d69ddd09826dae133a479cff545b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af40d69ddd09826dae133a479cff545b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af40d69ddd09826dae133a479cff545b0">ones</a> (const int &amp;N)</td></tr>
<tr class="memdesc:af40d69ddd09826dae133a479cff545b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of length N containing all ones.  <a href="#af40d69ddd09826dae133a479cff545b0">More...</a><br/></td></tr>
<tr class="separator:af40d69ddd09826dae133a479cff545b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bb3ea9a842383b82c889179f25be9ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diag</b> (const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</td></tr>
<tr class="separator:a4bb3ea9a842383b82c889179f25be9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e8fc8dec82325b5f9245fae02954f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2e8fc8dec82325b5f9245fae02954f7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab2e8fc8dec82325b5f9245fae02954f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diag</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;v1, const int &amp;d=0)</td></tr>
<tr class="separator:ab2e8fc8dec82325b5f9245fae02954f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ba9ffa45fecd5880534415b116cc6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a282ba9ffa45fecd5880534415b116cc6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a282ba9ffa45fecd5880534415b116cc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diag</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const int &amp;d=0)</td></tr>
<tr class="separator:a282ba9ffa45fecd5880534415b116cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec07979cca186806a17250b2cb50aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dec07979cca186806a17250b2cb50aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7dec07979cca186806a17250b2cb50aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repmat</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;A, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:a7dec07979cca186806a17250b2cb50aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae354f0a4b26f5e5cc4158e193ab23ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae354f0a4b26f5e5cc4158e193ab23ea"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aae354f0a4b26f5e5cc4158e193ab23ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repmat</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; v1, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:aae354f0a4b26f5e5cc4158e193ab23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f555c6d461fb102bc95d6cbefa5528e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f555c6d461fb102bc95d6cbefa5528e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f555c6d461fb102bc95d6cbefa5528e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repmat</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; v1, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:a1f555c6d461fb102bc95d6cbefa5528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memTemplParams" colspan="2">template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a23a0fd48168263aad7f77f1769dc2f2a">times</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, dim &gt; &amp;B)</td></tr>
<tr class="memdesc:a23a0fd48168263aad7f77f1769dc2f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on matrices A and B.  <a href="#a23a0fd48168263aad7f77f1769dc2f2a">More...</a><br/></td></tr>
<tr class="separator:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab613a4c8cc04981045fdea358931780"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aab613a4c8cc04981045fdea358931780"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aab613a4c8cc04981045fdea358931780">times</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:aab613a4c8cc04981045fdea358931780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on vectors v1 and v2.  <a href="#aab613a4c8cc04981045fdea358931780">More...</a><br/></td></tr>
<tr class="separator:aab613a4c8cc04981045fdea358931780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aacd37d195541b2313b753b6e8839f916">rdivide</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:aacd37d195541b2313b753b6e8839f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on matrices A and B.  <a href="#aacd37d195541b2313b753b6e8839f916">More...</a><br/></td></tr>
<tr class="separator:aacd37d195541b2313b753b6e8839f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299ba9f0640c2f95fe2393f2eef6ed2"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab299ba9f0640c2f95fe2393f2eef6ed2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab299ba9f0640c2f95fe2393f2eef6ed2">rdivide</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab299ba9f0640c2f95fe2393f2eef6ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on vectors v1 and v2.  <a href="#ab299ba9f0640c2f95fe2393f2eef6ed2">More...</a><br/></td></tr>
<tr class="separator:ab299ba9f0640c2f95fe2393f2eef6ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac57d32902cba2c399475015235aeccec">ldivide</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;B, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A)</td></tr>
<tr class="memdesc:ac57d32902cba2c399475015235aeccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on matrices B and A.  <a href="#ac57d32902cba2c399475015235aeccec">More...</a><br/></td></tr>
<tr class="separator:ac57d32902cba2c399475015235aeccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee6d21e4a11f11422cc5f47d37c0e72"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:acee6d21e4a11f11422cc5f47d37c0e72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#acee6d21e4a11f11422cc5f47d37c0e72">ldivide</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v2, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v1)</td></tr>
<tr class="memdesc:acee6d21e4a11f11422cc5f47d37c0e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on vectors v2 and v1.  <a href="#acee6d21e4a11f11422cc5f47d37c0e72">More...</a><br/></td></tr>
<tr class="separator:acee6d21e4a11f11422cc5f47d37c0e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplParams" colspan="2"><a class="anchor" id="a87f2917e6a7c8e20d010aea0d8480668"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (const T &amp;val)</td></tr>
<tr class="separator:a87f2917e6a7c8e20d010aea0d8480668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa2e17334911e8a447a5ef6c0cc54c3f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle</b> (const std::complex&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fe7e0308538622ae7d0b3a45182e0b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4fe7e0308538622ae7d0b3a45182e0b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4fe7e0308538622ae7d0b3a45182e0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:ab4fe7e0308538622ae7d0b3a45182e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe373666d686c14e6ce6517d050373"><td class="memTemplParams" colspan="2"><a class="anchor" id="afbbe373666d686c14e6ce6517d050373"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:afbbe373666d686c14e6ce6517d050373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:afbbe373666d686c14e6ce6517d050373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9aef54bbe0cd6e85d9a41842a57f05"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a9aef54bbe0cd6e85d9a41842a57f05"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a9aef54bbe0cd6e85d9a41842a57f05"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5a9aef54bbe0cd6e85d9a41842a57f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3069eeec7219d10f997367701e488"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61e3069eeec7219d10f997367701e488"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt; &amp;x)</td></tr>
<tr class="separator:a61e3069eeec7219d10f997367701e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa0ebe44ce33d380a100f6db8232a2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfa0ebe44ce33d380a100f6db8232a2d"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:abfa0ebe44ce33d380a100f6db8232a2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim-1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:abfa0ebe44ce33d380a100f6db8232a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f79e58739abeaa5e3f7d5c422cc409"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5f79e58739abeaa5e3f7d5c422cc409"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5f79e58739abeaa5e3f7d5c422cc409"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;A)</td></tr>
<tr class="separator:aa5f79e58739abeaa5e3f7d5c422cc409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e11da7ff0d018261f1d66703672af"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f6e11da7ff0d018261f1d66703672af"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f6e11da7ff0d018261f1d66703672af"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a3f6e11da7ff0d018261f1d66703672af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d65d68004f40352c8e33bffb0e0eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa56d65d68004f40352c8e33bffb0e0eb"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt; &amp;x)</td></tr>
<tr class="separator:aa56d65d68004f40352c8e33bffb0e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bbe7de3141b751cc3ce36cdfb51000"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51bbe7de3141b751cc3ce36cdfb51000"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a51bbe7de3141b751cc3ce36cdfb51000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a51bbe7de3141b751cc3ce36cdfb51000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7fd5ce0385e9cc7bed5b44ed8475e8aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7fd5ce0385e9cc7bed5b44ed8475e8aa">transpose</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of matrix A. <br/></td></tr>
<tr class="separator:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c195d39e32dd81020c07cab17baa9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af86c195d39e32dd81020c07cab17baa9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af86c195d39e32dd81020c07cab17baa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;v1)</td></tr>
<tr class="separator:af86c195d39e32dd81020c07cab17baa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d241b78ac9d5764e08c3f03bdffd07"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24d241b78ac9d5764e08c3f03bdffd07"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24d241b78ac9d5764e08c3f03bdffd07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a24d241b78ac9d5764e08c3f03bdffd07">transpose</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a24d241b78ac9d5764e08c3f03bdffd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of vector v1. <br/></td></tr>
<tr class="separator:a24d241b78ac9d5764e08c3f03bdffd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14503c0419f365433d88fa081d473210"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a14503c0419f365433d88fa081d473210">ctranspose</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a14503c0419f365433d88fa081d473210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a14503c0419f365433d88fa081d473210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fc1e2c9bf6ee79ee28a6f25b7b55b23"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9fc1e2c9bf6ee79ee28a6f25b7b55b23">ctranspose&lt; double &gt;</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A)</td></tr>
<tr class="memdesc:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21722a52fe60726dbeaff3ee47787d2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21722a52fe60726dbeaff3ee47787d2a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a21722a52fe60726dbeaff3ee47787d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctranspose</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;v1)</td></tr>
<tr class="separator:a21722a52fe60726dbeaff3ee47787d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d20ed431cc6169d23b932a2ed57a35"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3d20ed431cc6169d23b932a2ed57a35"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab3d20ed431cc6169d23b932a2ed57a35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctranspose</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double, 1 &gt; &amp;v1)</td></tr>
<tr class="separator:ab3d20ed431cc6169d23b932a2ed57a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ac98094acdd80972dfd34d307489dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60ac98094acdd80972dfd34d307489dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a60ac98094acdd80972dfd34d307489dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a60ac98094acdd80972dfd34d307489dd">ctranspose</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a60ac98094acdd80972dfd34d307489dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of vector v1. <br/></td></tr>
<tr class="separator:a60ac98094acdd80972dfd34d307489dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3157bfc97800f25010c32280dde212"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d3157bfc97800f25010c32280dde212"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7d3157bfc97800f25010c32280dde212"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7d3157bfc97800f25010c32280dde212">sum</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a7d3157bfc97800f25010c32280dde212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of vector v1. <br/></td></tr>
<tr class="separator:a7d3157bfc97800f25010c32280dde212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b77d5a0c3eb7c97254067015e843c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f2b77d5a0c3eb7c97254067015e843c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f2b77d5a0c3eb7c97254067015e843c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;v1)</td></tr>
<tr class="separator:a1f2b77d5a0c3eb7c97254067015e843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f53f3dc1a16e2afc809f2510b35c00"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90f53f3dc1a16e2afc809f2510b35c00"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a90f53f3dc1a16e2afc809f2510b35c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a90f53f3dc1a16e2afc809f2510b35c00">sum</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a90f53f3dc1a16e2afc809f2510b35c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of each column of A. <br/></td></tr>
<tr class="separator:a90f53f3dc1a16e2afc809f2510b35c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049d8e50ce9c2c5e0b7a0ad95cc559b3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a049d8e50ce9c2c5e0b7a0ad95cc559b3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a049d8e50ce9c2c5e0b7a0ad95cc559b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a049d8e50ce9c2c5e0b7a0ad95cc559b3">mat2vec</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a049d8e50ce9c2c5e0b7a0ad95cc559b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts matrix A to a column vector. <br/></td></tr>
<tr class="separator:a049d8e50ce9c2c5e0b7a0ad95cc559b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb905e99ba06b2a005547e7f5d0f54f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fb905e99ba06b2a005547e7f5d0f54f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6fb905e99ba06b2a005547e7f5d0f54f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6fb905e99ba06b2a005547e7f5d0f54f">vec2mat</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a6fb905e99ba06b2a005547e7f5d0f54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a column vector to a 1 x length(v1) matrix. <br/></td></tr>
<tr class="separator:a6fb905e99ba06b2a005547e7f5d0f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3667b0575327bba14f481cd3524197fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3667b0575327bba14f481cd3524197fc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3667b0575327bba14f481cd3524197fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linspace</b> (const T &amp;x1, const T &amp;x2, const size_t &amp;N)</td></tr>
<tr class="separator:a3667b0575327bba14f481cd3524197fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1c37fd71074c56e963be121e5de0f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e1c37fd71074c56e963be121e5de0f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9e1c37fd71074c56e963be121e5de0f3">logspace</a> (const T &amp;x1, const T &amp;x2, const int &amp;N)</td></tr>
<tr class="memdesc:a9e1c37fd71074c56e963be121e5de0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively.  <a href="#a9e1c37fd71074c56e963be121e5de0f3">More...</a><br/></td></tr>
<tr class="separator:a9e1c37fd71074c56e963be121e5de0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae471c1edede10cab9baaa3f97b79f9fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae471c1edede10cab9baaa3f97b79f9fe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae471c1edede10cab9baaa3f97b79f9fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;v1, const T &amp;tol=pi)</td></tr>
<tr class="separator:ae471c1edede10cab9baaa3f97b79f9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2909bfb67450be6a6d53a62752a2106"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2909bfb67450be6a6d53a62752a2106"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2909bfb67450be6a6d53a62752a2106"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae2909bfb67450be6a6d53a62752a2106">mean</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ae2909bfb67450be6a6d53a62752a2106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean of vector v1. <br/></td></tr>
<tr class="separator:ae2909bfb67450be6a6d53a62752a2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cb099fd0d2482617127385c7de7a06"><td class="memTemplParams" colspan="2"><a class="anchor" id="a69cb099fd0d2482617127385c7de7a06"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a69cb099fd0d2482617127385c7de7a06"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a69cb099fd0d2482617127385c7de7a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378d96774bbc4017e0bd39ccfed82e5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a378d96774bbc4017e0bd39ccfed82e5d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a378d96774bbc4017e0bd39ccfed82e5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;y, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a378d96774bbc4017e0bd39ccfed82e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f799c4adf6335d1f4ca42057ffb603"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3f799c4adf6335d1f4ca42057ffb603"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac3f799c4adf6335d1f4ca42057ffb603"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;y, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:ac3f799c4adf6335d1f4ca42057ffb603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66239f5f5276de220dd1ad8a6a2d8529"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66239f5f5276de220dd1ad8a6a2d8529"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a66239f5f5276de220dd1ad8a6a2d8529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;x, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;y, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 2 &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a66239f5f5276de220dd1ad8a6a2d8529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1aa362c40ee8f0e4d31a4060b1d9e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f1aa362c40ee8f0e4d31a4060b1d9e0"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a6f1aa362c40ee8f0e4d31a4060b1d9e0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trapz</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;eta, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;integrand)</td></tr>
<tr class="separator:a6f1aa362c40ee8f0e4d31a4060b1d9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b0680673a79b8b3e4f184c5ff1fcd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a0b0680673a79b8b3e4f184c5ff1fcd"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a8a0b0680673a79b8b3e4f184c5ff1fcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trapz</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;eta, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;integrand)</td></tr>
<tr class="separator:a8a0b0680673a79b8b3e4f184c5ff1fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb28bb59e9e552598c05ebe9d1af397"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbb28bb59e9e552598c05ebe9d1af397"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adbb28bb59e9e552598c05ebe9d1af397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 2 &gt; &amp;eta, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;u, const int &amp;index=2)</td></tr>
<tr class="separator:adbb28bb59e9e552598c05ebe9d1af397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232fca3b7e079168f3588cbda16a4808"><td class="memTemplParams" colspan="2"><a class="anchor" id="a232fca3b7e079168f3588cbda16a4808"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a232fca3b7e079168f3588cbda16a4808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;eta, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 2 &gt; &amp;u)</td></tr>
<tr class="separator:a232fca3b7e079168f3588cbda16a4808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc6a57c0c427d6cf8800969003af7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a06cc6a57c0c427d6cf8800969003af7c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a06cc6a57c0c427d6cf8800969003af7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; &amp;eta, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;u)</td></tr>
<tr class="separator:a06cc6a57c0c427d6cf8800969003af7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61efdf6ebae0ecb767132e59c2e60e3d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61efdf6ebae0ecb767132e59c2e60e3d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a61efdf6ebae0ecb767132e59c2e60e3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fft</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; &amp;u, int N=-1)</td></tr>
<tr class="separator:a61efdf6ebae0ecb767132e59c2e60e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd649bfb166d80da042fc50275c5b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34bd649bfb166d80da042fc50275c5b9"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:a34bd649bfb166d80da042fc50275c5b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1_o_d_e__type.html">ODE_type</a>&lt; U, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ode45</b> (F odeClass, const std::initializer_list&lt; U &gt; &amp;x_span, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:a34bd649bfb166d80da042fc50275c5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2dd255c17cb6d38d4242386c8dca83"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace2dd255c17cb6d38d4242386c8dca83"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:ace2dd255c17cb6d38d4242386c8dca83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ode45</b> (F odeClass, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U, 1 &gt; x_ode, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T, 1 &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:ace2dd255c17cb6d38d4242386c8dca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6ae07fc18f5374868fe314f00108c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd6ae07fc18f5374868fe314f00108c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (<a class="el" href="classkeycpp_1_1_figure.html">Figure</a> &amp;h, std::string property, double val)</td></tr>
<tr class="separator:afcd6ae07fc18f5374868fe314f00108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67eb981ff22ef79a4ee90a9a40ae21f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67eb981ff22ef79a4ee90a9a40ae21f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (<a class="el" href="classkeycpp_1_1_figure.html">Figure</a> &amp;h, std::string property, std::initializer_list&lt; size_t &gt; list)</td></tr>
<tr class="separator:ae67eb981ff22ef79a4ee90a9a40ae21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dec3da4533a1db21a6c6c4fe8e740a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9dec3da4533a1db21a6c6c4fe8e740a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (<a class="el" href="classkeycpp_1_1_figure.html">Figure</a> &amp;h, std::string pterm, std::string pfilename)</td></tr>
<tr class="separator:af9dec3da4533a1db21a6c6c4fe8e740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe567d1c5cdf91722dfbe5da89e859e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe567d1c5cdf91722dfbe5da89e859e8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abe567d1c5cdf91722dfbe5da89e859e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1_sort___matrix.html">Sort_Matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const size_t &amp;dim=2, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:abe567d1c5cdf91722dfbe5da89e859e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab724c8ffc30f7beac54280a4ee81eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ab724c8ffc30f7beac54280a4ee81eb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ab724c8ffc30f7beac54280a4ee81eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1_sort___vector.html">Sort_Vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a0ab724c8ffc30f7beac54280a4ee81eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2245da139cf6cf2e03426476b3b88"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4a2245da139cf6cf2e03426476b3b88"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af4a2245da139cf6cf2e03426476b3b88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af4a2245da139cf6cf2e03426476b3b88">disp</a> (const T &amp;x, std::ostream &amp;outStream=std::cout)</td></tr>
<tr class="memdesc:af4a2245da139cf6cf2e03426476b3b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. <br/></td></tr>
<tr class="separator:af4a2245da139cf6cf2e03426476b3b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69db64fe38ad271de1939d3f1a5520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba69db64fe38ad271de1939d3f1a5520"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aba69db64fe38ad271de1939d3f1a5520">input</a> (const std::string &amp;prompt, std::string option)</td></tr>
<tr class="memdesc:aba69db64fe38ad271de1939d3f1a5520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as "s" because C++ is a statically typed language. <br/></td></tr>
<tr class="separator:aba69db64fe38ad271de1939d3f1a5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bca7924aad17a920f2f5f0606e6d9a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4bca7924aad17a920f2f5f0606e6d9a9">str2num</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) <br/></td></tr>
<tr class="separator:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa605bad9095a6c529656926dc4fb35cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa605bad9095a6c529656926dc4fb35cf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa605bad9095a6c529656926dc4fb35cf"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa605bad9095a6c529656926dc4fb35cf">length</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:aa605bad9095a6c529656926dc4fb35cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a vector. <br/></td></tr>
<tr class="separator:aa605bad9095a6c529656926dc4fb35cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c30ad952d4422425a171c12bdf33947"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c30ad952d4422425a171c12bdf33947"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c30ad952d4422425a171c12bdf33947"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9c30ad952d4422425a171c12bdf33947">length</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9c30ad952d4422425a171c12bdf33947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the largest dimension of A. <br/></td></tr>
<tr class="separator:a9c30ad952d4422425a171c12bdf33947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adcbcd3d38aa0721f2556422eb06cad7d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numel</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcf6804c0bcef12904db8880c451cea"><td class="memTemplParams" colspan="2"><a class="anchor" id="afbcf6804c0bcef12904db8880c451cea"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afbcf6804c0bcef12904db8880c451cea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afbcf6804c0bcef12904db8880c451cea">find</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const size_t &amp;k=-1, std::string start=&quot;&quot;)</td></tr>
<tr class="memdesc:afbcf6804c0bcef12904db8880c451cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the indices of non-zero elements of v1. <br/></td></tr>
<tr class="separator:afbcf6804c0bcef12904db8880c451cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97f0fc27cf8489f3f556fb1a0c975115"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1matrix__find__type.html">matrix_find_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a97f0fc27cf8489f3f556fb1a0c975115">find</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a97f0fc27cf8489f3f556fb1a0c975115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the row and column indices and values of non-zero elements of A. <br/></td></tr>
<tr class="separator:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6462a878df6e022bd4f9aa6f953983"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e6462a878df6e022bd4f9aa6f953983"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e6462a878df6e022bd4f9aa6f953983"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const size_t &amp;m, const size_t &amp;n)</td></tr>
<tr class="separator:a8e6462a878df6e022bd4f9aa6f953983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3e21956e9f34310b243bc45d68b238"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e3e21956e9f34310b243bc45d68b238"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e3e21956e9f34310b243bc45d68b238"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const size_t &amp;m, const size_t &amp;n)</td></tr>
<tr class="separator:a1e3e21956e9f34310b243bc45d68b238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dabe064e99dd423157829c4b133261"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04dabe064e99dd423157829c4b133261"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a04dabe064e99dd423157829c4b133261"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; T &gt;<br class="typebreak"/>
()*std::declval&lt; U &gt;())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a04dabe064e99dd423157829c4b133261">dot</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a04dabe064e99dd423157829c4b133261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between vectors v1 and v2. <br/></td></tr>
<tr class="separator:a04dabe064e99dd423157829c4b133261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8c1401db056696103c4ad8f1aa48ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b8c1401db056696103c4ad8f1aa48ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3b8c1401db056696103c4ad8f1aa48ce"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3b8c1401db056696103c4ad8f1aa48ce">dot</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; double &gt; &amp;v2)</td></tr>
<tr class="memdesc:a3b8c1401db056696103c4ad8f1aa48ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between vectors v1 and v2. <br/></td></tr>
<tr class="separator:a3b8c1401db056696103c4ad8f1aa48ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499b51e89dfda97b0dcf5dc2461926a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3499b51e89dfda97b0dcf5dc2461926a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3499b51e89dfda97b0dcf5dc2461926a"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3499b51e89dfda97b0dcf5dc2461926a">dot</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; &amp;v2)</td></tr>
<tr class="memdesc:a3499b51e89dfda97b0dcf5dc2461926a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between vectors v1 and v2. <br/></td></tr>
<tr class="separator:a3499b51e89dfda97b0dcf5dc2461926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4eac6fbefd72947d7fe26fada6c221"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d4eac6fbefd72947d7fe26fada6c221"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0d4eac6fbefd72947d7fe26fada6c221"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0d4eac6fbefd72947d7fe26fada6c221">dot</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;B, const size_t &amp;dim=-1)</td></tr>
<tr class="memdesc:a0d4eac6fbefd72947d7fe26fada6c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between the first non-singleton dimension of A and B. <br/></td></tr>
<tr class="separator:a0d4eac6fbefd72947d7fe26fada6c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa590a6946f71f4c1b2e575bdb791f00f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa590a6946f71f4c1b2e575bdb791f00f"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa590a6946f71f4c1b2e575bdb791f00f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa590a6946f71f4c1b2e575bdb791f00f">cross</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:aa590a6946f71f4c1b2e575bdb791f00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. <br/></td></tr>
<tr class="separator:aa590a6946f71f4c1b2e575bdb791f00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea0301dbb858bbfdf2646a857a1ec6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78ea0301dbb858bbfdf2646a857a1ec6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a78ea0301dbb858bbfdf2646a857a1ec6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a78ea0301dbb858bbfdf2646a857a1ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb34bdd249af3ce92341cdda62f95f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb34bdd249af3ce92341cdda62f95f65"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:aeb34bdd249af3ce92341cdda62f95f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838fc93d66e1ab63d68d04781086d81a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a838fc93d66e1ab63d68d04781086d81a"></a>
<a class="el" href="classkeycpp_1_1_s_v_d__type.html">SVD_type</a>&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a838fc93d66e1ab63d68d04781086d81a">svd</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in, std::string method)</td></tr>
<tr class="memdesc:a838fc93d66e1ab63d68d04781086d81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a838fc93d66e1ab63d68d04781086d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad211ab5ae14ac9710265c662f70f20ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad211ab5ae14ac9710265c662f70f20ff"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:ad211ab5ae14ac9710265c662f70f20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610adca37ac4c85df23b899d29d5dfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad610adca37ac4c85df23b899d29d5dfc"></a>
<a class="el" href="classkeycpp_1_1_s_v_d__type.html">SVD_type</a>&lt; std::complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad610adca37ac4c85df23b899d29d5dfc">svd</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method)</td></tr>
<tr class="memdesc:ad610adca37ac4c85df23b899d29d5dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:ad610adca37ac4c85df23b899d29d5dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb9efbc77cc58fa22403ea7ae5f4555c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aeb9efbc77cc58fa22403ea7ae5f4555c">rank</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. <br/></td></tr>
<tr class="separator:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f497e2da901adba0e1257be943595a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8f497e2da901adba0e1257be943595a1">null</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8f497e2da901adba0e1257be943595a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of matrix A. <br/></td></tr>
<tr class="separator:a8f497e2da901adba0e1257be943595a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70b89ab3e8f66f86c47c3bde004d4487"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a70b89ab3e8f66f86c47c3bde004d4487">any</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a70b89ab3e8f66f86c47c3bde004d4487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade6d308fd22d34ad4860e5fcd22ccb39"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ade6d308fd22d34ad4860e5fcd22ccb39">any</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any elements of A are nonzero. <br/></td></tr>
<tr class="separator:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fa7667b60f30a3b0912464d382d57"><td class="memTemplParams" colspan="2"><a class="anchor" id="af40fa7667b60f30a3b0912464d382d57"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af40fa7667b60f30a3b0912464d382d57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af40fa7667b60f30a3b0912464d382d57">any</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:af40fa7667b60f30a3b0912464d382d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any elements of v1 are nonzero. <br/></td></tr>
<tr class="separator:af40fa7667b60f30a3b0912464d382d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab77d82d9cc7d1fcca87967048f09e0e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aab77d82d9cc7d1fcca87967048f09e0e">all</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aab77d82d9cc7d1fcca87967048f09e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd51ca90981278382a922c04ee7a75"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ebd51ca90981278382a922c04ee7a75"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ebd51ca90981278382a922c04ee7a75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0ebd51ca90981278382a922c04ee7a75">all</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a0ebd51ca90981278382a922c04ee7a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are nonzero. <br/></td></tr>
<tr class="separator:a0ebd51ca90981278382a922c04ee7a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe10fe179c6988a6f72e3715197457c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fe10fe179c6988a6f72e3715197457c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9fe10fe179c6988a6f72e3715197457c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9fe10fe179c6988a6f72e3715197457c">all</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a9fe10fe179c6988a6f72e3715197457c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of v1 are nonzero. <br/></td></tr>
<tr class="separator:a9fe10fe179c6988a6f72e3715197457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c154d91210f0af72e5047649ab2fb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97c154d91210f0af72e5047649ab2fb5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a97c154d91210f0af72e5047649ab2fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a97c154d91210f0af72e5047649ab2fb5">finite</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a97c154d91210f0af72e5047649ab2fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is finite. <br/></td></tr>
<tr class="separator:a97c154d91210f0af72e5047649ab2fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8879482fc9af1a809453e1719948263b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8879482fc9af1a809453e1719948263b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8879482fc9af1a809453e1719948263b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8879482fc9af1a809453e1719948263b">finite</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8879482fc9af1a809453e1719948263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are finite. <br/></td></tr>
<tr class="separator:a8879482fc9af1a809453e1719948263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83702fd83d07f4e3822abdcba5819dcb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83702fd83d07f4e3822abdcba5819dcb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a83702fd83d07f4e3822abdcba5819dcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a83702fd83d07f4e3822abdcba5819dcb">finite</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a83702fd83d07f4e3822abdcba5819dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are finite. <br/></td></tr>
<tr class="separator:a83702fd83d07f4e3822abdcba5819dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852be6145adcca15ceaeb5a138651e20"><td class="memTemplParams" colspan="2"><a class="anchor" id="a852be6145adcca15ceaeb5a138651e20"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a852be6145adcca15ceaeb5a138651e20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a852be6145adcca15ceaeb5a138651e20">isinf</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a852be6145adcca15ceaeb5a138651e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is infinite. <br/></td></tr>
<tr class="separator:a852be6145adcca15ceaeb5a138651e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12e8a9c04720e074328bb1d34dce04"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf12e8a9c04720e074328bb1d34dce04"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abf12e8a9c04720e074328bb1d34dce04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abf12e8a9c04720e074328bb1d34dce04">isinf</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abf12e8a9c04720e074328bb1d34dce04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are infinite. <br/></td></tr>
<tr class="separator:abf12e8a9c04720e074328bb1d34dce04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af104a680d8727dc0653925a834764ab4"><td class="memTemplParams" colspan="2"><a class="anchor" id="af104a680d8727dc0653925a834764ab4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af104a680d8727dc0653925a834764ab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af104a680d8727dc0653925a834764ab4">isinf</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:af104a680d8727dc0653925a834764ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. <br/></td></tr>
<tr class="separator:af104a680d8727dc0653925a834764ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b16064066dc041be364e6fbefa173a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3b16064066dc041be364e6fbefa173a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3b16064066dc041be364e6fbefa173a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad3b16064066dc041be364e6fbefa173a">isnan</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ad3b16064066dc041be364e6fbefa173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are NaN. <br/></td></tr>
<tr class="separator:ad3b16064066dc041be364e6fbefa173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91dbdf14632d313a304d3ddbadf935f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad91dbdf14632d313a304d3ddbadf935f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad91dbdf14632d313a304d3ddbadf935f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad91dbdf14632d313a304d3ddbadf935f">isnan</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ad91dbdf14632d313a304d3ddbadf935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is NaN. <br/></td></tr>
<tr class="separator:ad91dbdf14632d313a304d3ddbadf935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54a98797b243f8f8b13b897cdeeba1c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac54a98797b243f8f8b13b897cdeeba1c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac54a98797b243f8f8b13b897cdeeba1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac54a98797b243f8f8b13b897cdeeba1c">isnan</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ac54a98797b243f8f8b13b897cdeeba1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. <br/></td></tr>
<tr class="separator:ac54a98797b243f8f8b13b897cdeeba1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc2de8926c54a2048a0d8965e7d70995"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#acc2de8926c54a2048a0d8965e7d70995">isempty</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:acc2de8926c54a2048a0d8965e7d70995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix is empty. <br/></td></tr>
<tr class="separator:acc2de8926c54a2048a0d8965e7d70995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3406643c82187b13c5ab0b6da788b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef3406643c82187b13c5ab0b6da788b6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aef3406643c82187b13c5ab0b6da788b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aef3406643c82187b13c5ab0b6da788b6">isempty</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:aef3406643c82187b13c5ab0b6da788b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if vector is empty. <br/></td></tr>
<tr class="separator:aef3406643c82187b13c5ab0b6da788b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81a8c955cdbeb60181f6bf7d6553ac53"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a81a8c955cdbeb60181f6bf7d6553ac53">isreal</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is real. <br/></td></tr>
<tr class="separator:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7118882bac24ab403ffb5f8ee7034"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62d7118882bac24ab403ffb5f8ee7034"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a62d7118882bac24ab403ffb5f8ee7034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a62d7118882bac24ab403ffb5f8ee7034">isreal</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a62d7118882bac24ab403ffb5f8ee7034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are real. <br/></td></tr>
<tr class="separator:a62d7118882bac24ab403ffb5f8ee7034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5db41667f15caabbbdf37362e2f1990"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae5db41667f15caabbbdf37362e2f1990"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5db41667f15caabbbdf37362e2f1990"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae5db41667f15caabbbdf37362e2f1990">isreal</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ae5db41667f15caabbbdf37362e2f1990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of v1 are real. <br/></td></tr>
<tr class="separator:ae5db41667f15caabbbdf37362e2f1990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005c1190f7087fb1d2545c38c080fd1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005c1190f7087fb1d2545c38c080fd1a"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a005c1190f7087fb1d2545c38c080fd1a">ceil</a> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="memdesc:a005c1190f7087fb1d2545c38c080fd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the real and imaginary parts of std::complex&lt;double&gt; a towards positive infinity seperately. <br/></td></tr>
<tr class="separator:a005c1190f7087fb1d2545c38c080fd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc86c63af2d6788c45ac99a1f3b14ad8"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc86c63af2d6788c45ac99a1f3b14ad8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abc86c63af2d6788c45ac99a1f3b14ad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abc86c63af2d6788c45ac99a1f3b14ad8">ceil</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:abc86c63af2d6788c45ac99a1f3b14ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of v1 towards positive infinity. <br/></td></tr>
<tr class="separator:abc86c63af2d6788c45ac99a1f3b14ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba31744fef3693901a075fda07857c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bba31744fef3693901a075fda07857c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bba31744fef3693901a075fda07857c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4bba31744fef3693901a075fda07857c">ceil</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a4bba31744fef3693901a075fda07857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of A towards positive infinity. <br/></td></tr>
<tr class="separator:a4bba31744fef3693901a075fda07857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de6c3e5c495e91b1b1de7d716e7a5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7de6c3e5c495e91b1b1de7d716e7a5d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae7de6c3e5c495e91b1b1de7d716e7a5d"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; T &gt;<br class="typebreak"/>
()*std::declval&lt; U &gt;())&#160;</td><td class="memTemplItemRight" valign="bottom"><b>polyval</b> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;p, const U &amp;x)</td></tr>
<tr class="separator:ae7de6c3e5c495e91b1b1de7d716e7a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cb545ca871d88bcd449b61bd8bdbfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21cb545ca871d88bcd449b61bd8bdbfb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a21cb545ca871d88bcd449b61bd8bdbfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a21cb545ca871d88bcd449b61bd8bdbfb">roots</a> (const <a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a21cb545ca871d88bcd449b61bd8bdbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. <br/></td></tr>
<tr class="separator:a21cb545ca871d88bcd449b61bd8bdbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6069a9eec0edfa1d401230013d98765e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6069a9eec0edfa1d401230013d98765e"></a>
<a class="el" href="structkeycpp_1_1tictoc__type.html">tictoc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e">tic</a> ()</td></tr>
<tr class="memdesc:a6069a9eec0edfa1d401230013d98765e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the timer. <br/></td></tr>
<tr class="separator:a6069a9eec0edfa1d401230013d98765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe03fbbb5126729fb4b9367097acb1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe03fbbb5126729fb4b9367097acb1d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afe03fbbb5126729fb4b9367097acb1d1">toc</a> (<a class="el" href="structkeycpp_1_1tictoc__type.html">tictoc_type</a> &amp;Timer)</td></tr>
<tr class="memdesc:afe03fbbb5126729fb4b9367097acb1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the timer. The number of elapsed seconds is returned. <br/></td></tr>
<tr class="separator:afe03fbbb5126729fb4b9367097acb1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d70a761d33bbc2bdec6b4e0eb43d517"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517">sprintf</a> (const std::string &amp;fmt,...)</td></tr>
<tr class="memdesc:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the C++ function <a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517" title="Overload of the C++ function sprintf(). This overload provides a more MATLAB-like interface...">sprintf()</a>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. <br/></td></tr>
<tr class="separator:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806f0afebdf1131be26a05d7a4a23044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a806f0afebdf1131be26a05d7a4a23044"></a>
<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a806f0afebdf1131be26a05d7a4a23044">clock</a> ()</td></tr>
<tr class="memdesc:a806f0afebdf1131be26a05d7a4a23044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. <br/></td></tr>
<tr class="separator:a806f0afebdf1131be26a05d7a4a23044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac20bd2ef4fb18cbcdb0f462a89447bd7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac20bd2ef4fb18cbcdb0f462a89447bd7">pinv</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. <br/></td></tr>
<tr class="separator:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70d9156c4b6a75e5b7a4c799f900162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad70d9156c4b6a75e5b7a4c799f900162"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>removeWhiteSpace</b> (std::string in)</td></tr>
<tr class="separator:ad70d9156c4b6a75e5b7a4c799f900162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c0a8bc58229a412ec2068979b6b84e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c0a8bc58229a412ec2068979b6b84e"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac5c0a8bc58229a412ec2068979b6b84e">importdata</a> (std::string filename)</td></tr>
<tr class="memdesc:ac5c0a8bc58229a412ec2068979b6b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the data read from a text file. Values must be white space separated. <br/></td></tr>
<tr class="separator:ac5c0a8bc58229a412ec2068979b6b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61234b7bb0f3126b3db82634675c2951"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61234b7bb0f3126b3db82634675c2951"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a61234b7bb0f3126b3db82634675c2951"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a61234b7bb0f3126b3db82634675c2951">stdev</a> (<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a61234b7bb0f3126b3db82634675c2951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of inputed vector. <br/></td></tr>
<tr class="separator:a61234b7bb0f3126b3db82634675c2951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec07a4c4dd0fc5de230a753bf59066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdec07a4c4dd0fc5de230a753bf59066"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abdec07a4c4dd0fc5de230a753bf59066">stdev</a> (<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; v1)</td></tr>
<tr class="memdesc:abdec07a4c4dd0fc5de230a753bf59066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of inputed vector. <br/></td></tr>
<tr class="separator:abdec07a4c4dd0fc5de230a753bf59066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553528cf7a020895037ce3b1a828a04c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a553528cf7a020895037ce3b1a828a04c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a553528cf7a020895037ce3b1a828a04c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a553528cf7a020895037ce3b1a828a04c">var</a> (<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a553528cf7a020895037ce3b1a828a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variance (square of standard deviation) for inputed vector. <br/></td></tr>
<tr class="separator:a553528cf7a020895037ce3b1a828a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3249effde70a573fbd8881dc4629e04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3249effde70a573fbd8881dc4629e04"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af3249effde70a573fbd8881dc4629e04">var</a> (<a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt;&gt; v1)</td></tr>
<tr class="memdesc:af3249effde70a573fbd8881dc4629e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variance (square of standard deviation) for inputed vector. <br/></td></tr>
<tr class="separator:af3249effde70a573fbd8881dc4629e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a9561cf5654ae722a0879b41d9d73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab99a9561cf5654ae722a0879b41d9d73"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab99a9561cf5654ae722a0879b41d9d73">rand</a> (const unsigned int &amp;N)</td></tr>
<tr class="memdesc:ab99a9561cf5654ae722a0879b41d9d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an N x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:ab99a9561cf5654ae722a0879b41d9d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6413232f2de6f8ac96efde6531c3055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6413232f2de6f8ac96efde6531c3055"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af6413232f2de6f8ac96efde6531c3055">rand</a> (const unsigned int &amp;M, const unsigned int &amp;N)</td></tr>
<tr class="memdesc:af6413232f2de6f8ac96efde6531c3055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an M x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:af6413232f2de6f8ac96efde6531c3055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14e19e286b30265734236c0af2f9e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa14e19e286b30265734236c0af2f9e78">eig</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vr_return, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:aa14e19e286b30265734236c0af2f9e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double precision eigenvalue solver using LAPACK function call.  <a href="#aa14e19e286b30265734236c0af2f9e78">More...</a><br/></td></tr>
<tr class="separator:aa14e19e286b30265734236c0af2f9e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b58f47ed977cafdc96227468f5f10a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b58f47ed977cafdc96227468f5f10a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a16b58f47ed977cafdc96227468f5f10a">dgemm_</a> (const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, double *ALPHA, const double *A, const int *LDA, const double *B, const int *LDB, double *BETA, double *C, const int *LDC)</td></tr>
<tr class="memdesc:a16b58f47ed977cafdc96227468f5f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double matrix-matrix multiplication function. <br/></td></tr>
<tr class="separator:a16b58f47ed977cafdc96227468f5f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fb4e46ee1b9cce0fd8bc79a2490c72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29fb4e46ee1b9cce0fd8bc79a2490c72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a29fb4e46ee1b9cce0fd8bc79a2490c72">zgemm_</a> (const char *TRANSA, const char *TRANSB, const int *M, const int *N, const int *K, std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *B, const int *LDB, std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *C, const int *LDC)</td></tr>
<tr class="memdesc:a29fb4e46ee1b9cce0fd8bc79a2490c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double matrix-matrix multiplication function. <br/></td></tr>
<tr class="separator:a29fb4e46ee1b9cce0fd8bc79a2490c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0676a4a89dbb63f09fc627c05e12699"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0676a4a89dbb63f09fc627c05e12699"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af0676a4a89dbb63f09fc627c05e12699">dgemv_</a> (const char *TRANS, const int *M, const int *N, const double *ALPHA, const double *A, const int *LDA, const double *X, const int *INCX, const double *BETA, double *Y, const int *INCY)</td></tr>
<tr class="memdesc:af0676a4a89dbb63f09fc627c05e12699"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double matrix-vector multiplication function. <br/></td></tr>
<tr class="separator:af0676a4a89dbb63f09fc627c05e12699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea174778653491b5fd21dd2960c0f7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea174778653491b5fd21dd2960c0f7cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aea174778653491b5fd21dd2960c0f7cb">zgemv_</a> (const char *TRANS, const int *M, const int *N, const std::complex&lt; double &gt; *ALPHA, const std::complex&lt; double &gt; *A, const int *LDA, const std::complex&lt; double &gt; *X, const int *INCX, const std::complex&lt; double &gt; *BETA, std::complex&lt; double &gt; *Y, const int *INCY)</td></tr>
<tr class="memdesc:aea174778653491b5fd21dd2960c0f7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double matrix-vector multiplication function. <br/></td></tr>
<tr class="separator:aea174778653491b5fd21dd2960c0f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb32fd99bb09455f5a124df4560ab0f"><td class="memTemplParams" colspan="2"><a class="anchor" id="adfb32fd99bb09455f5a124df4560ab0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfb32fd99bb09455f5a124df4560ab0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:adfb32fd99bb09455f5a124df4560ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9358d5f3f08dd8ed262697b7e8b2a4f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9358d5f3f08dd8ed262697b7e8b2a4f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9358d5f3f08dd8ed262697b7e8b2a4f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:a9358d5f3f08dd8ed262697b7e8b2a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a724b505d52660e42e1148eba1a9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a689a724b505d52660e42e1148eba1a9a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689a724b505d52660e42e1148eba1a9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:a689a724b505d52660e42e1148eba1a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330eaaa701d2308c19f84adda097685"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7330eaaa701d2308c19f84adda097685"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7330eaaa701d2308c19f84adda097685"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:a7330eaaa701d2308c19f84adda097685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b02f40e92cad47b419ac09207518b9f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b02f40e92cad47b419ac09207518b9f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b02f40e92cad47b419ac09207518b9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:a9b02f40e92cad47b419ac09207518b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e928cddf953cbdd90b0cd6f3802b24"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6e928cddf953cbdd90b0cd6f3802b24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6e928cddf953cbdd90b0cd6f3802b24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:af6e928cddf953cbdd90b0cd6f3802b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88546738baf0a658bbe540827343939"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad88546738baf0a658bbe540827343939"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad88546738baf0a658bbe540827343939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r1, const <a class="el" href="classkeycpp_1_1_pointer_iterator.html">PointerIterator</a>&lt; T &gt; &amp;r2)</td></tr>
<tr class="separator:ad88546738baf0a658bbe540827343939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abb4e57814fd30b7b8d4845bbc16c73e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::diff </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </p>

</div>
</div>
<a class="anchor" id="a516e693670ca88debd44ca9a48b2f225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt; keycpp::eig </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vr_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vl_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </p>

</div>
</div>
<a class="anchor" id="ae24a17765339d2464a0cccb476782bff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt; std::complex&lt; double &gt; &gt; keycpp::eig </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vr_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vl_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the eigenvalues(lambda) of the complex-valued eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </p>

</div>
</div>
<a class="anchor" id="aa14e19e286b30265734236c0af2f9e78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;std::complex&lt;double&gt; &gt; keycpp::eig </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vr_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; std::complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vl_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the eigenvalues(lambda) of the eigenvalue problem: Ax_r = lambda*x_r or x_l^T*A = lambda*x_l^T. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a std::complex&lt;double&gt; matrix object in the 2nd or 3rd parameters, respectively. </p>

</div>
</div>
<a class="anchor" id="ac57d32902cba2c399475015235aeccec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </p>

</div>
</div>
<a class="anchor" id="acee6d21e4a11f11422cc5f47d37c0e72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide </td>
          <td>(</td>
          <td class="paramtype">const vector_k&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_k&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </p>

</div>
</div>
<a class="anchor" id="a9e1c37fd71074c56e963be121e5de0f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;T&gt; keycpp::logspace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The base 10 logarithm of the minimum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The base 10 logarithm of the maximum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>The number of values between 10^(x1) and 10^(x2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </dd></dl>

</div>
</div>
<a class="anchor" id="a388f91a0ccf34978ef9403ccd0c680bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::ones </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a matrix of size M x N containing all ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An M x N matrix containing ones for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="af40d69ddd09826dae133a479cff545b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;T&gt; keycpp::ones </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of length N containing all ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length N containing ones for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="aacd37d195541b2313b753b6e8839f916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </p>

</div>
</div>
<a class="anchor" id="ab299ba9f0640c2f95fe2393f2eef6ed2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide </td>
          <td>(</td>
          <td class="paramtype">const vector_k&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_k&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </p>

</div>
</div>
<a class="anchor" id="acfe17126168656af54ae76ab6c487407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; size_t, 1 &gt; keycpp::size </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of matrix A in a matrix_size_type variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix for which you want to know the size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix_size_type variable containing the number of rows and cols. </dd></dl>

</div>
</div>
<a class="anchor" id="a2824156817719ffe96a842dd0ef27ae5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int keycpp::size </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements along dimension dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix for which you want to know the size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer value of the number of elements along the desired dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a23a0fd48168263aad7f77f1769dc2f2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;)),dim&gt; keycpp::times </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </p>

</div>
</div>
<a class="anchor" id="aab613a4c8cc04981045fdea358931780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times </td>
          <td>(</td>
          <td class="paramtype">const vector_k&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_k&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </p>

</div>
</div>
<a class="anchor" id="a5699c522088657287bf0ac01173b716c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::zeros </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a matrix of size M x N containing all zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An M x N matrix containing zeros for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ac00f5a8f1eba98722c1aac6b637a18c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1vector__k.html">vector_k</a>&lt;T&gt; keycpp::zeros </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of length N containing all zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length N containing zeros for each element. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 17 2013 15:37:20 for KeyCpp -- A MATLAB-like library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
