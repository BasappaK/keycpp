<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>KeyCpp -- A MATLAB-like library for C++: keycpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KeyCpp -- A MATLAB-like library for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">keycpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library.  
</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_figure_exception.html">FigureException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_figure.html">Figure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_key_cpp_exception.html">KeyCppException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1observe.html">observe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___matrix.html">Sort_Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___vector.html">Sort_Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_s_v_d__type.html">SVD_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1matrix__size__type.html">matrix_size_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_matrix_exception.html">MatrixException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_spline_exception.html">SplineException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_spline.html">Spline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace2501951ab3db3a91c3520ae89750b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2501951ab3db3a91c3520ae89750b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace2501951ab3db3a91c3520ae89750b1">zggev_</a> (const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:ace2501951ab3db3a91c3520ae89750b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex generalized eigenvalue solver. <br/></td></tr>
<tr class="separator:ace2501951ab3db3a91c3520ae89750b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3be6524e195662cbb74a810305e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3be6524e195662cbb74a810305e721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aca3be6524e195662cbb74a810305e721">dgecon_</a> (const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</td></tr>
<tr class="memdesc:aca3be6524e195662cbb74a810305e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:aca3be6524e195662cbb74a810305e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e334ffaf1864d7191e9e0b64189783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e334ffaf1864d7191e9e0b64189783"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a75e334ffaf1864d7191e9e0b64189783">dgetrf_</a> (const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:a75e334ffaf1864d7191e9e0b64189783"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU decomposition function. <br/></td></tr>
<tr class="separator:a75e334ffaf1864d7191e9e0b64189783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c33788a2c083aa5738eda1fe62a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c33788a2c083aa5738eda1fe62a261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab9c33788a2c083aa5738eda1fe62a261">dgetrs_</a> (const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:ab9c33788a2c083aa5738eda1fe62a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU solver. <br/></td></tr>
<tr class="separator:ab9c33788a2c083aa5738eda1fe62a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507ef954be960fec70ca0f93258d730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4507ef954be960fec70ca0f93258d730"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4507ef954be960fec70ca0f93258d730">dlange_</a> (const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a4507ef954be960fec70ca0f93258d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision norm function. <br/></td></tr>
<tr class="separator:a4507ef954be960fec70ca0f93258d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e3cdc7e7929414370b6b50ea1218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444e3cdc7e7929414370b6b50ea1218c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a444e3cdc7e7929414370b6b50ea1218c">zgecon_</a> (const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</td></tr>
<tr class="memdesc:a444e3cdc7e7929414370b6b50ea1218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex-valued reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:a444e3cdc7e7929414370b6b50ea1218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18d58d53d8e19a37d74d24da27a64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18d58d53d8e19a37d74d24da27a64dd">zgetrf_</a> (const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:ab18d58d53d8e19a37d74d24da27a64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU decomposition function. <br/></td></tr>
<tr class="separator:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4322276dcdb7d864e85854b5b90f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe4322276dcdb7d864e85854b5b90f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abbe4322276dcdb7d864e85854b5b90f2">zgetrs_</a> (const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:abbe4322276dcdb7d864e85854b5b90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU solver. <br/></td></tr>
<tr class="separator:abbe4322276dcdb7d864e85854b5b90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477c910b07baef984fe8528c29b2774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1477c910b07baef984fe8528c29b2774"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1477c910b07baef984fe8528c29b2774">zlange_</a> (const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a1477c910b07baef984fe8528c29b2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex norm function. <br/></td></tr>
<tr class="separator:a1477c910b07baef984fe8528c29b2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12719f4b48de048f9642066666a920bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12719f4b48de048f9642066666a920bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a12719f4b48de048f9642066666a920bd">dgesv_</a> (const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</td></tr>
<tr class="memdesc:a12719f4b48de048f9642066666a920bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision linear system solver. <br/></td></tr>
<tr class="separator:a12719f4b48de048f9642066666a920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0d887ae48cc4222f7167232a7f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92d0d887ae48cc4222f7167232a7f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af92d0d887ae48cc4222f7167232a7f82">dgetri_</a> (const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:af92d0d887ae48cc4222f7167232a7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision matrix inverse function. <br/></td></tr>
<tr class="separator:af92d0d887ae48cc4222f7167232a7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190e125fe33133aafa586089ca6e174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4190e125fe33133aafa586089ca6e174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4190e125fe33133aafa586089ca6e174">zgetri_</a> (const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a4190e125fe33133aafa586089ca6e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex matrix inverse function. <br/></td></tr>
<tr class="separator:a4190e125fe33133aafa586089ca6e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7a71afbb6c5dc049cdd7afff6c0af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8fe7a71afbb6c5dc049cdd7afff6c0af">dgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision SVD function. <br/></td></tr>
<tr class="separator:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5e2f74110f53bd288c15ce1f183f9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afa5e2f74110f53bd288c15ce1f183f9b">zgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:afa5e2f74110f53bd288c15ce1f183f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex SVD function. <br/></td></tr>
<tr class="separator:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aca656320e1b26861469a979a96066f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aca656320e1b26861469a979a96066f"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eig</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; B, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</td></tr>
<tr class="separator:a6aca656320e1b26861469a979a96066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7545ff5c1295647680d08f2953875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b7545ff5c1295647680d08f2953875"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rcond</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; A)</td></tr>
<tr class="separator:a08b7545ff5c1295647680d08f2953875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc586899ece36154e39201f18e6db55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc586899ece36154e39201f18e6db55"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rcond</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; A)</td></tr>
<tr class="separator:a5cc586899ece36154e39201f18e6db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f68b3d9143ad3582e59dd0a4b1998b8"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linsolve</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f4a25648e5bad1cf0bd0e7fca7fae0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linsolve</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</td></tr>
<tr class="separator:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96927cda2df7a6e8e2031941c43601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96927cda2df7a6e8e2031941c43601"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:adc96927cda2df7a6e8e2031941c43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b74369f5415c3ed45f63995149ad992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b74369f5415c3ed45f63995149ad992"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a6b74369f5415c3ed45f63995149ad992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef5c1f5951e8182a7c4ec9612f3f7e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5ef5c1f5951e8182a7c4ec9612f3f7e1">rand</a> ()</td></tr>
<tr class="memdesc:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double between 0 and 1.0. <br/></td></tr>
<tr class="separator:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53e0eb41dbd6cddc6ac15d92d68c7aee"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a53e0eb41dbd6cddc6ac15d92d68c7aee">rand</a> (int N)</td></tr>
<tr class="memdesc:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an N x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc446e99edbcde1d69bfe2c74dc3c80"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#adbc446e99edbcde1d69bfe2c74dc3c80">rand</a> (int M, int N)</td></tr>
<tr class="memdesc:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an M x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e8bada51586c0561e1b32ca1ab5f2a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplParams" colspan="2"><a class="anchor" id="a300d8f6e8992c7b33156492d884bd621"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a300d8f6e8992c7b33156492d884bd621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18c262cc7b63b53f3d4c9fbeda591088"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a18c262cc7b63b53f3d4c9fbeda591088">prod</a> (const std::vector&lt; T &gt; x)</td></tr>
<tr class="memdesc:a18c262cc7b63b53f3d4c9fbeda591088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements of the vector x. <br/></td></tr>
<tr class="separator:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b348cee175715d20a1997b471c47d7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b348cee175715d20a1997b471c47d7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0b348cee175715d20a1997b471c47d7a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0b348cee175715d20a1997b471c47d7a">prod</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a0b348cee175715d20a1997b471c47d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the product of all the elements in each column of the matrix A. <br/></td></tr>
<tr class="separator:a0b348cee175715d20a1997b471c47d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9">diff</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of differences between adjacent elements. <br/></td></tr>
<tr class="separator:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf08572a2b7b23b6be5365053770fa5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cf08572a2b7b23b6be5365053770fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0cf08572a2b7b23b6be5365053770fa5">diff</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a0cf08572a2b7b23b6be5365053770fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of row differences between adjacent rows.  <a href="#a0cf08572a2b7b23b6be5365053770fa5">More...</a><br/></td></tr>
<tr class="separator:a0cf08572a2b7b23b6be5365053770fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad26d6a2ad64185a749c6f2e85aeaf62b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5cbc9dd508d193697eb9dfbef01f1404"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; x)</td></tr>
<tr class="separator:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd22caf522d677271fb915fb3aec37"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76cd22caf522d677271fb915fb3aec37"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76cd22caf522d677271fb915fb3aec37"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a76cd22caf522d677271fb915fb3aec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cc33e0299a65158c81352603bcd35a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22cc33e0299a65158c81352603bcd35a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22cc33e0299a65158c81352603bcd35a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a22cc33e0299a65158c81352603bcd35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01edbbe2645ae65b6ec2c08b2d4352e4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d66686c6b209cc8eb64f84977544da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70d66686c6b209cc8eb64f84977544da"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70d66686c6b209cc8eb64f84977544da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arg</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a70d66686c6b209cc8eb64f84977544da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e5296774667c3be4e792b5cd980da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952e5296774667c3be4e792b5cd980da"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>csqrt</b> (const double &amp;a)</td></tr>
<tr class="separator:a952e5296774667c3be4e792b5cd980da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4da6882977b2262f8d6f080b0eaf60c5"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d5dbf37b71d16d686dd0fdbad82f8fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T &amp;a, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae187563f8f86e256bc1394edcba1b2b1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A, const T &amp;a)</td></tr>
<tr class="separator:ae187563f8f86e256bc1394edcba1b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6dcf10b0db68d53d126803e8d6d591fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const std::vector&lt; T &gt; &amp;v1, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b523ff3dd5abac240788f6efb2e554e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="separator:a4b523ff3dd5abac240788f6efb2e554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2e9a06b12f7df18005a3daa3c051b2c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2665554c04ea23aad98e77d1618ca6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ac2665554c04ea23aad98e77d1618ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a390125160a7febd08d5c30629f4f698f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a390125160a7febd08d5c30629f4f698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3852c35cfcc8caa784465a26d04c68a1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:a3852c35cfcc8caa784465a26d04c68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a394f23f09cf122a8e8c20a7afd40f58e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ebc4ddf6e567714f63f0dbb8a984745"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1ebc4ddf6e567714f63f0dbb8a984745">sin</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a28c69282a740e381465a0e71bf23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a159a28c69282a740e381465a0e71bf23"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a159a28c69282a740e381465a0e71bf23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a159a28c69282a740e381465a0e71bf23">sin</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a159a28c69282a740e381465a0e71bf23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a159a28c69282a740e381465a0e71bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memTemplParams" colspan="2"><a class="anchor" id="afaf5c65950c36d6a10e2fc42cae7b041"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afaf5c65950c36d6a10e2fc42cae7b041">cos</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:afaf5c65950c36d6a10e2fc42cae7b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d906ad1b0afbefd588c619cdb02530a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d906ad1b0afbefd588c619cdb02530a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d906ad1b0afbefd588c619cdb02530a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6d906ad1b0afbefd588c619cdb02530a">cos</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a6d906ad1b0afbefd588c619cdb02530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the cosine of each element of A. <br/></td></tr>
<tr class="separator:a6d906ad1b0afbefd588c619cdb02530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2d4f2ab79da4b10e9be3af2693904ef"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa2d4f2ab79da4b10e9be3af2693904ef">exp</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24ac535f72f9e72bf2d0fb93b2b0ee01"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a24ac535f72f9e72bf2d0fb93b2b0ee01">exp</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90a6f9aaec03f1f72bf4013316795c5f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eye</b> (const int N)</td></tr>
<tr class="separator:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc5102775ed955f378432f84fe96987"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2dc5102775ed955f378432f84fe96987"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2dc5102775ed955f378432f84fe96987">size</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A, const int dim)</td></tr>
<tr class="memdesc:a2dc5102775ed955f378432f84fe96987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements along dimension dim.  <a href="#a2dc5102775ed955f378432f84fe96987">More...</a><br/></td></tr>
<tr class="separator:a2dc5102775ed955f378432f84fe96987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e501a865c86bdf616ea13e87645fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a028e501a865c86bdf616ea13e87645fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1matrix__size__type.html">matrix_size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a028e501a865c86bdf616ea13e87645fa">size</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a028e501a865c86bdf616ea13e87645fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of matrix A.  <a href="#a028e501a865c86bdf616ea13e87645fa">More...</a><br/></td></tr>
<tr class="separator:a028e501a865c86bdf616ea13e87645fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a86f1406f9fad5a439d8eff01aba8eac6">zeros</a> (const int M, const int N)</td></tr>
<tr class="memdesc:a86f1406f9fad5a439d8eff01aba8eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all zeros.  <a href="#a86f1406f9fad5a439d8eff01aba8eac6">More...</a><br/></td></tr>
<tr class="separator:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace6f21832ab61f8f15e5b35e0a5cdb3e">ones</a> (const int M, const int N)</td></tr>
<tr class="memdesc:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all ones.  <a href="#ace6f21832ab61f8f15e5b35e0a5cdb3e">More...</a><br/></td></tr>
<tr class="separator:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88b11f2372831ebb28fcd2a9961c4eab"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diag</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40a637f210b03a3901cafbd6c1a7e83f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repmat</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A, int m, int n)</td></tr>
<tr class="separator:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbea40dfc2d43cd338812f06c4f064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59fbea40dfc2d43cd338812f06c4f064"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a59fbea40dfc2d43cd338812f06c4f064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repmat</b> (const std::vector&lt; T &gt; v1, int m, int n)</td></tr>
<tr class="separator:a59fbea40dfc2d43cd338812f06c4f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac1ff99e34619478096c271b38df1f3d7">times</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:ac1ff99e34619478096c271b38df1f3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on matrices A and B.  <a href="#ac1ff99e34619478096c271b38df1f3d7">More...</a><br/></td></tr>
<tr class="separator:ac1ff99e34619478096c271b38df1f3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a90d5fd4f9f7c52f16425105995655e9d">times</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a90d5fd4f9f7c52f16425105995655e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on vectors v1 and v2.  <a href="#a90d5fd4f9f7c52f16425105995655e9d">More...</a><br/></td></tr>
<tr class="separator:a90d5fd4f9f7c52f16425105995655e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aacd37d195541b2313b753b6e8839f916">rdivide</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:aacd37d195541b2313b753b6e8839f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on matrices A and B.  <a href="#aacd37d195541b2313b753b6e8839f916">More...</a><br/></td></tr>
<tr class="separator:aacd37d195541b2313b753b6e8839f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af234cd07a4e1d649629a6b83dbe113ff">rdivide</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:af234cd07a4e1d649629a6b83dbe113ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on vectors v1 and v2.  <a href="#af234cd07a4e1d649629a6b83dbe113ff">More...</a><br/></td></tr>
<tr class="separator:af234cd07a4e1d649629a6b83dbe113ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac57d32902cba2c399475015235aeccec">ldivide</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; &amp;B, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; &amp;A)</td></tr>
<tr class="memdesc:ac57d32902cba2c399475015235aeccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on matrices B and A.  <a href="#ac57d32902cba2c399475015235aeccec">More...</a><br/></td></tr>
<tr class="separator:ac57d32902cba2c399475015235aeccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7a86bc7e25833cdf9266c038a4edb0ea">ldivide</a> (const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="memdesc:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on vectors v2 and v1.  <a href="#a7a86bc7e25833cdf9266c038a4edb0ea">More...</a><br/></td></tr>
<tr class="separator:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1cd159623e23abeedd26d34fc500d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f1cd159623e23abeedd26d34fc500d9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f1cd159623e23abeedd26d34fc500d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (T val)</td></tr>
<tr class="separator:a8f1cd159623e23abeedd26d34fc500d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebb8d8939a33f6c3cb00be9278114c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abebb8d8939a33f6c3cb00be9278114c6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abebb8d8939a33f6c3cb00be9278114c6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:abebb8d8939a33f6c3cb00be9278114c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef49e492f67187d0909c7ae093fee48"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ef49e492f67187d0909c7ae093fee48"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ef49e492f67187d0909c7ae093fee48"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a8ef49e492f67187d0909c7ae093fee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c90b0df3a170c845b848593be4cb74"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83c90b0df3a170c845b848593be4cb74"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a83c90b0df3a170c845b848593be4cb74"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle</b> (T x)</td></tr>
<tr class="separator:a83c90b0df3a170c845b848593be4cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13ee1c3dd9cbb21a325260188a7fa860"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73269c9db9fe25412819858bd7048ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73269c9db9fe25412819858bd7048ae5"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (std::vector&lt; std::complex&lt; double &gt; &gt; x)</td></tr>
<tr class="separator:a73269c9db9fe25412819858bd7048ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed77b31791ec78800e98ace1cbc3693d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed77b31791ec78800e98ace1cbc3693d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aed77b31791ec78800e98ace1cbc3693d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="separator:aed77b31791ec78800e98ace1cbc3693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7577228b38fa6a1911ac65fb80832f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7577228b38fa6a1911ac65fb80832f3"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (std::vector&lt; std::complex&lt; double &gt; &gt; x)</td></tr>
<tr class="separator:ab7577228b38fa6a1911ac65fb80832f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad68697505d1a1a85f30a18b0e9b0eb2f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad68697505d1a1a85f30a18b0e9b0eb2f">transpose</a> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of matrix A. <br/></td></tr>
<tr class="separator:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148d677899a0da5ab14edfc5057a97b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa148d677899a0da5ab14edfc5057a97b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa148d677899a0da5ab14edfc5057a97b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa148d677899a0da5ab14edfc5057a97b">transpose</a> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa148d677899a0da5ab14edfc5057a97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of vector v1. <br/></td></tr>
<tr class="separator:aa148d677899a0da5ab14edfc5057a97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88081df8038d0b630d6a3540aeca8b9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88081df8038d0b630d6a3540aeca8b9a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88081df8038d0b630d6a3540aeca8b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a88081df8038d0b630d6a3540aeca8b9a">ctranspose</a> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:a88081df8038d0b630d6a3540aeca8b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a88081df8038d0b630d6a3540aeca8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827218d19d98cf1357032a652a9bf4e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a827218d19d98cf1357032a652a9bf4e5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a827218d19d98cf1357032a652a9bf4e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a827218d19d98cf1357032a652a9bf4e5">ctranspose</a> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a827218d19d98cf1357032a652a9bf4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of vector v1. <br/></td></tr>
<tr class="separator:a827218d19d98cf1357032a652a9bf4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aedb589e76ced5d79d62c5f72029adb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4aedb589e76ced5d79d62c5f72029adb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4aedb589e76ced5d79d62c5f72029adb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="separator:a4aedb589e76ced5d79d62c5f72029adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad05b888638b5ea7103bdc6ba0882d47d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="separator:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0e8201f775945a0a61d6d645a3456e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a0e8201f775945a0a61d6d645a3456e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a0e8201f775945a0a61d6d645a3456e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mat2vec</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="separator:a8a0e8201f775945a0a61d6d645a3456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d3ef9b10b3db438529bafc5e74fa0dc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vec2mat</b> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="separator:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab57eee495c93eb18ebf8c8ccf4d44e74">linspace</a> (const T x1, const T x2, const int N)</td></tr>
<tr class="memdesc:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values equally spaced between x1 and x2, inclusively.  <a href="#ab57eee495c93eb18ebf8c8ccf4d44e74">More...</a><br/></td></tr>
<tr class="separator:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92462e3b25414144d4e45fc269d2f13"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac92462e3b25414144d4e45fc269d2f13"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac92462e3b25414144d4e45fc269d2f13">logspace</a> (const T x1, const T x2, int N)</td></tr>
<tr class="memdesc:ac92462e3b25414144d4e45fc269d2f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively.  <a href="#ac92462e3b25414144d4e45fc269d2f13">More...</a><br/></td></tr>
<tr class="separator:ac92462e3b25414144d4e45fc269d2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e350b4b11ea4d9962b4daa13cc66e32"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const std::vector&lt; T &gt; &amp;v1, T tol=pi)</td></tr>
<tr class="separator:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1acd03db6a49523cb5dbe751a80917a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ad1acd03db6a49523cb5dbe751a80917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123211086c4953fe9346acc22b2a67f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a123211086c4953fe9346acc22b2a67f9"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a123211086c4953fe9346acc22b2a67f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, U x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a123211086c4953fe9346acc22b2a67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56633eb0878a0dbe6596fb0e74fdc6ea"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6dfc562f4ab516d21be63ab8a9c1b23"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b44770c6a8c5ba4acb6fe6ead6cc811"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; std::vector&lt; T &gt; &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ab894467bbea180c9b283895d5d5d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5ab894467bbea180c9b283895d5d5d3"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac5ab894467bbea180c9b283895d5d5d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:ac5ab894467bbea180c9b283895d5d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c19f6ff8e0001eca5c63529bd58e664"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; std::vector&lt; U &gt; &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=<a class="el" href="classkeycpp_1_1_extrap.html">Extrap</a>())</td></tr>
<tr class="separator:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad817c482d12509f0938849890bb4de4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad817c482d12509f0938849890bb4de4e"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:ad817c482d12509f0938849890bb4de4e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trapz</b> (std::vector&lt; U &gt; eta, std::vector&lt; T &gt; integrand)</td></tr>
<tr class="separator:ad817c482d12509f0938849890bb4de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379324b1d1cb219fdde96c9678aa5341"><td class="memTemplParams" colspan="2"><a class="anchor" id="a379324b1d1cb219fdde96c9678aa5341"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a379324b1d1cb219fdde96c9678aa5341"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; U &gt; eta, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; u, int index=2)</td></tr>
<tr class="separator:a379324b1d1cb219fdde96c9678aa5341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b09f118fe12b83865ff08fe3d3633ff"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (std::vector&lt; U &gt; eta, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; u)</td></tr>
<tr class="separator:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3bdbcb862d76b1b1fb5157788b7336ae"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diffxy</b> (std::vector&lt; U &gt; eta, std::vector&lt; T &gt; u)</td></tr>
<tr class="separator:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b17b3d224192fffc838834ff736d572"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b17b3d224192fffc838834ff736d572"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b17b3d224192fffc838834ff736d572"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fft</b> (std::vector&lt; T &gt; u, int N=-1)</td></tr>
<tr class="separator:a6b17b3d224192fffc838834ff736d572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a880f7df231a78f912b3fb5d301c809f9"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ode45</b> (F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:a880f7df231a78f912b3fb5d301c809f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6ae07fc18f5374868fe314f00108c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd6ae07fc18f5374868fe314f00108c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (<a class="el" href="classkeycpp_1_1_figure.html">Figure</a> &amp;h, std::string property, double val)</td></tr>
<tr class="separator:afcd6ae07fc18f5374868fe314f00108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6862448bf6e09309e60a6ba7aa0caf9a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1_sort___matrix.html">Sort_Matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; T &gt; A, int dim=2, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1be4e97b99a996a01f428fd8ba048fb0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkeycpp_1_1_sort___vector.html">Sort_Vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (std::vector&lt; T &gt; v1, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5236252f6a33f3523fb805a2d1727c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e5236252f6a33f3523fb805a2d1727c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a7e5236252f6a33f3523fb805a2d1727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b80bd145aab03a9e79a42d32ca573bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b80bd145aab03a9e79a42d32ca573bd"></a>
<a class="el" href="structkeycpp_1_1_s_v_d__type.html">SVD_type</a>&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4b80bd145aab03a9e79a42d32ca573bd">svd</a> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; double &gt; A_in, std::string method)</td></tr>
<tr class="memdesc:a4b80bd145aab03a9e79a42d32ca573bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a4b80bd145aab03a9e79a42d32ca573bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ba604b4e72e41b123f890dd66d854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867ba604b4e72e41b123f890dd66d854"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a867ba604b4e72e41b123f890dd66d854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d15c3c38ff98e6d9afdd9db4b46c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d15c3c38ff98e6d9afdd9db4b46c6c"></a>
<a class="el" href="structkeycpp_1_1_s_v_d__type.html">SVD_type</a>&lt; std::complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>svd</b> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;&quot;)</td></tr>
<tr class="separator:aa6d15c3c38ff98e6d9afdd9db4b46c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190640edb8e634de02d302d94a29ee17"><td class="memItemLeft" align="right" valign="top">vector&lt; complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a190640edb8e634de02d302d94a29ee17">eig</a> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt; &gt; A, const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt; &gt; B, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt; &gt; *vr_return, <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:a190640edb8e634de02d302d94a29ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized complex-valued eigenvalue solver using LAPACK function call.  <a href="#a190640edb8e634de02d302d94a29ee17">More...</a><br/></td></tr>
<tr class="separator:a190640edb8e634de02d302d94a29ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea0bb8f128ef0cdf55a79c50ceccb83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acea0bb8f128ef0cdf55a79c50ceccb83"></a>
std::vector&lt; complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linsolve</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:acea0bb8f128ef0cdf55a79c50ceccb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cabca49e9650ae8b5aadf5ee2f7f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9cabca49e9650ae8b5aadf5ee2f7f4e"></a>
<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:ac9cabca49e9650ae8b5aadf5ee2f7f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a41d0919918b5cf62ef28dd68217d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a41d0919918b5cf62ef28dd68217d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt;&gt; A_in, std::string method)</td></tr>
<tr class="separator:af1a41d0919918b5cf62ef28dd68217d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913fb7501259de640e7119a852adafc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a913fb7501259de640e7119a852adafc9"></a>
<a class="el" href="structkeycpp_1_1_s_v_d__type.html">SVD_type</a>&lt; complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a913fb7501259de640e7119a852adafc9">svd</a> (<a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt; complex&lt; double &gt;&gt; A_in, std::string method)</td></tr>
<tr class="memdesc:a913fb7501259de640e7119a852adafc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a913fb7501259de640e7119a852adafc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0cf08572a2b7b23b6be5365053770fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::diff </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Add recursive functionality and make sure it picks first non-singleton dimension. Also, accept dimension as argument. See MATLAB docs. </p>

</div>
</div>
<a class="anchor" id="a190640edb8e634de02d302d94a29ee17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;complex&lt;double&gt; &gt; keycpp::eig </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; complex&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; complex&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vr_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; complex&lt; double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>vl_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the eigenvalues(lambda) of the complex-valued generalized eigenvalue problem: Ax_r = lambda*Bx_r or x_l^T*A = lambda*x_l^T*B. The eigenvalues are returned by default. To return the right or left eigenvectors, supply the function with a complex&lt;double&gt; matrix object in the 3rd or 4th parameters, respectively. </p>

</div>
</div>
<a class="anchor" id="ac57d32902cba2c399475015235aeccec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is divided by each element of B. The matrix that is returned is the same size as B and A. Equivalent to B. in MATLAB. </p>

</div>
</div>
<a class="anchor" id="a7a86bc7e25833cdf9266c038a4edb0ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::ldivide </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v2 and v1. Equivalent to v2. in MATLAB. </p>

</div>
</div>
<a class="anchor" id="ab57eee495c93eb18ebf8c8ccf4d44e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; keycpp::linspace </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produces a vector containing N values equally spaced between x1 and x2, inclusively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The minimum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The maximum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>The number of values between x1 and x2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing N equally spaced values between x1 and x2, inclusively. </dd></dl>

</div>
</div>
<a class="anchor" id="ac92462e3b25414144d4e45fc269d2f13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; keycpp::logspace </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>The base 10 logarithm of the minimum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>The base 10 logarithm of the maximum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>The number of values between 10^(x1) and 10^(x2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing N logarithmically spaced values between 10^(x1) and 10^(x2), inclusively. </dd></dl>

</div>
</div>
<a class="anchor" id="ace6f21832ab61f8f15e5b35e0a5cdb3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::ones </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a matrix of size M x N containing all ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An M x N matrix containing ones for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="aacd37d195541b2313b753b6e8839f916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is divided by each element of B. The matrix that is returned is the same size as A and B. Equivalent to A./B in MATLAB. </p>

</div>
</div>
<a class="anchor" id="af234cd07a4e1d649629a6b83dbe113ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::rdivide </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is divided by each element of v2. The vector that is returned is the same size as v1 and v2. Equivalent to v1./v2 in MATLAB. </p>

</div>
</div>
<a class="anchor" id="a2dc5102775ed955f378432f84fe96987"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int keycpp::size </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements along dimension dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix for which you want to know the size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension along which you want the number of elements. 1 = number of rows, 2 = number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer value of the number of elements along the desired dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a028e501a865c86bdf616ea13e87645fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkeycpp_1_1matrix__size__type.html">matrix_size_type</a> keycpp::size </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of matrix A in a <a class="el" href="structkeycpp_1_1matrix__size__type.html">matrix_size_type</a> variable.  auto msize = size(A); int num_rows = msize.rows; int num_cols = msize.cols; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix for which you want to know the size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structkeycpp_1_1matrix__size__type.html">matrix_size_type</a> variable containing the number of rows and cols. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1ff99e34619478096c271b38df1f3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of A is multiplied by each element of B. The matrix that is returned is the same size as A and B. </p>

</div>
</div>
<a class="anchor" id="a90d5fd4f9f7c52f16425105995655e9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;decltype(std::declval&lt;T&gt;)*std::declval&lt;U&gt;))&gt; keycpp::times </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element of v1 is multiplied by each element of v2. The vector that is returned is the same size as v1 and v2. </p>

</div>
</div>
<a class="anchor" id="a86f1406f9fad5a439d8eff01aba8eac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkeycpp_1_1matrix.html">matrix</a>&lt;T&gt; keycpp::zeros </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a matrix of size M x N containing all zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An M x N matrix containing zeros for each element. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 12 2013 16:05:43 for KeyCpp -- A MATLAB-like library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{
var pageTracker = _gat._getTracker("UA-42949208-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
