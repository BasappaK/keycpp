<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>KeyCpp -- A MATLAB-like library for C++: keycpp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KeyCpp -- A MATLAB-like library for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">keycpp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;iomanip&gt;</code><br/>
<code>#include &lt;complex&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;cmath&gt;</code><br/>
<code>#include &lt;boost/numeric/odeint.hpp&gt;</code><br/>
<code>#include &lt;utility&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &quot;Matrix.h&quot;</code><br/>
<code>#include &quot;kiss_fft.h&quot;</code><br/>
<code>#include &quot;Spline.h&quot;</code><br/>
<code>#include &quot;Figure.h&quot;</code><br/>
</div>
<p><a href="keycpp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_key_cpp_exception.html">keycpp::KeyCppException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1observe.html">keycpp::observe&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___matrix.html">keycpp::Sort_Matrix&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___vector.html">keycpp::Sort_Vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_s_v_d__type.html">keycpp::SVD_type&lt; T, X &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacekeycpp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html">keycpp</a></td></tr>
<tr class="memdesc:namespacekeycpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1daf785e3f68d293c7caa1c756d5cb74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1daf785e3f68d293c7caa1c756d5cb74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pi</b>&#160;&#160;&#160;3.1415926535897932384626433832795</td></tr>
<tr class="separator:a1daf785e3f68d293c7caa1c756d5cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace2501951ab3db3a91c3520ae89750b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2501951ab3db3a91c3520ae89750b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace2501951ab3db3a91c3520ae89750b1">keycpp::zggev_</a> (const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:ace2501951ab3db3a91c3520ae89750b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex generalized eigenvalue solver. <br/></td></tr>
<tr class="separator:ace2501951ab3db3a91c3520ae89750b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3be6524e195662cbb74a810305e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3be6524e195662cbb74a810305e721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aca3be6524e195662cbb74a810305e721">keycpp::dgecon_</a> (const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</td></tr>
<tr class="memdesc:aca3be6524e195662cbb74a810305e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:aca3be6524e195662cbb74a810305e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e334ffaf1864d7191e9e0b64189783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e334ffaf1864d7191e9e0b64189783"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a75e334ffaf1864d7191e9e0b64189783">keycpp::dgetrf_</a> (const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:a75e334ffaf1864d7191e9e0b64189783"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU decomposition function. <br/></td></tr>
<tr class="separator:a75e334ffaf1864d7191e9e0b64189783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c33788a2c083aa5738eda1fe62a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c33788a2c083aa5738eda1fe62a261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab9c33788a2c083aa5738eda1fe62a261">keycpp::dgetrs_</a> (const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:ab9c33788a2c083aa5738eda1fe62a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU solver. <br/></td></tr>
<tr class="separator:ab9c33788a2c083aa5738eda1fe62a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507ef954be960fec70ca0f93258d730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4507ef954be960fec70ca0f93258d730"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4507ef954be960fec70ca0f93258d730">keycpp::dlange_</a> (const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a4507ef954be960fec70ca0f93258d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision norm function. <br/></td></tr>
<tr class="separator:a4507ef954be960fec70ca0f93258d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e3cdc7e7929414370b6b50ea1218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444e3cdc7e7929414370b6b50ea1218c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a444e3cdc7e7929414370b6b50ea1218c">keycpp::zgecon_</a> (const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</td></tr>
<tr class="memdesc:a444e3cdc7e7929414370b6b50ea1218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex-valued reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:a444e3cdc7e7929414370b6b50ea1218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18d58d53d8e19a37d74d24da27a64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18d58d53d8e19a37d74d24da27a64dd">keycpp::zgetrf_</a> (const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:ab18d58d53d8e19a37d74d24da27a64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU decomposition function. <br/></td></tr>
<tr class="separator:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4322276dcdb7d864e85854b5b90f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe4322276dcdb7d864e85854b5b90f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abbe4322276dcdb7d864e85854b5b90f2">keycpp::zgetrs_</a> (const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:abbe4322276dcdb7d864e85854b5b90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU solver. <br/></td></tr>
<tr class="separator:abbe4322276dcdb7d864e85854b5b90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477c910b07baef984fe8528c29b2774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1477c910b07baef984fe8528c29b2774"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1477c910b07baef984fe8528c29b2774">keycpp::zlange_</a> (const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a1477c910b07baef984fe8528c29b2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex norm function. <br/></td></tr>
<tr class="separator:a1477c910b07baef984fe8528c29b2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12719f4b48de048f9642066666a920bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12719f4b48de048f9642066666a920bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a12719f4b48de048f9642066666a920bd">keycpp::dgesv_</a> (const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</td></tr>
<tr class="memdesc:a12719f4b48de048f9642066666a920bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision linear system solver. <br/></td></tr>
<tr class="separator:a12719f4b48de048f9642066666a920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0d887ae48cc4222f7167232a7f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92d0d887ae48cc4222f7167232a7f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af92d0d887ae48cc4222f7167232a7f82">keycpp::dgetri_</a> (const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:af92d0d887ae48cc4222f7167232a7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision matrix inverse function. <br/></td></tr>
<tr class="separator:af92d0d887ae48cc4222f7167232a7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190e125fe33133aafa586089ca6e174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4190e125fe33133aafa586089ca6e174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4190e125fe33133aafa586089ca6e174">keycpp::zgetri_</a> (const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a4190e125fe33133aafa586089ca6e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex matrix inverse function. <br/></td></tr>
<tr class="separator:a4190e125fe33133aafa586089ca6e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7a71afbb6c5dc049cdd7afff6c0af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8fe7a71afbb6c5dc049cdd7afff6c0af">keycpp::dgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision SVD function. <br/></td></tr>
<tr class="separator:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5e2f74110f53bd288c15ce1f183f9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afa5e2f74110f53bd288c15ce1f183f9b">keycpp::zgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:afa5e2f74110f53bd288c15ce1f183f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex SVD function. <br/></td></tr>
<tr class="separator:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aca656320e1b26861469a979a96066f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aca656320e1b26861469a979a96066f"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::eig</b> (const matrix&lt; std::complex&lt; double &gt; &gt; A, const matrix&lt; std::complex&lt; double &gt; &gt; B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</td></tr>
<tr class="separator:a6aca656320e1b26861469a979a96066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7545ff5c1295647680d08f2953875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b7545ff5c1295647680d08f2953875"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; double &gt; A)</td></tr>
<tr class="separator:a08b7545ff5c1295647680d08f2953875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc586899ece36154e39201f18e6db55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc586899ece36154e39201f18e6db55"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; std::complex&lt; double &gt;&gt; A)</td></tr>
<tr class="separator:a5cc586899ece36154e39201f18e6db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f68b3d9143ad3582e59dd0a4b1998b8"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f4a25648e5bad1cf0bd0e7fca7fae0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</td></tr>
<tr class="separator:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96927cda2df7a6e8e2031941c43601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96927cda2df7a6e8e2031941c43601"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:adc96927cda2df7a6e8e2031941c43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b74369f5415c3ed45f63995149ad992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b74369f5415c3ed45f63995149ad992"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a6b74369f5415c3ed45f63995149ad992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef5c1f5951e8182a7c4ec9612f3f7e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5ef5c1f5951e8182a7c4ec9612f3f7e1">keycpp::rand</a> ()</td></tr>
<tr class="memdesc:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double between 0 and 1.0. <br/></td></tr>
<tr class="separator:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53e0eb41dbd6cddc6ac15d92d68c7aee"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a53e0eb41dbd6cddc6ac15d92d68c7aee">keycpp::rand</a> (int N)</td></tr>
<tr class="memdesc:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an N x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:a53e0eb41dbd6cddc6ac15d92d68c7aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc446e99edbcde1d69bfe2c74dc3c80"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#adbc446e99edbcde1d69bfe2c74dc3c80">keycpp::rand</a> (int M, int N)</td></tr>
<tr class="memdesc:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an M x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:adbc446e99edbcde1d69bfe2c74dc3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e8bada51586c0561e1b32ca1ab5f2a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator&lt;&lt;</b> (std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplParams" colspan="2"><a class="anchor" id="a300d8f6e8992c7b33156492d884bd621"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator&lt;&lt;</b> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a300d8f6e8992c7b33156492d884bd621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18c262cc7b63b53f3d4c9fbeda591088"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a18c262cc7b63b53f3d4c9fbeda591088">keycpp::prod</a> (const std::vector&lt; T &gt; x)</td></tr>
<tr class="memdesc:a18c262cc7b63b53f3d4c9fbeda591088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements of the vector x. <br/></td></tr>
<tr class="separator:a18c262cc7b63b53f3d4c9fbeda591088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b348cee175715d20a1997b471c47d7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b348cee175715d20a1997b471c47d7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0b348cee175715d20a1997b471c47d7a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0b348cee175715d20a1997b471c47d7a">keycpp::prod</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a0b348cee175715d20a1997b471c47d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the product of all the elements in each column of the matrix A. <br/></td></tr>
<tr class="separator:a0b348cee175715d20a1997b471c47d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9">keycpp::diff</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of differences between adjacent elements. <br/></td></tr>
<tr class="separator:aa4d7bfe3e5ee5f1b805e9aa64c5ba1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf08572a2b7b23b6be5365053770fa5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cf08572a2b7b23b6be5365053770fa5"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0cf08572a2b7b23b6be5365053770fa5">keycpp::diff</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a0cf08572a2b7b23b6be5365053770fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of row differences between adjacent rows.  <a href="#a0cf08572a2b7b23b6be5365053770fa5">More...</a><br/></td></tr>
<tr class="separator:a0cf08572a2b7b23b6be5365053770fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad26d6a2ad64185a749c6f2e85aeaf62b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::conj</b> (const std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:ad26d6a2ad64185a749c6f2e85aeaf62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5cbc9dd508d193697eb9dfbef01f1404"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::conj</b> (const matrix&lt; T &gt; x)</td></tr>
<tr class="separator:a5cbc9dd508d193697eb9dfbef01f1404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd22caf522d677271fb915fb3aec37"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76cd22caf522d677271fb915fb3aec37"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76cd22caf522d677271fb915fb3aec37"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::real</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a76cd22caf522d677271fb915fb3aec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cc33e0299a65158c81352603bcd35a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22cc33e0299a65158c81352603bcd35a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22cc33e0299a65158c81352603bcd35a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::imag</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a22cc33e0299a65158c81352603bcd35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01edbbe2645ae65b6ec2c08b2d4352e4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a01edbbe2645ae65b6ec2c08b2d4352e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d66686c6b209cc8eb64f84977544da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70d66686c6b209cc8eb64f84977544da"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70d66686c6b209cc8eb64f84977544da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::arg</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a70d66686c6b209cc8eb64f84977544da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e5296774667c3be4e792b5cd980da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952e5296774667c3be4e792b5cd980da"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::csqrt</b> (const double &amp;a)</td></tr>
<tr class="separator:a952e5296774667c3be4e792b5cd980da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4da6882977b2262f8d6f080b0eaf60c5"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d5dbf37b71d16d686dd0fdbad82f8fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const T &amp;a, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae187563f8f86e256bc1394edcba1b2b1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const matrix&lt; U &gt; &amp;A, const T &amp;a)</td></tr>
<tr class="separator:ae187563f8f86e256bc1394edcba1b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6dcf10b0db68d53d126803e8d6d591fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const std::vector&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b523ff3dd5abac240788f6efb2e554e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="separator:a4b523ff3dd5abac240788f6efb2e554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2e9a06b12f7df18005a3daa3c051b2c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2665554c04ea23aad98e77d1618ca6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ac2665554c04ea23aad98e77d1618ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a390125160a7febd08d5c30629f4f698f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a390125160a7febd08d5c30629f4f698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3852c35cfcc8caa784465a26d04c68a1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const matrix&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:a3852c35cfcc8caa784465a26d04c68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a394f23f09cf122a8e8c20a7afd40f58e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ebc4ddf6e567714f63f0dbb8a984745"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1ebc4ddf6e567714f63f0dbb8a984745">keycpp::sin</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:a1ebc4ddf6e567714f63f0dbb8a984745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a28c69282a740e381465a0e71bf23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a159a28c69282a740e381465a0e71bf23"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a159a28c69282a740e381465a0e71bf23"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a159a28c69282a740e381465a0e71bf23">keycpp::sin</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a159a28c69282a740e381465a0e71bf23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a159a28c69282a740e381465a0e71bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memTemplParams" colspan="2"><a class="anchor" id="afaf5c65950c36d6a10e2fc42cae7b041"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afaf5c65950c36d6a10e2fc42cae7b041">keycpp::cos</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:afaf5c65950c36d6a10e2fc42cae7b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:afaf5c65950c36d6a10e2fc42cae7b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d906ad1b0afbefd588c619cdb02530a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d906ad1b0afbefd588c619cdb02530a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d906ad1b0afbefd588c619cdb02530a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6d906ad1b0afbefd588c619cdb02530a">keycpp::cos</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a6d906ad1b0afbefd588c619cdb02530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the cosine of each element of A. <br/></td></tr>
<tr class="separator:a6d906ad1b0afbefd588c619cdb02530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2d4f2ab79da4b10e9be3af2693904ef"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa2d4f2ab79da4b10e9be3af2693904ef">keycpp::exp</a> (const std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:aa2d4f2ab79da4b10e9be3af2693904ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24ac535f72f9e72bf2d0fb93b2b0ee01"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a24ac535f72f9e72bf2d0fb93b2b0ee01">keycpp::exp</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a24ac535f72f9e72bf2d0fb93b2b0ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90a6f9aaec03f1f72bf4013316795c5f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eye</b> (const int N)</td></tr>
<tr class="separator:a90a6f9aaec03f1f72bf4013316795c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc5102775ed955f378432f84fe96987"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2dc5102775ed955f378432f84fe96987"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2dc5102775ed955f378432f84fe96987">keycpp::size</a> (const matrix&lt; T &gt; A, const int dim)</td></tr>
<tr class="memdesc:a2dc5102775ed955f378432f84fe96987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements along dimension dim.  <a href="#a2dc5102775ed955f378432f84fe96987">More...</a><br/></td></tr>
<tr class="separator:a2dc5102775ed955f378432f84fe96987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e501a865c86bdf616ea13e87645fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a028e501a865c86bdf616ea13e87645fa"><td class="memTemplItemLeft" align="right" valign="top">matrix_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a028e501a865c86bdf616ea13e87645fa">keycpp::size</a> (const matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a028e501a865c86bdf616ea13e87645fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of matrix A.  <a href="#a028e501a865c86bdf616ea13e87645fa">More...</a><br/></td></tr>
<tr class="separator:a028e501a865c86bdf616ea13e87645fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a86f1406f9fad5a439d8eff01aba8eac6">keycpp::zeros</a> (const int M, const int N)</td></tr>
<tr class="memdesc:a86f1406f9fad5a439d8eff01aba8eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all zeros.  <a href="#a86f1406f9fad5a439d8eff01aba8eac6">More...</a><br/></td></tr>
<tr class="separator:a86f1406f9fad5a439d8eff01aba8eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace6f21832ab61f8f15e5b35e0a5cdb3e">keycpp::ones</a> (const int M, const int N)</td></tr>
<tr class="memdesc:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all ones.  <a href="#ace6f21832ab61f8f15e5b35e0a5cdb3e">More...</a><br/></td></tr>
<tr class="separator:ace6f21832ab61f8f15e5b35e0a5cdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88b11f2372831ebb28fcd2a9961c4eab"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:a88b11f2372831ebb28fcd2a9961c4eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40a637f210b03a3901cafbd6c1a7e83f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::repmat</b> (const matrix&lt; T &gt; A, int m, int n)</td></tr>
<tr class="separator:a40a637f210b03a3901cafbd6c1a7e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbea40dfc2d43cd338812f06c4f064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59fbea40dfc2d43cd338812f06c4f064"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a59fbea40dfc2d43cd338812f06c4f064"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::repmat</b> (const std::vector&lt; T &gt; v1, int m, int n)</td></tr>
<tr class="separator:a59fbea40dfc2d43cd338812f06c4f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac1ff99e34619478096c271b38df1f3d7">keycpp::times</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:ac1ff99e34619478096c271b38df1f3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on matrices A and B.  <a href="#ac1ff99e34619478096c271b38df1f3d7">More...</a><br/></td></tr>
<tr class="separator:ac1ff99e34619478096c271b38df1f3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a90d5fd4f9f7c52f16425105995655e9d">keycpp::times</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a90d5fd4f9f7c52f16425105995655e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on vectors v1 and v2.  <a href="#a90d5fd4f9f7c52f16425105995655e9d">More...</a><br/></td></tr>
<tr class="separator:a90d5fd4f9f7c52f16425105995655e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aacd37d195541b2313b753b6e8839f916">keycpp::rdivide</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:aacd37d195541b2313b753b6e8839f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on matrices A and B.  <a href="#aacd37d195541b2313b753b6e8839f916">More...</a><br/></td></tr>
<tr class="separator:aacd37d195541b2313b753b6e8839f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af234cd07a4e1d649629a6b83dbe113ff">keycpp::rdivide</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:af234cd07a4e1d649629a6b83dbe113ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on vectors v1 and v2.  <a href="#af234cd07a4e1d649629a6b83dbe113ff">More...</a><br/></td></tr>
<tr class="separator:af234cd07a4e1d649629a6b83dbe113ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac57d32902cba2c399475015235aeccec">keycpp::ldivide</a> (const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="memdesc:ac57d32902cba2c399475015235aeccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on matrices B and A.  <a href="#ac57d32902cba2c399475015235aeccec">More...</a><br/></td></tr>
<tr class="separator:ac57d32902cba2c399475015235aeccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7a86bc7e25833cdf9266c038a4edb0ea">keycpp::ldivide</a> (const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="memdesc:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on vectors v2 and v1.  <a href="#a7a86bc7e25833cdf9266c038a4edb0ea">More...</a><br/></td></tr>
<tr class="separator:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1cd159623e23abeedd26d34fc500d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f1cd159623e23abeedd26d34fc500d9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f1cd159623e23abeedd26d34fc500d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sign</b> (T val)</td></tr>
<tr class="separator:a8f1cd159623e23abeedd26d34fc500d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebb8d8939a33f6c3cb00be9278114c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abebb8d8939a33f6c3cb00be9278114c6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abebb8d8939a33f6c3cb00be9278114c6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::max</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:abebb8d8939a33f6c3cb00be9278114c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef49e492f67187d0909c7ae093fee48"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ef49e492f67187d0909c7ae093fee48"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ef49e492f67187d0909c7ae093fee48"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::min</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a8ef49e492f67187d0909c7ae093fee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c90b0df3a170c845b848593be4cb74"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83c90b0df3a170c845b848593be4cb74"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a83c90b0df3a170c845b848593be4cb74"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (T x)</td></tr>
<tr class="separator:a83c90b0df3a170c845b848593be4cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13ee1c3dd9cbb21a325260188a7fa860"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (std::vector&lt; T &gt; x)</td></tr>
<tr class="separator:a13ee1c3dd9cbb21a325260188a7fa860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73269c9db9fe25412819858bd7048ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73269c9db9fe25412819858bd7048ae5"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::max</b> (std::vector&lt; std::complex&lt; double &gt; &gt; x)</td></tr>
<tr class="separator:a73269c9db9fe25412819858bd7048ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed77b31791ec78800e98ace1cbc3693d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed77b31791ec78800e98ace1cbc3693d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aed77b31791ec78800e98ace1cbc3693d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::max</b> (matrix&lt; T &gt; A)</td></tr>
<tr class="separator:aed77b31791ec78800e98ace1cbc3693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7577228b38fa6a1911ac65fb80832f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7577228b38fa6a1911ac65fb80832f3"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::min</b> (std::vector&lt; std::complex&lt; double &gt; &gt; x)</td></tr>
<tr class="separator:ab7577228b38fa6a1911ac65fb80832f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad68697505d1a1a85f30a18b0e9b0eb2f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad68697505d1a1a85f30a18b0e9b0eb2f">keycpp::transpose</a> (matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of matrix A. <br/></td></tr>
<tr class="separator:ad68697505d1a1a85f30a18b0e9b0eb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148d677899a0da5ab14edfc5057a97b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa148d677899a0da5ab14edfc5057a97b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa148d677899a0da5ab14edfc5057a97b"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa148d677899a0da5ab14edfc5057a97b">keycpp::transpose</a> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:aa148d677899a0da5ab14edfc5057a97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of vector v1. <br/></td></tr>
<tr class="separator:aa148d677899a0da5ab14edfc5057a97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88081df8038d0b630d6a3540aeca8b9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88081df8038d0b630d6a3540aeca8b9a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88081df8038d0b630d6a3540aeca8b9a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a88081df8038d0b630d6a3540aeca8b9a">keycpp::ctranspose</a> (matrix&lt; T &gt; A)</td></tr>
<tr class="memdesc:a88081df8038d0b630d6a3540aeca8b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a88081df8038d0b630d6a3540aeca8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827218d19d98cf1357032a652a9bf4e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a827218d19d98cf1357032a652a9bf4e5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a827218d19d98cf1357032a652a9bf4e5"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a827218d19d98cf1357032a652a9bf4e5">keycpp::ctranspose</a> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="memdesc:a827218d19d98cf1357032a652a9bf4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of vector v1. <br/></td></tr>
<tr class="separator:a827218d19d98cf1357032a652a9bf4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aedb589e76ced5d79d62c5f72029adb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4aedb589e76ced5d79d62c5f72029adb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4aedb589e76ced5d79d62c5f72029adb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sum</b> (matrix&lt; T &gt; A)</td></tr>
<tr class="separator:a4aedb589e76ced5d79d62c5f72029adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad05b888638b5ea7103bdc6ba0882d47d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sum</b> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="separator:ad05b888638b5ea7103bdc6ba0882d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0e8201f775945a0a61d6d645a3456e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a0e8201f775945a0a61d6d645a3456e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a0e8201f775945a0a61d6d645a3456e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::mat2vec</b> (matrix&lt; T &gt; A)</td></tr>
<tr class="separator:a8a0e8201f775945a0a61d6d645a3456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d3ef9b10b3db438529bafc5e74fa0dc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::vec2mat</b> (std::vector&lt; T &gt; v1)</td></tr>
<tr class="separator:a4d3ef9b10b3db438529bafc5e74fa0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab57eee495c93eb18ebf8c8ccf4d44e74">keycpp::linspace</a> (const T x1, const T x2, const int N)</td></tr>
<tr class="memdesc:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values equally spaced between x1 and x2, inclusively.  <a href="#ab57eee495c93eb18ebf8c8ccf4d44e74">More...</a><br/></td></tr>
<tr class="separator:ab57eee495c93eb18ebf8c8ccf4d44e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92462e3b25414144d4e45fc269d2f13"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac92462e3b25414144d4e45fc269d2f13"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac92462e3b25414144d4e45fc269d2f13">keycpp::logspace</a> (const T x1, const T x2, int N)</td></tr>
<tr class="memdesc:ac92462e3b25414144d4e45fc269d2f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively.  <a href="#ac92462e3b25414144d4e45fc269d2f13">More...</a><br/></td></tr>
<tr class="separator:ac92462e3b25414144d4e45fc269d2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e350b4b11ea4d9962b4daa13cc66e32"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::unwrap</b> (const std::vector&lt; T &gt; &amp;v1, T tol=pi)</td></tr>
<tr class="separator:a4e350b4b11ea4d9962b4daa13cc66e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1acd03db6a49523cb5dbe751a80917a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::mean</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ad1acd03db6a49523cb5dbe751a80917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123211086c4953fe9346acc22b2a67f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a123211086c4953fe9346acc22b2a67f9"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a123211086c4953fe9346acc22b2a67f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, U x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a123211086c4953fe9346acc22b2a67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56633eb0878a0dbe6596fb0e74fdc6ea"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a56633eb0878a0dbe6596fb0e74fdc6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6dfc562f4ab516d21be63ab8a9c1b23"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, matrix&lt; T &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:ad6dfc562f4ab516d21be63ab8a9c1b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b44770c6a8c5ba4acb6fe6ead6cc811"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; std::vector&lt; T &gt; &gt; y, std::vector&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a3b44770c6a8c5ba4acb6fe6ead6cc811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ab894467bbea180c9b283895d5d5d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5ab894467bbea180c9b283895d5d5d3"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac5ab894467bbea180c9b283895d5d5d3"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, matrix&lt; U &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:ac5ab894467bbea180c9b283895d5d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c19f6ff8e0001eca5c63529bd58e664"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (std::vector&lt; U &gt; x, std::vector&lt; T &gt; y, std::vector&lt; std::vector&lt; U &gt; &gt; x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a4c19f6ff8e0001eca5c63529bd58e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad817c482d12509f0938849890bb4de4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad817c482d12509f0938849890bb4de4e"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:ad817c482d12509f0938849890bb4de4e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::trapz</b> (std::vector&lt; U &gt; eta, std::vector&lt; T &gt; integrand)</td></tr>
<tr class="separator:ad817c482d12509f0938849890bb4de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379324b1d1cb219fdde96c9678aa5341"><td class="memTemplParams" colspan="2"><a class="anchor" id="a379324b1d1cb219fdde96c9678aa5341"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a379324b1d1cb219fdde96c9678aa5341"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (matrix&lt; U &gt; eta, matrix&lt; T &gt; u, int index=2)</td></tr>
<tr class="separator:a379324b1d1cb219fdde96c9678aa5341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b09f118fe12b83865ff08fe3d3633ff"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (std::vector&lt; U &gt; eta, matrix&lt; T &gt; u)</td></tr>
<tr class="separator:a5b09f118fe12b83865ff08fe3d3633ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3bdbcb862d76b1b1fb5157788b7336ae"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (std::vector&lt; U &gt; eta, std::vector&lt; T &gt; u)</td></tr>
<tr class="separator:a3bdbcb862d76b1b1fb5157788b7336ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b17b3d224192fffc838834ff736d572"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b17b3d224192fffc838834ff736d572"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b17b3d224192fffc838834ff736d572"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::fft</b> (std::vector&lt; T &gt; u, int N=-1)</td></tr>
<tr class="separator:a6b17b3d224192fffc838834ff736d572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a880f7df231a78f912b3fb5d301c809f9"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::ode45</b> (F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:a880f7df231a78f912b3fb5d301c809f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6ae07fc18f5374868fe314f00108c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd6ae07fc18f5374868fe314f00108c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, double val)</td></tr>
<tr class="separator:afcd6ae07fc18f5374868fe314f00108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6862448bf6e09309e60a6ba7aa0caf9a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memTemplItemLeft" align="right" valign="top">Sort_Matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sort</b> (matrix&lt; T &gt; A, int dim=2, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a6862448bf6e09309e60a6ba7aa0caf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1be4e97b99a996a01f428fd8ba048fb0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memTemplItemLeft" align="right" valign="top">Sort_Vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sort</b> (std::vector&lt; T &gt; v1, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a1be4e97b99a996a01f428fd8ba048fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5236252f6a33f3523fb805a2d1727c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e5236252f6a33f3523fb805a2d1727c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; double &gt; A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a7e5236252f6a33f3523fb805a2d1727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b80bd145aab03a9e79a42d32ca573bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b80bd145aab03a9e79a42d32ca573bd"></a>
SVD_type&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4b80bd145aab03a9e79a42d32ca573bd">keycpp::svd</a> (matrix&lt; double &gt; A_in, std::string method)</td></tr>
<tr class="memdesc:a4b80bd145aab03a9e79a42d32ca573bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a4b80bd145aab03a9e79a42d32ca573bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ba604b4e72e41b123f890dd66d854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867ba604b4e72e41b123f890dd66d854"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a867ba604b4e72e41b123f890dd66d854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d15c3c38ff98e6d9afdd9db4b46c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d15c3c38ff98e6d9afdd9db4b46c6c"></a>
SVD_type&lt; std::complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::svd</b> (matrix&lt; std::complex&lt; double &gt;&gt; A_in, std::string method=&quot;&quot;)</td></tr>
<tr class="separator:aa6d15c3c38ff98e6d9afdd9db4b46c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 12 2013 16:05:43 for KeyCpp -- A MATLAB-like library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{
var pageTracker = _gat._getTracker("UA-42949208-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
