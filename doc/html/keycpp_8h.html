<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>KeyCpp -- A MATLAB-like library for C++: keycpp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KeyCpp -- A MATLAB-like library for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">keycpp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;iomanip&gt;</code><br/>
<code>#include &lt;complex&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;cmath&gt;</code><br/>
<code>#include &lt;boost/numeric/odeint.hpp&gt;</code><br/>
<code>#include &lt;utility&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &lt;ctime&gt;</code><br/>
<code>#include &lt;sys/time.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &quot;Matrix.h&quot;</code><br/>
<code>#include &quot;kiss_fft.h&quot;</code><br/>
<code>#include &quot;Spline.h&quot;</code><br/>
<code>#include &quot;Figure.h&quot;</code><br/>
</div>
<p><a href="keycpp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_key_cpp_exception.html">keycpp::KeyCppException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1observe.html">keycpp::observe&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___matrix.html">keycpp::Sort_Matrix&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___vector.html">keycpp::Sort_Vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1matrix__find__type.html">keycpp::matrix_find_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_s_v_d__type.html">keycpp::SVD_type&lt; T, X &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1tictoc__type.html">keycpp::tictoc_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for using the <a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e" title="Start the timer.">tic()</a> and toc(tictoc_type Timer) commands.  <a href="structkeycpp_1_1tictoc__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacekeycpp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html">keycpp</a></td></tr>
<tr class="memdesc:namespacekeycpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1daf785e3f68d293c7caa1c756d5cb74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1daf785e3f68d293c7caa1c756d5cb74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>pi</b>&#160;&#160;&#160;3.1415926535897932384626433832795</td></tr>
<tr class="separator:a1daf785e3f68d293c7caa1c756d5cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53328405fd9ba89990d9426d0e6389e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab53328405fd9ba89990d9426d0e6389e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>eps</b>&#160;&#160;&#160;std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="separator:ab53328405fd9ba89990d9426d0e6389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311d23688bfa914e83491178976adab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a311d23688bfa914e83491178976adab9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Inf</b>&#160;&#160;&#160;std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:a311d23688bfa914e83491178976adab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f667fb27fb68dd74a487d002b19b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953f667fb27fb68dd74a487d002b19b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NaN</b>&#160;&#160;&#160;nan(&quot;&quot;)</td></tr>
<tr class="separator:a953f667fb27fb68dd74a487d002b19b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace2501951ab3db3a91c3520ae89750b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2501951ab3db3a91c3520ae89750b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace2501951ab3db3a91c3520ae89750b1">keycpp::zggev_</a> (const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:ace2501951ab3db3a91c3520ae89750b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex generalized eigenvalue solver. <br/></td></tr>
<tr class="separator:ace2501951ab3db3a91c3520ae89750b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc5253e80ac15a9bfdc5449ae4f972a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aebc5253e80ac15a9bfdc5449ae4f972a">keycpp::dgeev_</a> (const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1cca2a162f40fc6c6218c35cadf9f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8c1cca2a162f40fc6c6218c35cadf9f2">keycpp::zgeev_</a> (const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3be6524e195662cbb74a810305e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3be6524e195662cbb74a810305e721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aca3be6524e195662cbb74a810305e721">keycpp::dgecon_</a> (const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</td></tr>
<tr class="memdesc:aca3be6524e195662cbb74a810305e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:aca3be6524e195662cbb74a810305e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e334ffaf1864d7191e9e0b64189783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e334ffaf1864d7191e9e0b64189783"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a75e334ffaf1864d7191e9e0b64189783">keycpp::dgetrf_</a> (const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:a75e334ffaf1864d7191e9e0b64189783"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU decomposition function. <br/></td></tr>
<tr class="separator:a75e334ffaf1864d7191e9e0b64189783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c33788a2c083aa5738eda1fe62a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c33788a2c083aa5738eda1fe62a261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab9c33788a2c083aa5738eda1fe62a261">keycpp::dgetrs_</a> (const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:ab9c33788a2c083aa5738eda1fe62a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU solver. <br/></td></tr>
<tr class="separator:ab9c33788a2c083aa5738eda1fe62a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507ef954be960fec70ca0f93258d730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4507ef954be960fec70ca0f93258d730"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4507ef954be960fec70ca0f93258d730">keycpp::dlange_</a> (const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a4507ef954be960fec70ca0f93258d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision norm function. <br/></td></tr>
<tr class="separator:a4507ef954be960fec70ca0f93258d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e3cdc7e7929414370b6b50ea1218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444e3cdc7e7929414370b6b50ea1218c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a444e3cdc7e7929414370b6b50ea1218c">keycpp::zgecon_</a> (const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</td></tr>
<tr class="memdesc:a444e3cdc7e7929414370b6b50ea1218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex-valued reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:a444e3cdc7e7929414370b6b50ea1218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18d58d53d8e19a37d74d24da27a64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18d58d53d8e19a37d74d24da27a64dd">keycpp::zgetrf_</a> (const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:ab18d58d53d8e19a37d74d24da27a64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU decomposition function. <br/></td></tr>
<tr class="separator:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4322276dcdb7d864e85854b5b90f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe4322276dcdb7d864e85854b5b90f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abbe4322276dcdb7d864e85854b5b90f2">keycpp::zgetrs_</a> (const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:abbe4322276dcdb7d864e85854b5b90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU solver. <br/></td></tr>
<tr class="separator:abbe4322276dcdb7d864e85854b5b90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477c910b07baef984fe8528c29b2774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1477c910b07baef984fe8528c29b2774"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1477c910b07baef984fe8528c29b2774">keycpp::zlange_</a> (const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a1477c910b07baef984fe8528c29b2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex norm function. <br/></td></tr>
<tr class="separator:a1477c910b07baef984fe8528c29b2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12719f4b48de048f9642066666a920bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12719f4b48de048f9642066666a920bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a12719f4b48de048f9642066666a920bd">keycpp::dgesv_</a> (const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</td></tr>
<tr class="memdesc:a12719f4b48de048f9642066666a920bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision linear system solver. <br/></td></tr>
<tr class="separator:a12719f4b48de048f9642066666a920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0d887ae48cc4222f7167232a7f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92d0d887ae48cc4222f7167232a7f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af92d0d887ae48cc4222f7167232a7f82">keycpp::dgetri_</a> (const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:af92d0d887ae48cc4222f7167232a7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision matrix inverse function. <br/></td></tr>
<tr class="separator:af92d0d887ae48cc4222f7167232a7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190e125fe33133aafa586089ca6e174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4190e125fe33133aafa586089ca6e174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4190e125fe33133aafa586089ca6e174">keycpp::zgetri_</a> (const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a4190e125fe33133aafa586089ca6e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex matrix inverse function. <br/></td></tr>
<tr class="separator:a4190e125fe33133aafa586089ca6e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7a71afbb6c5dc049cdd7afff6c0af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8fe7a71afbb6c5dc049cdd7afff6c0af">keycpp::dgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision SVD function. <br/></td></tr>
<tr class="separator:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5e2f74110f53bd288c15ce1f183f9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afa5e2f74110f53bd288c15ce1f183f9b">keycpp::zgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:afa5e2f74110f53bd288c15ce1f183f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex SVD function. <br/></td></tr>
<tr class="separator:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61795f58aa135cfa0ebb4325f52f9de6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61795f58aa135cfa0ebb4325f52f9de6"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::eig</b> (const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, const matrix&lt; std::complex&lt; double &gt; &gt; &amp;B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</td></tr>
<tr class="separator:a61795f58aa135cfa0ebb4325f52f9de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262bb0ca13c9c1e11732b9b1dab65c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4262bb0ca13c9c1e11732b9b1dab65c6"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::eig</b> (const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return=NULL)</td></tr>
<tr class="separator:a4262bb0ca13c9c1e11732b9b1dab65c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e462b40dbbb92e5ebef12956d76e1f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e462b40dbbb92e5ebef12956d76e1f8"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::eig</b> (const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</td></tr>
<tr class="separator:a9e462b40dbbb92e5ebef12956d76e1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3905cfc35dbd146f5dbf7bcb5729c2c2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; double &gt; &amp;A)</td></tr>
<tr class="separator:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d9a9dd04453e5a417f7a9eb8ae4391b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f68b3d9143ad3582e59dd0a4b1998b8"></a>
std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:a9f68b3d9143ad3582e59dd0a4b1998b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f4a25648e5bad1cf0bd0e7fca7fae0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; double &gt; &amp;A_in, const std::vector&lt; double &gt; &amp;b_in)</td></tr>
<tr class="separator:a46f4a25648e5bad1cf0bd0e7fca7fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96927cda2df7a6e8e2031941c43601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96927cda2df7a6e8e2031941c43601"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:adc96927cda2df7a6e8e2031941c43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b74369f5415c3ed45f63995149ad992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b74369f5415c3ed45f63995149ad992"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a6b74369f5415c3ed45f63995149ad992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef5c1f5951e8182a7c4ec9612f3f7e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5ef5c1f5951e8182a7c4ec9612f3f7e1">keycpp::rand</a> ()</td></tr>
<tr class="memdesc:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double between 0 and 1.0. <br/></td></tr>
<tr class="separator:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c6c79ad914131dfc2b0ae22c6d5017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c6c79ad914131dfc2b0ae22c6d5017"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae5c6c79ad914131dfc2b0ae22c6d5017">keycpp::rand</a> (const int &amp;N)</td></tr>
<tr class="memdesc:ae5c6c79ad914131dfc2b0ae22c6d5017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an N x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:ae5c6c79ad914131dfc2b0ae22c6d5017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259b4e27cc4ec4d79d27688fdafcf2ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a259b4e27cc4ec4d79d27688fdafcf2ca"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a259b4e27cc4ec4d79d27688fdafcf2ca">keycpp::rand</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a259b4e27cc4ec4d79d27688fdafcf2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an M x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:a259b4e27cc4ec4d79d27688fdafcf2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae90693acdaf666bd23bf861f2c0d28c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae90693acdaf666bd23bf861f2c0d28c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aae90693acdaf666bd23bf861f2c0d28c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; T &gt; &amp;A, T(*f)(const T &amp;))</td></tr>
<tr class="separator:aae90693acdaf666bd23bf861f2c0d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1122e5d4ae4b58fc150352b5d38d2cdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1122e5d4ae4b58fc150352b5d38d2cdb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1122e5d4ae4b58fc150352b5d38d2cdb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const std::vector&lt; T &gt; &amp;v1, T(*f)(const T &amp;))</td></tr>
<tr class="separator:a1122e5d4ae4b58fc150352b5d38d2cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ba458353cfecef659b40e446baaf0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a1ba458353cfecef659b40e446baaf0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3a1ba458353cfecef659b40e446baaf0"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; T &gt; &amp;A, T(*f)(T))</td></tr>
<tr class="separator:a3a1ba458353cfecef659b40e446baaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9f15708903bc3f2c6d26693b8872d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7d9f15708903bc3f2c6d26693b8872d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7d9f15708903bc3f2c6d26693b8872d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const std::vector&lt; T &gt; &amp;v1, T(*f)(T))</td></tr>
<tr class="separator:ad7d9f15708903bc3f2c6d26693b8872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afc215befa38bf47fb52cff33794ebe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5afc215befa38bf47fb52cff33794ebe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5afc215befa38bf47fb52cff33794ebe"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</td></tr>
<tr class="separator:a5afc215befa38bf47fb52cff33794ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33e9ccd4e31c7c63d31af13d44312e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad33e9ccd4e31c7c63d31af13d44312e8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad33e9ccd4e31c7c63d31af13d44312e8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(const std::complex&lt; T &gt; &amp;))</td></tr>
<tr class="separator:ad33e9ccd4e31c7c63d31af13d44312e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14b016d01024e738c3110299ee58666"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae14b016d01024e738c3110299ee58666"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae14b016d01024e738c3110299ee58666"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</td></tr>
<tr class="separator:ae14b016d01024e738c3110299ee58666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22b23749bd8423cf52448a34280ba4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f22b23749bd8423cf52448a34280ba4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f22b23749bd8423cf52448a34280ba4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1, T(*f)(std::complex&lt; T &gt;))</td></tr>
<tr class="separator:a7f22b23749bd8423cf52448a34280ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e8bada51586c0561e1b32ca1ab5f2a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator&lt;&lt;</b> (std::ostream &amp;out, const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a55e8bada51586c0561e1b32ca1ab5f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplParams" colspan="2"><a class="anchor" id="a300d8f6e8992c7b33156492d884bd621"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a300d8f6e8992c7b33156492d884bd621"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator&lt;&lt;</b> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a300d8f6e8992c7b33156492d884bd621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5823fd4b932039262a1eddb2f4f47299"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5823fd4b932039262a1eddb2f4f47299"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5823fd4b932039262a1eddb2f4f47299"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5823fd4b932039262a1eddb2f4f47299">keycpp::prod</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a5823fd4b932039262a1eddb2f4f47299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements of the vector x. <br/></td></tr>
<tr class="separator:a5823fd4b932039262a1eddb2f4f47299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff26fd7007c28ea88b3ad7cdf90546c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ff26fd7007c28ea88b3ad7cdf90546c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9ff26fd7007c28ea88b3ad7cdf90546c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9ff26fd7007c28ea88b3ad7cdf90546c">keycpp::prod</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9ff26fd7007c28ea88b3ad7cdf90546c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the product of all the elements in each column of the matrix A. <br/></td></tr>
<tr class="separator:a9ff26fd7007c28ea88b3ad7cdf90546c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67644e3e1031773d6bfdb1ebb7d88e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae67644e3e1031773d6bfdb1ebb7d88e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae67644e3e1031773d6bfdb1ebb7d88e2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae67644e3e1031773d6bfdb1ebb7d88e2">keycpp::diff</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ae67644e3e1031773d6bfdb1ebb7d88e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of differences between adjacent elements. <br/></td></tr>
<tr class="separator:ae67644e3e1031773d6bfdb1ebb7d88e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abb4e57814fd30b7b8d4845bbc16c73e9">keycpp::diff</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of row differences between adjacent rows.  <a href="#abb4e57814fd30b7b8d4845bbc16c73e9">More...</a><br/></td></tr>
<tr class="separator:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e92e1abe266ccc6735d443c228a97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c2e92e1abe266ccc6735d443c228a97"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c2e92e1abe266ccc6735d443c228a97"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::conj</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a4c2e92e1abe266ccc6735d443c228a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f000b392fbefccdb089383bb6a20151"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f000b392fbefccdb089383bb6a20151"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0f000b392fbefccdb089383bb6a20151"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::conj</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a0f000b392fbefccdb089383bb6a20151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ed5914a3c4b05e1e137fc9735e3ed5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa6ed5914a3c4b05e1e137fc9735e3ed5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa6ed5914a3c4b05e1e137fc9735e3ed5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::real</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:aa6ed5914a3c4b05e1e137fc9735e3ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61efb014b42cd8b02a81b4520c41ab2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61efb014b42cd8b02a81b4520c41ab2c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a61efb014b42cd8b02a81b4520c41ab2c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::real</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a61efb014b42cd8b02a81b4520c41ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a0afaf26071f5f60ff1c11a2f9a2a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af7a0afaf26071f5f60ff1c11a2f9a2a9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af7a0afaf26071f5f60ff1c11a2f9a2a9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::imag</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:af7a0afaf26071f5f60ff1c11a2f9a2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902a14fdaa4b744a8a11220f5be0161"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad902a14fdaa4b744a8a11220f5be0161"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad902a14fdaa4b744a8a11220f5be0161"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::imag</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="separator:ad902a14fdaa4b744a8a11220f5be0161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02a8494963dd9566a978221434d9366"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab02a8494963dd9566a978221434d9366"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab02a8494963dd9566a978221434d9366"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ab02a8494963dd9566a978221434d9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce9304ff511ac2e50ad3016045f22f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="acce9304ff511ac2e50ad3016045f22f6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acce9304ff511ac2e50ad3016045f22f6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:acce9304ff511ac2e50ad3016045f22f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f83b48bfedf753904dfea9dde554a4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f83b48bfedf753904dfea9dde554a4c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f83b48bfedf753904dfea9dde554a4c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a1f83b48bfedf753904dfea9dde554a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0edec63f48a81c576da0c0ffc768af9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae0edec63f48a81c576da0c0ffc768af9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0edec63f48a81c576da0c0ffc768af9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="separator:ae0edec63f48a81c576da0c0ffc768af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e5296774667c3be4e792b5cd980da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952e5296774667c3be4e792b5cd980da"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::csqrt</b> (const double &amp;a)</td></tr>
<tr class="separator:a952e5296774667c3be4e792b5cd980da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4da6882977b2262f8d6f080b0eaf60c5"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:a4da6882977b2262f8d6f080b0eaf60c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1cd804c6f704b7a9124a9d9a82c325"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c1cd804c6f704b7a9124a9d9a82c325"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1c1cd804c6f704b7a9124a9d9a82c325"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a1c1cd804c6f704b7a9124a9d9a82c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4df2f7feaefed6813ecfe11e37087ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad4df2f7feaefed6813ecfe11e37087ab"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad4df2f7feaefed6813ecfe11e37087ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const U &amp;a, const std::vector&lt; T &gt; &amp;v2)</td></tr>
<tr class="separator:ad4df2f7feaefed6813ecfe11e37087ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff86e062c6497110b7505b0ef715c2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="adff86e062c6497110b7505b0ef715c2c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adff86e062c6497110b7505b0ef715c2c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const matrix&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:adff86e062c6497110b7505b0ef715c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b4a64905c9d681c174b2dfcfba272c4"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const U &amp;a, const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a4b4a64905c9d681c174b2dfcfba272c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a177fcb4f0ec1f260fdb39069fc29"><td class="memTemplParams" colspan="2"><a class="anchor" id="af66a177fcb4f0ec1f260fdb39069fc29"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af66a177fcb4f0ec1f260fdb39069fc29"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:af66a177fcb4f0ec1f260fdb39069fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99d5b9548a160a11ed713b85038871"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a99d5b9548a160a11ed713b85038871"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9a99d5b9548a160a11ed713b85038871"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const U &amp;a, const std::vector&lt; T &gt; &amp;v2)</td></tr>
<tr class="separator:a9a99d5b9548a160a11ed713b85038871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a8f2ebc458f06e29b17ecc28ed000d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71a8f2ebc458f06e29b17ecc28ed000d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a71a8f2ebc458f06e29b17ecc28ed000d"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const matrix&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:a71a8f2ebc458f06e29b17ecc28ed000d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc853f9410d964ef9f163ce53ea4828"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bc853f9410d964ef9f163ce53ea4828"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4bc853f9410d964ef9f163ce53ea4828"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const U &amp;a, const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a4bc853f9410d964ef9f163ce53ea4828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185edce957f4afd65cb641ec6307376"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab185edce957f4afd65cb641ec6307376"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab185edce957f4afd65cb641ec6307376"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="separator:ab185edce957f4afd65cb641ec6307376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d5dbf37b71d16d686dd0fdbad82f8fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const T &amp;a, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a8d5dbf37b71d16d686dd0fdbad82f8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae187563f8f86e256bc1394edcba1b2b1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae187563f8f86e256bc1394edcba1b2b1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const matrix&lt; U &gt; &amp;A, const T &amp;a)</td></tr>
<tr class="separator:ae187563f8f86e256bc1394edcba1b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6dcf10b0db68d53d126803e8d6d591fb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const std::vector&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="separator:a6dcf10b0db68d53d126803e8d6d591fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b523ff3dd5abac240788f6efb2e554e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4b523ff3dd5abac240788f6efb2e554e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const T &amp;a, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="separator:a4b523ff3dd5abac240788f6efb2e554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2e9a06b12f7df18005a3daa3c051b2c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator*</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:aa2e9a06b12f7df18005a3daa3c051b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2665554c04ea23aad98e77d1618ca6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2665554c04ea23aad98e77d1618ca6b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:ac2665554c04ea23aad98e77d1618ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a390125160a7febd08d5c30629f4f698f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a390125160a7febd08d5c30629f4f698f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator-</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a390125160a7febd08d5c30629f4f698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825f94b7be431bab5e5c99f8d7a1b54"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7825f94b7be431bab5e5c99f8d7a1b54"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7825f94b7be431bab5e5c99f8d7a1b54"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a7825f94b7be431bab5e5c99f8d7a1b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b10f703c72875b9f5e2ecc5c7696f9c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator+</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a5b10f703c72875b9f5e2ecc5c7696f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3852c35cfcc8caa784465a26d04c68a1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3852c35cfcc8caa784465a26d04c68a1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const matrix&lt; T &gt; &amp;A, const U &amp;a)</td></tr>
<tr class="separator:a3852c35cfcc8caa784465a26d04c68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a394f23f09cf122a8e8c20a7afd40f58e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const std::vector&lt; T &gt; &amp;v1, const U &amp;a)</td></tr>
<tr class="separator:a394f23f09cf122a8e8c20a7afd40f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc0089bdf204385c1e627755c5070b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafc0089bdf204385c1e627755c5070b0"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aafc0089bdf204385c1e627755c5070b0"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const U &amp;a, const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:aafc0089bdf204385c1e627755c5070b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d18510a87d417d5c38f24ded26a8cee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d18510a87d417d5c38f24ded26a8cee"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4d18510a87d417d5c38f24ded26a8cee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator/</b> (const U &amp;a, const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a4d18510a87d417d5c38f24ded26a8cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3f3c9d269e14b23609d754684cdcf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60d3f3c9d269e14b23609d754684cdcf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a60d3f3c9d269e14b23609d754684cdcf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a60d3f3c9d269e14b23609d754684cdcf">keycpp::sin</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a60d3f3c9d269e14b23609d754684cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:a60d3f3c9d269e14b23609d754684cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56636d37802b9237f0e09690307cacef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56636d37802b9237f0e09690307cacef"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a56636d37802b9237f0e09690307cacef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a56636d37802b9237f0e09690307cacef">keycpp::sin</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a56636d37802b9237f0e09690307cacef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of v1. <br/></td></tr>
<tr class="separator:a56636d37802b9237f0e09690307cacef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d66a7287374d8e1e685538e0363101e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d66a7287374d8e1e685538e0363101e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7d66a7287374d8e1e685538e0363101e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7d66a7287374d8e1e685538e0363101e">keycpp::sin</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a7d66a7287374d8e1e685538e0363101e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a7d66a7287374d8e1e685538e0363101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd3aac5066a4d3e2c7108b26c554605"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0dd3aac5066a4d3e2c7108b26c554605"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0dd3aac5066a4d3e2c7108b26c554605"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0dd3aac5066a4d3e2c7108b26c554605">keycpp::sin</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a0dd3aac5066a4d3e2c7108b26c554605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a0dd3aac5066a4d3e2c7108b26c554605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d958e47ae678b0818a166d5a75883"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b3d958e47ae678b0818a166d5a75883"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9b3d958e47ae678b0818a166d5a75883"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9b3d958e47ae678b0818a166d5a75883">keycpp::cos</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a9b3d958e47ae678b0818a166d5a75883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:a9b3d958e47ae678b0818a166d5a75883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d6592d124735f2377e1a2c43985b94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51d6592d124735f2377e1a2c43985b94"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a51d6592d124735f2377e1a2c43985b94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a51d6592d124735f2377e1a2c43985b94">keycpp::cos</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a51d6592d124735f2377e1a2c43985b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of v1. <br/></td></tr>
<tr class="separator:a51d6592d124735f2377e1a2c43985b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8f8e6c241ddcb678acf54c03a89b08"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b8f8e6c241ddcb678acf54c03a89b08"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b8f8e6c241ddcb678acf54c03a89b08"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6b8f8e6c241ddcb678acf54c03a89b08">keycpp::cos</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a6b8f8e6c241ddcb678acf54c03a89b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of A. <br/></td></tr>
<tr class="separator:a6b8f8e6c241ddcb678acf54c03a89b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc28105b536bc99365073d7cbe0f9910"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc28105b536bc99365073d7cbe0f9910"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abc28105b536bc99365073d7cbe0f9910"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abc28105b536bc99365073d7cbe0f9910">keycpp::cos</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abc28105b536bc99365073d7cbe0f9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cos of each element of A. <br/></td></tr>
<tr class="separator:abc28105b536bc99365073d7cbe0f9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb76498765f30f7a95c80ce7491d28"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fbb76498765f30f7a95c80ce7491d28"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1fbb76498765f30f7a95c80ce7491d28"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1fbb76498765f30f7a95c80ce7491d28">keycpp::tan</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a1fbb76498765f30f7a95c80ce7491d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of v1. <br/></td></tr>
<tr class="separator:a1fbb76498765f30f7a95c80ce7491d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fe8a3edd9841d208cc044f79d48ae2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4fe8a3edd9841d208cc044f79d48ae2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae4fe8a3edd9841d208cc044f79d48ae2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae4fe8a3edd9841d208cc044f79d48ae2">keycpp::tan</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ae4fe8a3edd9841d208cc044f79d48ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of v1. <br/></td></tr>
<tr class="separator:ae4fe8a3edd9841d208cc044f79d48ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a91266a8d14f0ae2de1d3e098d05e41"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a91266a8d14f0ae2de1d3e098d05e41"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a91266a8d14f0ae2de1d3e098d05e41"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6a91266a8d14f0ae2de1d3e098d05e41">keycpp::tan</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a6a91266a8d14f0ae2de1d3e098d05e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:a6a91266a8d14f0ae2de1d3e098d05e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf9e0ed2f49b902c93be19ea6ef147"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8cf9e0ed2f49b902c93be19ea6ef147"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa8cf9e0ed2f49b902c93be19ea6ef147"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa8cf9e0ed2f49b902c93be19ea6ef147">keycpp::tan</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa8cf9e0ed2f49b902c93be19ea6ef147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:aa8cf9e0ed2f49b902c93be19ea6ef147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ce29f6b9a95792764fcffc175ffc2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8ce29f6b9a95792764fcffc175ffc2a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8ce29f6b9a95792764fcffc175ffc2a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae8ce29f6b9a95792764fcffc175ffc2a">keycpp::cosh</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:ae8ce29f6b9a95792764fcffc175ffc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the hyperbolic cosine of each element of v1. <br/></td></tr>
<tr class="separator:ae8ce29f6b9a95792764fcffc175ffc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b4df07d8fb2beb7f8b63408345caf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a227b4df07d8fb2beb7f8b63408345caf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a227b4df07d8fb2beb7f8b63408345caf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a227b4df07d8fb2beb7f8b63408345caf">keycpp::cosh</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a227b4df07d8fb2beb7f8b63408345caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the hyperbolic cosine of each element of v1. <br/></td></tr>
<tr class="separator:a227b4df07d8fb2beb7f8b63408345caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50caa1bee883d40591442882e777a67b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a50caa1bee883d40591442882e777a67b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a50caa1bee883d40591442882e777a67b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a50caa1bee883d40591442882e777a67b">keycpp::exp</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a50caa1bee883d40591442882e777a67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:a50caa1bee883d40591442882e777a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a68550626786b480e7c8d02aaf9039"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66a68550626786b480e7c8d02aaf9039"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a66a68550626786b480e7c8d02aaf9039"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a66a68550626786b480e7c8d02aaf9039">keycpp::exp</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a66a68550626786b480e7c8d02aaf9039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of v1. <br/></td></tr>
<tr class="separator:a66a68550626786b480e7c8d02aaf9039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8bd2143a6d613b560f71d0b99b346f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a8bd2143a6d613b560f71d0b99b346f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a8bd2143a6d613b560f71d0b99b346f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6a8bd2143a6d613b560f71d0b99b346f">keycpp::exp</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a6a8bd2143a6d613b560f71d0b99b346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a6a8bd2143a6d613b560f71d0b99b346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc8180fd2f17512f0f75957615da294"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6cc8180fd2f17512f0f75957615da294"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6cc8180fd2f17512f0f75957615da294"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6cc8180fd2f17512f0f75957615da294">keycpp::exp</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6cc8180fd2f17512f0f75957615da294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a6cc8180fd2f17512f0f75957615da294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95843ef0a09d799d8b62eb7b91e9c02f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95843ef0a09d799d8b62eb7b91e9c02f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a95843ef0a09d799d8b62eb7b91e9c02f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a95843ef0a09d799d8b62eb7b91e9c02f">keycpp::log</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a95843ef0a09d799d8b62eb7b91e9c02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a95843ef0a09d799d8b62eb7b91e9c02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8239f43008337eeab762bc1c7414e735"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8239f43008337eeab762bc1c7414e735"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8239f43008337eeab762bc1c7414e735"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8239f43008337eeab762bc1c7414e735">keycpp::log</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a8239f43008337eeab762bc1c7414e735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a8239f43008337eeab762bc1c7414e735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba78d97ea38234b858fffc97b05e6925"><td class="memTemplParams" colspan="2"><a class="anchor" id="aba78d97ea38234b858fffc97b05e6925"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aba78d97ea38234b858fffc97b05e6925"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aba78d97ea38234b858fffc97b05e6925">keycpp::log</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:aba78d97ea38234b858fffc97b05e6925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:aba78d97ea38234b858fffc97b05e6925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c65fb4ee4ceaf869361f4fb6fef3dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1c65fb4ee4ceaf869361f4fb6fef3dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab1c65fb4ee4ceaf869361f4fb6fef3dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab1c65fb4ee4ceaf869361f4fb6fef3dd">keycpp::log</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab1c65fb4ee4ceaf869361f4fb6fef3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:ab1c65fb4ee4ceaf869361f4fb6fef3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb93c1aed2037f957fa113994d7239ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb93c1aed2037f957fa113994d7239ee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb93c1aed2037f957fa113994d7239ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afb93c1aed2037f957fa113994d7239ee">keycpp::log10</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:afb93c1aed2037f957fa113994d7239ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of v1. <br/></td></tr>
<tr class="separator:afb93c1aed2037f957fa113994d7239ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3042ac961c7bffb3c315f41f175c5760"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3042ac961c7bffb3c315f41f175c5760"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3042ac961c7bffb3c315f41f175c5760"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3042ac961c7bffb3c315f41f175c5760">keycpp::log10</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a3042ac961c7bffb3c315f41f175c5760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of v1. <br/></td></tr>
<tr class="separator:a3042ac961c7bffb3c315f41f175c5760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea3b5f6f548e122d29e4571e15307fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ea3b5f6f548e122d29e4571e15307fd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ea3b5f6f548e122d29e4571e15307fd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3ea3b5f6f548e122d29e4571e15307fd">keycpp::log10</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a3ea3b5f6f548e122d29e4571e15307fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:a3ea3b5f6f548e122d29e4571e15307fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6529b56bdc13937f058879d0f5881d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b6529b56bdc13937f058879d0f5881d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b6529b56bdc13937f058879d0f5881d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1b6529b56bdc13937f058879d0f5881d">keycpp::log10</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a1b6529b56bdc13937f058879d0f5881d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:a1b6529b56bdc13937f058879d0f5881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d916a516c57aad0e383ce29a50b963"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24d916a516c57aad0e383ce29a50b963"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24d916a516c57aad0e383ce29a50b963"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a24d916a516c57aad0e383ce29a50b963">keycpp::sqrt</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a24d916a516c57aad0e383ce29a50b963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of v1. <br/></td></tr>
<tr class="separator:a24d916a516c57aad0e383ce29a50b963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8677ad8b7dc8485540330a632cb82994"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8677ad8b7dc8485540330a632cb82994"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8677ad8b7dc8485540330a632cb82994"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8677ad8b7dc8485540330a632cb82994">keycpp::sqrt</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a8677ad8b7dc8485540330a632cb82994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of v1. <br/></td></tr>
<tr class="separator:a8677ad8b7dc8485540330a632cb82994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2955a17019e584c29d9cce73ea572adc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2955a17019e584c29d9cce73ea572adc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2955a17019e584c29d9cce73ea572adc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2955a17019e584c29d9cce73ea572adc">keycpp::sqrt</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a2955a17019e584c29d9cce73ea572adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:a2955a17019e584c29d9cce73ea572adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab542118d6ab4772a4f100df097f7d55d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab542118d6ab4772a4f100df097f7d55d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab542118d6ab4772a4f100df097f7d55d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab542118d6ab4772a4f100df097f7d55d">keycpp::sqrt</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab542118d6ab4772a4f100df097f7d55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:ab542118d6ab4772a4f100df097f7d55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9303ca44f49ec926854e6ad9506050"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e9303ca44f49ec926854e6ad9506050"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e9303ca44f49ec926854e6ad9506050"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9e9303ca44f49ec926854e6ad9506050">keycpp::csqrt</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="memdesc:a9e9303ca44f49ec926854e6ad9506050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of v1. <br/></td></tr>
<tr class="separator:a9e9303ca44f49ec926854e6ad9506050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c724d2e4067f9ae5fd3098da74bf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e6c724d2e4067f9ae5fd3098da74bf6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e6c724d2e4067f9ae5fd3098da74bf6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1e6c724d2e4067f9ae5fd3098da74bf6">keycpp::csqrt</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a1e6c724d2e4067f9ae5fd3098da74bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of v1. <br/></td></tr>
<tr class="separator:a1e6c724d2e4067f9ae5fd3098da74bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce9f002c4f3db2000a5c8d3a38f3ca5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ce9f002c4f3db2000a5c8d3a38f3ca5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ce9f002c4f3db2000a5c8d3a38f3ca5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4ce9f002c4f3db2000a5c8d3a38f3ca5">keycpp::csqrt</a> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a4ce9f002c4f3db2000a5c8d3a38f3ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:a4ce9f002c4f3db2000a5c8d3a38f3ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f54061aba34fe730de8c35d68f9fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe9f54061aba34fe730de8c35d68f9fe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abe9f54061aba34fe730de8c35d68f9fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abe9f54061aba34fe730de8c35d68f9fe">keycpp::csqrt</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abe9f54061aba34fe730de8c35d68f9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:abe9f54061aba34fe730de8c35d68f9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ae33fb19a521ab1ec1f22e7c39ca076"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eye</b> (const int &amp;N)</td></tr>
<tr class="separator:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824156817719ffe96a842dd0ef27ae5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2824156817719ffe96a842dd0ef27ae5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2824156817719ffe96a842dd0ef27ae5">keycpp::size</a> (const matrix&lt; T &gt; &amp;A, const int &amp;dim)</td></tr>
<tr class="memdesc:a2824156817719ffe96a842dd0ef27ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements along dimension dim.  <a href="#a2824156817719ffe96a842dd0ef27ae5">More...</a><br/></td></tr>
<tr class="separator:a2824156817719ffe96a842dd0ef27ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae713df143a5e71da166f450e01a536e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae713df143a5e71da166f450e01a536e2"><td class="memTemplItemLeft" align="right" valign="top">matrix_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae713df143a5e71da166f450e01a536e2">keycpp::size</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ae713df143a5e71da166f450e01a536e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of matrix A.  <a href="#ae713df143a5e71da166f450e01a536e2">More...</a><br/></td></tr>
<tr class="separator:ae713df143a5e71da166f450e01a536e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5699c522088657287bf0ac01173b716c">keycpp::zeros</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a5699c522088657287bf0ac01173b716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all zeros.  <a href="#a5699c522088657287bf0ac01173b716c">More...</a><br/></td></tr>
<tr class="separator:a5699c522088657287bf0ac01173b716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f013931cb9989320b014d151cc527"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a0f013931cb9989320b014d151cc527"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9a0f013931cb9989320b014d151cc527">keycpp::zeros</a> (const int &amp;N)</td></tr>
<tr class="memdesc:a9a0f013931cb9989320b014d151cc527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of length N containing all zeros.  <a href="#a9a0f013931cb9989320b014d151cc527">More...</a><br/></td></tr>
<tr class="separator:a9a0f013931cb9989320b014d151cc527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a388f91a0ccf34978ef9403ccd0c680bf">keycpp::ones</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a388f91a0ccf34978ef9403ccd0c680bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all ones.  <a href="#a388f91a0ccf34978ef9403ccd0c680bf">More...</a><br/></td></tr>
<tr class="separator:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e69a9395f6dfe9e02af46e8b4273b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a831e69a9395f6dfe9e02af46e8b4273b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a831e69a9395f6dfe9e02af46e8b4273b">keycpp::ones</a> (const int &amp;N)</td></tr>
<tr class="memdesc:a831e69a9395f6dfe9e02af46e8b4273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of length N containing all ones.  <a href="#a831e69a9395f6dfe9e02af46e8b4273b">More...</a><br/></td></tr>
<tr class="separator:a831e69a9395f6dfe9e02af46e8b4273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bb3ea9a842383b82c889179f25be9ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</td></tr>
<tr class="separator:a4bb3ea9a842383b82c889179f25be9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400213b20d0dc5e0b31b1bf49f191f11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a400213b20d0dc5e0b31b1bf49f191f11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a400213b20d0dc5e0b31b1bf49f191f11"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const std::vector&lt; T &gt; &amp;v1, const int &amp;d=0)</td></tr>
<tr class="separator:a400213b20d0dc5e0b31b1bf49f191f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8468ea36d1466ddeda8c64b9f46f8dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac8468ea36d1466ddeda8c64b9f46f8dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac8468ea36d1466ddeda8c64b9f46f8dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const matrix&lt; T &gt; &amp;A, const int &amp;d=0)</td></tr>
<tr class="separator:ac8468ea36d1466ddeda8c64b9f46f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56165975dd12a86b498134da71bde29"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab56165975dd12a86b498134da71bde29"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab56165975dd12a86b498134da71bde29"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::repmat</b> (const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:ab56165975dd12a86b498134da71bde29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a41247c257a0244dd45c849a0ec3d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7a41247c257a0244dd45c849a0ec3d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab7a41247c257a0244dd45c849a0ec3d1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::repmat</b> (const std::vector&lt; T &gt; v1, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:ab7a41247c257a0244dd45c849a0ec3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac1ff99e34619478096c271b38df1f3d7"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac1ff99e34619478096c271b38df1f3d7">keycpp::times</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:ac1ff99e34619478096c271b38df1f3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on matrices A and B.  <a href="#ac1ff99e34619478096c271b38df1f3d7">More...</a><br/></td></tr>
<tr class="separator:ac1ff99e34619478096c271b38df1f3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a90d5fd4f9f7c52f16425105995655e9d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a90d5fd4f9f7c52f16425105995655e9d">keycpp::times</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a90d5fd4f9f7c52f16425105995655e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on vectors v1 and v2.  <a href="#a90d5fd4f9f7c52f16425105995655e9d">More...</a><br/></td></tr>
<tr class="separator:a90d5fd4f9f7c52f16425105995655e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aacd37d195541b2313b753b6e8839f916"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aacd37d195541b2313b753b6e8839f916">keycpp::rdivide</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B)</td></tr>
<tr class="memdesc:aacd37d195541b2313b753b6e8839f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on matrices A and B.  <a href="#aacd37d195541b2313b753b6e8839f916">More...</a><br/></td></tr>
<tr class="separator:aacd37d195541b2313b753b6e8839f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af234cd07a4e1d649629a6b83dbe113ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af234cd07a4e1d649629a6b83dbe113ff">keycpp::rdivide</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:af234cd07a4e1d649629a6b83dbe113ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on vectors v1 and v2.  <a href="#af234cd07a4e1d649629a6b83dbe113ff">More...</a><br/></td></tr>
<tr class="separator:af234cd07a4e1d649629a6b83dbe113ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac57d32902cba2c399475015235aeccec">keycpp::ldivide</a> (const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="memdesc:ac57d32902cba2c399475015235aeccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on matrices B and A.  <a href="#ac57d32902cba2c399475015235aeccec">More...</a><br/></td></tr>
<tr class="separator:ac57d32902cba2c399475015235aeccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7a86bc7e25833cdf9266c038a4edb0ea">keycpp::ldivide</a> (const std::vector&lt; T &gt; &amp;v2, const std::vector&lt; U &gt; &amp;v1)</td></tr>
<tr class="memdesc:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on vectors v2 and v1.  <a href="#a7a86bc7e25833cdf9266c038a4edb0ea">More...</a><br/></td></tr>
<tr class="separator:a7a86bc7e25833cdf9266c038a4edb0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplParams" colspan="2"><a class="anchor" id="a87f2917e6a7c8e20d010aea0d8480668"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sign</b> (const T &amp;val)</td></tr>
<tr class="separator:a87f2917e6a7c8e20d010aea0d8480668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa2e17334911e8a447a5ef6c0cc54c3f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (const std::complex&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed8b7c5c058bda28186010d2f3833f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9aed8b7c5c058bda28186010d2f3833f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9aed8b7c5c058bda28186010d2f3833f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v1)</td></tr>
<tr class="separator:a9aed8b7c5c058bda28186010d2f3833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c9c769d613f7526406ecf3b3351d89"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0c9c769d613f7526406ecf3b3351d89"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af0c9c769d613f7526406ecf3b3351d89"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (const matrix&lt; std::complex&lt; T &gt;&gt; &amp;A)</td></tr>
<tr class="separator:af0c9c769d613f7526406ecf3b3351d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646c5e616337a8174bd39ce729e53612"><td class="memTemplParams" colspan="2"><a class="anchor" id="a646c5e616337a8174bd39ce729e53612"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a646c5e616337a8174bd39ce729e53612"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::max</b> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a646c5e616337a8174bd39ce729e53612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35292f7ead7b19a2fc098f50f0147ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35292f7ead7b19a2fc098f50f0147ce6"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::max</b> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;x)</td></tr>
<tr class="separator:a35292f7ead7b19a2fc098f50f0147ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ff5485352bd4412d18050843809d42"><td class="memTemplParams" colspan="2"><a class="anchor" id="af7ff5485352bd4412d18050843809d42"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af7ff5485352bd4412d18050843809d42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::max</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:af7ff5485352bd4412d18050843809d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28171fa81d0f537dd058e63164410b43"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28171fa81d0f537dd058e63164410b43"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a28171fa81d0f537dd058e63164410b43"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::min</b> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a28171fa81d0f537dd058e63164410b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0241416e190842fd0c352a6c94c57c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0241416e190842fd0c352a6c94c57c3"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::min</b> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;x)</td></tr>
<tr class="separator:aa0241416e190842fd0c352a6c94c57c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33adfcd8368c2f96891ca3e27fd8affe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33adfcd8368c2f96891ca3e27fd8affe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a33adfcd8368c2f96891ca3e27fd8affe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::min</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:a33adfcd8368c2f96891ca3e27fd8affe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7fd5ce0385e9cc7bed5b44ed8475e8aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7fd5ce0385e9cc7bed5b44ed8475e8aa">keycpp::transpose</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of matrix A. <br/></td></tr>
<tr class="separator:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a72326529750cf63cf05afa6fa15a65"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a72326529750cf63cf05afa6fa15a65"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a72326529750cf63cf05afa6fa15a65"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0a72326529750cf63cf05afa6fa15a65">keycpp::transpose</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a0a72326529750cf63cf05afa6fa15a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of vector v1. <br/></td></tr>
<tr class="separator:a0a72326529750cf63cf05afa6fa15a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14503c0419f365433d88fa081d473210"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a14503c0419f365433d88fa081d473210">keycpp::ctranspose</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a14503c0419f365433d88fa081d473210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a14503c0419f365433d88fa081d473210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fc1e2c9bf6ee79ee28a6f25b7b55b23"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9fc1e2c9bf6ee79ee28a6f25b7b55b23">keycpp::ctranspose&lt; double &gt;</a> (const matrix&lt; double &gt; &amp;A)</td></tr>
<tr class="memdesc:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276b8edd0f4f62b430620047245d18d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad276b8edd0f4f62b430620047245d18d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad276b8edd0f4f62b430620047245d18d"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad276b8edd0f4f62b430620047245d18d">keycpp::ctranspose</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ad276b8edd0f4f62b430620047245d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of vector v1. <br/></td></tr>
<tr class="separator:ad276b8edd0f4f62b430620047245d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053c56f068ffe8c4a32e5a820b424b6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a053c56f068ffe8c4a32e5a820b424b6e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a053c56f068ffe8c4a32e5a820b424b6e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a053c56f068ffe8c4a32e5a820b424b6e">keycpp::sum</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a053c56f068ffe8c4a32e5a820b424b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of vector v1. <br/></td></tr>
<tr class="separator:a053c56f068ffe8c4a32e5a820b424b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778b050929a9f5cea9136df5d8bfe2d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a778b050929a9f5cea9136df5d8bfe2d8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a778b050929a9f5cea9136df5d8bfe2d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a778b050929a9f5cea9136df5d8bfe2d8">keycpp::sum</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a778b050929a9f5cea9136df5d8bfe2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of each column of A. <br/></td></tr>
<tr class="separator:a778b050929a9f5cea9136df5d8bfe2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966268670bc3e3b4f7107b8278e9b399"><td class="memTemplParams" colspan="2"><a class="anchor" id="a966268670bc3e3b4f7107b8278e9b399"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a966268670bc3e3b4f7107b8278e9b399"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a966268670bc3e3b4f7107b8278e9b399">keycpp::mat2vec</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a966268670bc3e3b4f7107b8278e9b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts matrix A to a column vector. <br/></td></tr>
<tr class="separator:a966268670bc3e3b4f7107b8278e9b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876140bc1dc01b4488c1bb2bba08940"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4876140bc1dc01b4488c1bb2bba08940"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4876140bc1dc01b4488c1bb2bba08940"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4876140bc1dc01b4488c1bb2bba08940">keycpp::vec2mat</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a4876140bc1dc01b4488c1bb2bba08940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a column vector to a 1 x length(v1) matrix. <br/></td></tr>
<tr class="separator:a4876140bc1dc01b4488c1bb2bba08940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8769de1f22713d3564350d53125b26"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e8769de1f22713d3564350d53125b26"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4e8769de1f22713d3564350d53125b26">keycpp::linspace</a> (const T &amp;x1, const T &amp;x2, const int &amp;N)</td></tr>
<tr class="memdesc:a4e8769de1f22713d3564350d53125b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values equally spaced between x1 and x2, inclusively.  <a href="#a4e8769de1f22713d3564350d53125b26">More...</a><br/></td></tr>
<tr class="separator:a4e8769de1f22713d3564350d53125b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1704b4adc18c9353ee63fa63539df54d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1704b4adc18c9353ee63fa63539df54d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1704b4adc18c9353ee63fa63539df54d">keycpp::logspace</a> (const T &amp;x1, const T &amp;x2, const int &amp;N)</td></tr>
<tr class="memdesc:a1704b4adc18c9353ee63fa63539df54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively.  <a href="#a1704b4adc18c9353ee63fa63539df54d">More...</a><br/></td></tr>
<tr class="separator:a1704b4adc18c9353ee63fa63539df54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7e6400d879e910f6bf8eb7270d5a64"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb7e6400d879e910f6bf8eb7270d5a64"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb7e6400d879e910f6bf8eb7270d5a64"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::unwrap</b> (const std::vector&lt; T &gt; &amp;v1, const T &amp;tol=pi)</td></tr>
<tr class="separator:afb7e6400d879e910f6bf8eb7270d5a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1acd03db6a49523cb5dbe751a80917a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1acd03db6a49523cb5dbe751a80917a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad1acd03db6a49523cb5dbe751a80917a">keycpp::mean</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ad1acd03db6a49523cb5dbe751a80917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean of vector v1. <br/></td></tr>
<tr class="separator:ad1acd03db6a49523cb5dbe751a80917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640a5654108c737a52e781ee1794571b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a640a5654108c737a52e781ee1794571b"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a640a5654108c737a52e781ee1794571b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a640a5654108c737a52e781ee1794571b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6759a7b418424b2ff906479f7be674"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe6759a7b418424b2ff906479f7be674"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afe6759a7b418424b2ff906479f7be674"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:afe6759a7b418424b2ff906479f7be674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a49bf5b82e6ed936de7431edf4a80b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a49bf5b82e6ed936de7431edf4a80b1"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4a49bf5b82e6ed936de7431edf4a80b1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const matrix&lt; T &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a4a49bf5b82e6ed936de7431edf4a80b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e4d72785a2ab1f2a5f351789d904f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaf4e4d72785a2ab1f2a5f351789d904f"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aaf4e4d72785a2ab1f2a5f351789d904f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y, const std::vector&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:aaf4e4d72785a2ab1f2a5f351789d904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7738d1b0ccad83715f29398829bd78"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c7738d1b0ccad83715f29398829bd78"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0c7738d1b0ccad83715f29398829bd78"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const matrix&lt; U &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a0c7738d1b0ccad83715f29398829bd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505a093e19a1f347d347b4a27ca7799"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5505a093e19a1f347d347b4a27ca7799"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5505a093e19a1f347d347b4a27ca7799"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const std::vector&lt; U &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, const std::vector&lt; std::vector&lt; U &gt; &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a5505a093e19a1f347d347b4a27ca7799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e3b00481455a363456bcdc8ab407fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1e3b00481455a363456bcdc8ab407fb"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:af1e3b00481455a363456bcdc8ab407fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::trapz</b> (const std::vector&lt; U &gt; &amp;eta, const std::vector&lt; T &gt; &amp;integrand)</td></tr>
<tr class="separator:af1e3b00481455a363456bcdc8ab407fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7124131346b73357a9e7d8e7c4ae9cc9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7124131346b73357a9e7d8e7c4ae9cc9"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7124131346b73357a9e7d8e7c4ae9cc9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (const matrix&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u, const int &amp;index=2)</td></tr>
<tr class="separator:a7124131346b73357a9e7d8e7c4ae9cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af805809516d8ef219573c6f3e4cbd077"><td class="memTemplParams" colspan="2"><a class="anchor" id="af805809516d8ef219573c6f3e4cbd077"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af805809516d8ef219573c6f3e4cbd077"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (const std::vector&lt; U &gt; &amp;eta, const matrix&lt; T &gt; &amp;u)</td></tr>
<tr class="separator:af805809516d8ef219573c6f3e4cbd077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e73976d2cf44b145d261f52c4bcdf5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e73976d2cf44b145d261f52c4bcdf5f"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a2e73976d2cf44b145d261f52c4bcdf5f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (const std::vector&lt; U &gt; &amp;eta, const std::vector&lt; T &gt; &amp;u)</td></tr>
<tr class="separator:a2e73976d2cf44b145d261f52c4bcdf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec9b07955f64a93dc76db37eea6656d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adec9b07955f64a93dc76db37eea6656d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adec9b07955f64a93dc76db37eea6656d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::fft</b> (const std::vector&lt; T &gt; &amp;u, int N=-1)</td></tr>
<tr class="separator:adec9b07955f64a93dc76db37eea6656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a880f7df231a78f912b3fb5d301c809f9"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:a880f7df231a78f912b3fb5d301c809f9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::ode45</b> (F odeClass, std::vector&lt; U &gt; x_ode, std::vector&lt; T &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:a880f7df231a78f912b3fb5d301c809f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6ae07fc18f5374868fe314f00108c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd6ae07fc18f5374868fe314f00108c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, double val)</td></tr>
<tr class="separator:afcd6ae07fc18f5374868fe314f00108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261a9d83dcc8786777d193575b7e1a1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a261a9d83dcc8786777d193575b7e1a1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, std::initializer_list&lt; int &gt; list)</td></tr>
<tr class="separator:a261a9d83dcc8786777d193575b7e1a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2641f24e5cec5eddddbd6de2159055f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2641f24e5cec5eddddbd6de2159055f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2641f24e5cec5eddddbd6de2159055f"><td class="memTemplItemLeft" align="right" valign="top">Sort_Matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sort</b> (const matrix&lt; T &gt; &amp;A, const int &amp;dim=2, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:aa2641f24e5cec5eddddbd6de2159055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba3dbd0ed8ce919ffcd445bcf273673"><td class="memTemplParams" colspan="2"><a class="anchor" id="adba3dbd0ed8ce919ffcd445bcf273673"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adba3dbd0ed8ce919ffcd445bcf273673"><td class="memTemplItemLeft" align="right" valign="top">Sort_Vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sort</b> (const std::vector&lt; T &gt; &amp;v1, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:adba3dbd0ed8ce919ffcd445bcf273673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a286886d48471685b18b7782f1e4a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a8a286886d48471685b18b7782f1e4a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a8a286886d48471685b18b7782f1e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6a8a286886d48471685b18b7782f1e4a">keycpp::disp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6a8a286886d48471685b18b7782f1e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. <br/></td></tr>
<tr class="separator:a6a8a286886d48471685b18b7782f1e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69db64fe38ad271de1939d3f1a5520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba69db64fe38ad271de1939d3f1a5520"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aba69db64fe38ad271de1939d3f1a5520">keycpp::input</a> (const std::string &amp;prompt, std::string option)</td></tr>
<tr class="memdesc:aba69db64fe38ad271de1939d3f1a5520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as "s" because C++ is a statically typed language. <br/></td></tr>
<tr class="separator:aba69db64fe38ad271de1939d3f1a5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bca7924aad17a920f2f5f0606e6d9a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4bca7924aad17a920f2f5f0606e6d9a9">keycpp::str2num</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) <br/></td></tr>
<tr class="separator:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fcab6592307cffe0e9aa035122a2e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c5fcab6592307cffe0e9aa035122a2e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c5fcab6592307cffe0e9aa035122a2e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1c5fcab6592307cffe0e9aa035122a2e">keycpp::length</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a1c5fcab6592307cffe0e9aa035122a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a vector. <br/></td></tr>
<tr class="separator:a1c5fcab6592307cffe0e9aa035122a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e64b0828ca7b61e301e8a803cfa91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a856e64b0828ca7b61e301e8a803cfa91"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a856e64b0828ca7b61e301e8a803cfa91"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a856e64b0828ca7b61e301e8a803cfa91">keycpp::length</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a856e64b0828ca7b61e301e8a803cfa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the largest dimension of A. <br/></td></tr>
<tr class="separator:a856e64b0828ca7b61e301e8a803cfa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd52330177821fc7cbf3f1c29e49f476"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd52330177821fc7cbf3f1c29e49f476"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abd52330177821fc7cbf3f1c29e49f476"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::numel</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:abd52330177821fc7cbf3f1c29e49f476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34a4afffae90a5579e08be7d2177b2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae34a4afffae90a5579e08be7d2177b2c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae34a4afffae90a5579e08be7d2177b2c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae34a4afffae90a5579e08be7d2177b2c">keycpp::find</a> (const std::vector&lt; T &gt; &amp;v1, const int &amp;k=-1, std::string start=&quot;&quot;)</td></tr>
<tr class="memdesc:ae34a4afffae90a5579e08be7d2177b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the indices of non-zero elements of v1. <br/></td></tr>
<tr class="separator:ae34a4afffae90a5579e08be7d2177b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97f0fc27cf8489f3f556fb1a0c975115"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memTemplItemLeft" align="right" valign="top">matrix_find_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a97f0fc27cf8489f3f556fb1a0c975115">keycpp::find</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a97f0fc27cf8489f3f556fb1a0c975115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the row and column indices and values of non-zero elements of A. <br/></td></tr>
<tr class="separator:a97f0fc27cf8489f3f556fb1a0c975115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef6aab5ede3802c66f27415107594ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ef6aab5ede3802c66f27415107594ed"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ef6aab5ede3802c66f27415107594ed"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::reshape</b> (const matrix&lt; T &gt; &amp;A, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:a5ef6aab5ede3802c66f27415107594ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a32dc59a247e09814a4b8ce9ea1db57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a32dc59a247e09814a4b8ce9ea1db57"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a32dc59a247e09814a4b8ce9ea1db57"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::reshape</b> (const std::vector&lt; T &gt; &amp;v1, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:a5a32dc59a247e09814a4b8ce9ea1db57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f586b97047513a6d2fa346d2302af0"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2f586b97047513a6d2fa346d2302af0"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af2f586b97047513a6d2fa346d2302af0"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; T &gt;<br class="typebreak"/>
()*std::declval&lt; U &gt;())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af2f586b97047513a6d2fa346d2302af0">keycpp::dot</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:af2f586b97047513a6d2fa346d2302af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between vectors v1 and v2. <br/></td></tr>
<tr class="separator:af2f586b97047513a6d2fa346d2302af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f44dfd7e58788078a8cba3696d3a39"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3f44dfd7e58788078a8cba3696d3a39"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac3f44dfd7e58788078a8cba3696d3a39"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac3f44dfd7e58788078a8cba3696d3a39">keycpp::dot</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B, const int &amp;dim=-1)</td></tr>
<tr class="memdesc:ac3f44dfd7e58788078a8cba3696d3a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between the first non-singleton dimension of A and B. <br/></td></tr>
<tr class="separator:ac3f44dfd7e58788078a8cba3696d3a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fa9874e6923dd54c95d52a22a99d00"><td class="memTemplParams" colspan="2"><a class="anchor" id="a73fa9874e6923dd54c95d52a22a99d00"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a73fa9874e6923dd54c95d52a22a99d00"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a73fa9874e6923dd54c95d52a22a99d00">keycpp::cross</a> (const std::vector&lt; T &gt; &amp;v1, const std::vector&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a73fa9874e6923dd54c95d52a22a99d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. <br/></td></tr>
<tr class="separator:a73fa9874e6923dd54c95d52a22a99d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85adf7a8804f7d7d3c378d86427b4210"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85adf7a8804f7d7d3c378d86427b4210"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85adf7a8804f7d7d3c378d86427b4210"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::norm</b> (const std::vector&lt; T &gt; &amp;v1, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a85adf7a8804f7d7d3c378d86427b4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb34bdd249af3ce92341cdda62f95f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb34bdd249af3ce92341cdda62f95f65"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; double &gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:aeb34bdd249af3ce92341cdda62f95f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838fc93d66e1ab63d68d04781086d81a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a838fc93d66e1ab63d68d04781086d81a"></a>
SVD_type&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a838fc93d66e1ab63d68d04781086d81a">keycpp::svd</a> (const matrix&lt; double &gt; &amp;A_in, std::string method)</td></tr>
<tr class="memdesc:a838fc93d66e1ab63d68d04781086d81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a838fc93d66e1ab63d68d04781086d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad211ab5ae14ac9710265c662f70f20ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad211ab5ae14ac9710265c662f70f20ff"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:ad211ab5ae14ac9710265c662f70f20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96149e6d3b76c5363601903c4fb72bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab96149e6d3b76c5363601903c4fb72bb"></a>
SVD_type&lt; std::complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::svd</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method=&quot;&quot;)</td></tr>
<tr class="separator:ab96149e6d3b76c5363601903c4fb72bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb9efbc77cc58fa22403ea7ae5f4555c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aeb9efbc77cc58fa22403ea7ae5f4555c">keycpp::rank</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. <br/></td></tr>
<tr class="separator:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f497e2da901adba0e1257be943595a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8f497e2da901adba0e1257be943595a1">keycpp::null</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8f497e2da901adba0e1257be943595a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of matrix A. <br/></td></tr>
<tr class="separator:a8f497e2da901adba0e1257be943595a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70b89ab3e8f66f86c47c3bde004d4487"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a70b89ab3e8f66f86c47c3bde004d4487">keycpp::any</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a70b89ab3e8f66f86c47c3bde004d4487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade6d308fd22d34ad4860e5fcd22ccb39"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ade6d308fd22d34ad4860e5fcd22ccb39">keycpp::any</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any elements of A are nonzero. <br/></td></tr>
<tr class="separator:ade6d308fd22d34ad4860e5fcd22ccb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b100190bc21b024340b7bddd4467dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01b100190bc21b024340b7bddd4467dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a01b100190bc21b024340b7bddd4467dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a01b100190bc21b024340b7bddd4467dd">keycpp::any</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a01b100190bc21b024340b7bddd4467dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any elements of v1 are nonzero. <br/></td></tr>
<tr class="separator:a01b100190bc21b024340b7bddd4467dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab77d82d9cc7d1fcca87967048f09e0e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aab77d82d9cc7d1fcca87967048f09e0e">keycpp::all</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aab77d82d9cc7d1fcca87967048f09e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd51ca90981278382a922c04ee7a75"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ebd51ca90981278382a922c04ee7a75"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ebd51ca90981278382a922c04ee7a75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0ebd51ca90981278382a922c04ee7a75">keycpp::all</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a0ebd51ca90981278382a922c04ee7a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are nonzero. <br/></td></tr>
<tr class="separator:a0ebd51ca90981278382a922c04ee7a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb91abe9a1d64046037bced47b7b466"><td class="memTemplParams" colspan="2"><a class="anchor" id="adcb91abe9a1d64046037bced47b7b466"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adcb91abe9a1d64046037bced47b7b466"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#adcb91abe9a1d64046037bced47b7b466">keycpp::all</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:adcb91abe9a1d64046037bced47b7b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of v1 are nonzero. <br/></td></tr>
<tr class="separator:adcb91abe9a1d64046037bced47b7b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03069647e77ae29e5437553b98274634"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03069647e77ae29e5437553b98274634"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03069647e77ae29e5437553b98274634"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a03069647e77ae29e5437553b98274634">keycpp::finite</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a03069647e77ae29e5437553b98274634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is finite. <br/></td></tr>
<tr class="separator:a03069647e77ae29e5437553b98274634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8879482fc9af1a809453e1719948263b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8879482fc9af1a809453e1719948263b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8879482fc9af1a809453e1719948263b"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8879482fc9af1a809453e1719948263b">keycpp::finite</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8879482fc9af1a809453e1719948263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are finite. <br/></td></tr>
<tr class="separator:a8879482fc9af1a809453e1719948263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4add0d0b269850e5f5fc1362d023666"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4add0d0b269850e5f5fc1362d023666"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af4add0d0b269850e5f5fc1362d023666"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af4add0d0b269850e5f5fc1362d023666">keycpp::finite</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:af4add0d0b269850e5f5fc1362d023666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are finite. <br/></td></tr>
<tr class="separator:af4add0d0b269850e5f5fc1362d023666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca45e7f46618cf193b6b7bb59465a9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adca45e7f46618cf193b6b7bb59465a9d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adca45e7f46618cf193b6b7bb59465a9d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#adca45e7f46618cf193b6b7bb59465a9d">keycpp::isinf</a> (const T &amp;a)</td></tr>
<tr class="memdesc:adca45e7f46618cf193b6b7bb59465a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is infinite. <br/></td></tr>
<tr class="separator:adca45e7f46618cf193b6b7bb59465a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12e8a9c04720e074328bb1d34dce04"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf12e8a9c04720e074328bb1d34dce04"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abf12e8a9c04720e074328bb1d34dce04"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abf12e8a9c04720e074328bb1d34dce04">keycpp::isinf</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abf12e8a9c04720e074328bb1d34dce04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are infinite. <br/></td></tr>
<tr class="separator:abf12e8a9c04720e074328bb1d34dce04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d8480a27e0e6d14d687054a221c0a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34d8480a27e0e6d14d687054a221c0a5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a34d8480a27e0e6d14d687054a221c0a5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a34d8480a27e0e6d14d687054a221c0a5">keycpp::isinf</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a34d8480a27e0e6d14d687054a221c0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are infinite. <br/></td></tr>
<tr class="separator:a34d8480a27e0e6d14d687054a221c0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5311cd26b6819f68c158d08c39d501"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b5311cd26b6819f68c158d08c39d501"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b5311cd26b6819f68c158d08c39d501"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6b5311cd26b6819f68c158d08c39d501">keycpp::isnan</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a6b5311cd26b6819f68c158d08c39d501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is NaN. <br/></td></tr>
<tr class="separator:a6b5311cd26b6819f68c158d08c39d501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b16064066dc041be364e6fbefa173a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3b16064066dc041be364e6fbefa173a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3b16064066dc041be364e6fbefa173a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad3b16064066dc041be364e6fbefa173a">keycpp::isnan</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ad3b16064066dc041be364e6fbefa173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are NaN. <br/></td></tr>
<tr class="separator:ad3b16064066dc041be364e6fbefa173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00160cff29da446de425d98ffafe8cb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a00160cff29da446de425d98ffafe8cb3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a00160cff29da446de425d98ffafe8cb3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a00160cff29da446de425d98ffafe8cb3">keycpp::isnan</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a00160cff29da446de425d98ffafe8cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing boolean values that are true if corresponding elements of v1 are NaN. <br/></td></tr>
<tr class="separator:a00160cff29da446de425d98ffafe8cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc2de8926c54a2048a0d8965e7d70995"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#acc2de8926c54a2048a0d8965e7d70995">keycpp::isempty</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:acc2de8926c54a2048a0d8965e7d70995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix is empty. <br/></td></tr>
<tr class="separator:acc2de8926c54a2048a0d8965e7d70995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bffe72cf3a118ccaaa6f195c4859550"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0bffe72cf3a118ccaaa6f195c4859550"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0bffe72cf3a118ccaaa6f195c4859550"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0bffe72cf3a118ccaaa6f195c4859550">keycpp::isempty</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a0bffe72cf3a118ccaaa6f195c4859550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if vector is empty. <br/></td></tr>
<tr class="separator:a0bffe72cf3a118ccaaa6f195c4859550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81a8c955cdbeb60181f6bf7d6553ac53"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a81a8c955cdbeb60181f6bf7d6553ac53">keycpp::isreal</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is real. <br/></td></tr>
<tr class="separator:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7118882bac24ab403ffb5f8ee7034"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62d7118882bac24ab403ffb5f8ee7034"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a62d7118882bac24ab403ffb5f8ee7034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a62d7118882bac24ab403ffb5f8ee7034">keycpp::isreal</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a62d7118882bac24ab403ffb5f8ee7034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are real. <br/></td></tr>
<tr class="separator:a62d7118882bac24ab403ffb5f8ee7034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad811cd86faad44bdf322b55d332fee29"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad811cd86faad44bdf322b55d332fee29"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad811cd86faad44bdf322b55d332fee29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad811cd86faad44bdf322b55d332fee29">keycpp::isreal</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:ad811cd86faad44bdf322b55d332fee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of v1 are real. <br/></td></tr>
<tr class="separator:ad811cd86faad44bdf322b55d332fee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005c1190f7087fb1d2545c38c080fd1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005c1190f7087fb1d2545c38c080fd1a"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a005c1190f7087fb1d2545c38c080fd1a">keycpp::ceil</a> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="memdesc:a005c1190f7087fb1d2545c38c080fd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the real and imaginary parts of complex&lt;double&gt; a towards positive infinity seperately. <br/></td></tr>
<tr class="separator:a005c1190f7087fb1d2545c38c080fd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb46ebfbb914f186bcb1859f39dfae91"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb46ebfbb914f186bcb1859f39dfae91"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adb46ebfbb914f186bcb1859f39dfae91"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#adb46ebfbb914f186bcb1859f39dfae91">keycpp::ceil</a> (const std::vector&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:adb46ebfbb914f186bcb1859f39dfae91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of v1 towards positive infinity. <br/></td></tr>
<tr class="separator:adb46ebfbb914f186bcb1859f39dfae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba31744fef3693901a075fda07857c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bba31744fef3693901a075fda07857c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bba31744fef3693901a075fda07857c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4bba31744fef3693901a075fda07857c">keycpp::ceil</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a4bba31744fef3693901a075fda07857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of A towards positive infinity. <br/></td></tr>
<tr class="separator:a4bba31744fef3693901a075fda07857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7752b443d306871030c8867467fe6cc9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7752b443d306871030c8867467fe6cc9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7752b443d306871030c8867467fe6cc9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7752b443d306871030c8867467fe6cc9">keycpp::roots</a> (const std::vector&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a7752b443d306871030c8867467fe6cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. <br/></td></tr>
<tr class="separator:a7752b443d306871030c8867467fe6cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6069a9eec0edfa1d401230013d98765e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6069a9eec0edfa1d401230013d98765e"></a>
tictoc_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e">keycpp::tic</a> ()</td></tr>
<tr class="memdesc:a6069a9eec0edfa1d401230013d98765e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the timer. <br/></td></tr>
<tr class="separator:a6069a9eec0edfa1d401230013d98765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe03fbbb5126729fb4b9367097acb1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe03fbbb5126729fb4b9367097acb1d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afe03fbbb5126729fb4b9367097acb1d1">keycpp::toc</a> (tictoc_type &amp;Timer)</td></tr>
<tr class="memdesc:afe03fbbb5126729fb4b9367097acb1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the timer. The number of elapsed seconds is returned. <br/></td></tr>
<tr class="separator:afe03fbbb5126729fb4b9367097acb1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d70a761d33bbc2bdec6b4e0eb43d517"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517">keycpp::sprintf</a> (const std::string &amp;fmt,...)</td></tr>
<tr class="memdesc:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the C++ function <a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517" title="Overload of the C++ function sprintf(). This overload provides a more MATLAB-like interface...">sprintf()</a>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. <br/></td></tr>
<tr class="separator:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2feefaeb946dd453d74ff51c66fe67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff2feefaeb946dd453d74ff51c66fe67"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aff2feefaeb946dd453d74ff51c66fe67">keycpp::clock</a> ()</td></tr>
<tr class="memdesc:aff2feefaeb946dd453d74ff51c66fe67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. <br/></td></tr>
<tr class="separator:aff2feefaeb946dd453d74ff51c66fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac20bd2ef4fb18cbcdb0f462a89447bd7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac20bd2ef4fb18cbcdb0f462a89447bd7">keycpp::pinv</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. <br/></td></tr>
<tr class="separator:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 17 2013 21:16:45 for KeyCpp -- A MATLAB-like library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{
var pageTracker = _gat._getTracker("UA-42949208-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
