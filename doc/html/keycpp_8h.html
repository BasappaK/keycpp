<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>KeyCpp -- A MATLAB-like library for C++: keycpp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-42949208-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">KeyCpp -- A MATLAB-like library for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#namespaces">Constant Groups</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">keycpp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;iomanip&gt;</code><br/>
<code>#include &lt;complex&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;cmath&gt;</code><br/>
<code>#include &lt;boost/numeric/odeint.hpp&gt;</code><br/>
<code>#include &lt;boost/range.hpp&gt;</code><br/>
<code>#include &lt;utility&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &lt;ctime&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &quot;vector_k.h&quot;</code><br/>
<code>#include &quot;Matrix.h&quot;</code><br/>
<code>#include &quot;_kiss_fft_guts.h&quot;</code><br/>
<code>#include &quot;Spline.h&quot;</code><br/>
<code>#include &quot;Figure.h&quot;</code><br/>
<code>#include &quot;SparseMatrix.h&quot;</code><br/>
<code>#include &quot;znaupd.h&quot;</code><br/>
</div>
<p><a href="keycpp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_key_cpp_exception.html">keycpp::KeyCppException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1observe.html">keycpp::observe&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1numeric_1_1odeint_1_1is__resizeable_3_01keycpp_1_1matrix_3_01_t_00_012_01_4_01_4.html">boost::numeric::odeint::is_resizeable&lt; keycpp::matrix&lt; T, 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_o_d_e__type.html">keycpp::ODE_type&lt; T, Y &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1_sort___matrix.html">keycpp::Sort_Matrix&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeycpp_1_1_s_v_d__type.html">keycpp::SVD_type&lt; T, X &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1tictoc__type.html">keycpp::tictoc_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for using the <a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e" title="Start the timer. ">tic()</a> and toc(tictoc_type Timer) commands.  <a href="structkeycpp_1_1tictoc__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkeycpp_1_1meshgrid__type.html">keycpp::meshgrid_type&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacekeycpp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html">keycpp</a></td></tr>
<tr class="memdesc:namespacekeycpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Constant Groups</h2></td></tr>
<tr class="memitem:namespacekeycpp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html">keycpp</a></td></tr>
<tr class="memdesc:namespacekeycpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keycpp namespace prevents KeyCpp functions and classes from interfering with other C++ libraries, for instance the std library. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55e50932cc54f92bdd7e38c6438f4f1f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a55e50932cc54f92bdd7e38c6438f4f1f">keycpp::ddot_</a> (const int *N, const double *a, const int *inca, const double *b, const int *incb)</td></tr>
<tr class="memdesc:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double dot product function. <br/></td></tr>
<tr class="separator:a55e50932cc54f92bdd7e38c6438f4f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce99b4fe4a13b9c70ada81761eb0ca2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a2ce99b4fe4a13b9c70ada81761eb0ca2">keycpp::zdotu_</a> (std::complex&lt; double &gt; *result, const int *N, const std::complex&lt; double &gt; *a, const int *inca, const std::complex&lt; double &gt; *b, const int *incb)</td></tr>
<tr class="memdesc:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double dot product function. <br/></td></tr>
<tr class="separator:a2ce99b4fe4a13b9c70ada81761eb0ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99c5b242a21ba683701ccb6ab6534b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae99c5b242a21ba683701ccb6ab6534b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae99c5b242a21ba683701ccb6ab6534b1">keycpp::daxpy_</a> (const int *N, const double *alpha, const double *x, const int *incx, double *y, const int *incy)</td></tr>
<tr class="memdesc:ae99c5b242a21ba683701ccb6ab6534b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double vector addition function. <br/></td></tr>
<tr class="separator:ae99c5b242a21ba683701ccb6ab6534b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6460fa334239dde761d8f737b9438fed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6460fa334239dde761d8f737b9438fed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6460fa334239dde761d8f737b9438fed">keycpp::zaxpy_</a> (const int *N, const std::complex&lt; double &gt; *alpha, const std::complex&lt; double &gt; *x, const int *incx, std::complex&lt; double &gt; *y, const int *incy)</td></tr>
<tr class="memdesc:a6460fa334239dde761d8f737b9438fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double vector addition function. <br/></td></tr>
<tr class="separator:a6460fa334239dde761d8f737b9438fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d249dd978770119c1b91d88009fefbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d249dd978770119c1b91d88009fefbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7d249dd978770119c1b91d88009fefbd">keycpp::dscal_</a> (const int *N, const double *alpha, double *x, const int *incx)</td></tr>
<tr class="memdesc:a7d249dd978770119c1b91d88009fefbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's double scalar-vector multiplication function. <br/></td></tr>
<tr class="separator:a7d249dd978770119c1b91d88009fefbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd69d0d355e4805a832813199f1dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9dd69d0d355e4805a832813199f1dff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad9dd69d0d355e4805a832813199f1dff">keycpp::zscal_</a> (const int *N, const std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *x, const int *incx)</td></tr>
<tr class="memdesc:ad9dd69d0d355e4805a832813199f1dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to BLAS's complex double scalar-vector multiplication function. <br/></td></tr>
<tr class="separator:ad9dd69d0d355e4805a832813199f1dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2501951ab3db3a91c3520ae89750b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2501951ab3db3a91c3520ae89750b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ace2501951ab3db3a91c3520ae89750b1">keycpp::zggev_</a> (const char *jobvl, const char *jobvr, const int *n, std::complex&lt; double &gt; *a, const int *lda, std::complex&lt; double &gt; *b, const int *ldb, std::complex&lt; double &gt; *alpha, std::complex&lt; double &gt; *beta, std::complex&lt; double &gt; *vl, const int *ldvl, std::complex&lt; double &gt; *vr, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:ace2501951ab3db3a91c3520ae89750b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex generalized eigenvalue solver. <br/></td></tr>
<tr class="separator:ace2501951ab3db3a91c3520ae89750b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc5253e80ac15a9bfdc5449ae4f972a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aebc5253e80ac15a9bfdc5449ae4f972a">keycpp::dgeev_</a> (const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:aebc5253e80ac15a9bfdc5449ae4f972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1cca2a162f40fc6c6218c35cadf9f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8c1cca2a162f40fc6c6218c35cadf9f2">keycpp::zgeev_</a> (const char *jobvl, const char *, const int *n, std::complex&lt; double &gt; *A, const int *lda, std::complex&lt; double &gt; *w, std::complex&lt; double &gt; *VL, const int *ldvl, std::complex&lt; double &gt; *VR, const int *ldvr, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex eigenvalue solver for a general matrix. <br/></td></tr>
<tr class="separator:a8c1cca2a162f40fc6c6218c35cadf9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3be6524e195662cbb74a810305e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3be6524e195662cbb74a810305e721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aca3be6524e195662cbb74a810305e721">keycpp::dgecon_</a> (const char *norm, const int *n, double *a, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info)</td></tr>
<tr class="memdesc:aca3be6524e195662cbb74a810305e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:aca3be6524e195662cbb74a810305e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e334ffaf1864d7191e9e0b64189783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e334ffaf1864d7191e9e0b64189783"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a75e334ffaf1864d7191e9e0b64189783">keycpp::dgetrf_</a> (const int *m, const int *n, double *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:a75e334ffaf1864d7191e9e0b64189783"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU decomposition function. <br/></td></tr>
<tr class="separator:a75e334ffaf1864d7191e9e0b64189783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c33788a2c083aa5738eda1fe62a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c33788a2c083aa5738eda1fe62a261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab9c33788a2c083aa5738eda1fe62a261">keycpp::dgetrs_</a> (const char *trans, int *n, int *nrhs, double *a, const int *lda, int *ipiv, double *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:ab9c33788a2c083aa5738eda1fe62a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision LU solver. <br/></td></tr>
<tr class="separator:ab9c33788a2c083aa5738eda1fe62a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507ef954be960fec70ca0f93258d730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4507ef954be960fec70ca0f93258d730"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4507ef954be960fec70ca0f93258d730">keycpp::dlange_</a> (const char *norm, const int *m, const int *n, const double *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a4507ef954be960fec70ca0f93258d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision norm function. <br/></td></tr>
<tr class="separator:a4507ef954be960fec70ca0f93258d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e3cdc7e7929414370b6b50ea1218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444e3cdc7e7929414370b6b50ea1218c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a444e3cdc7e7929414370b6b50ea1218c">keycpp::zgecon_</a> (const char *norm, const int *n, std::complex&lt; double &gt; *a, const int *lda, const double *anorm, double *rcond, std::complex&lt; double &gt; *work, double *rwork, int *info)</td></tr>
<tr class="memdesc:a444e3cdc7e7929414370b6b50ea1218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex-valued reciprocal condition number estimator. <br/></td></tr>
<tr class="separator:a444e3cdc7e7929414370b6b50ea1218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18d58d53d8e19a37d74d24da27a64dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab18d58d53d8e19a37d74d24da27a64dd">keycpp::zgetrf_</a> (const int *m, const int *n, std::complex&lt; double &gt; *a, const int *lda, int *lpiv, int *info)</td></tr>
<tr class="memdesc:ab18d58d53d8e19a37d74d24da27a64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU decomposition function. <br/></td></tr>
<tr class="separator:ab18d58d53d8e19a37d74d24da27a64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4322276dcdb7d864e85854b5b90f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe4322276dcdb7d864e85854b5b90f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abbe4322276dcdb7d864e85854b5b90f2">keycpp::zgetrs_</a> (const char *trans, int *n, int *nrhs, std::complex&lt; double &gt; *a, const int *lda, int *ipiv, std::complex&lt; double &gt; *b, int *ldb, int *info)</td></tr>
<tr class="memdesc:abbe4322276dcdb7d864e85854b5b90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex LU solver. <br/></td></tr>
<tr class="separator:abbe4322276dcdb7d864e85854b5b90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1477c910b07baef984fe8528c29b2774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1477c910b07baef984fe8528c29b2774"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1477c910b07baef984fe8528c29b2774">keycpp::zlange_</a> (const char *norm, const int *m, const int *n, const std::complex&lt; double &gt; *a, const int *lda, double *work)</td></tr>
<tr class="memdesc:a1477c910b07baef984fe8528c29b2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex norm function. <br/></td></tr>
<tr class="separator:a1477c910b07baef984fe8528c29b2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12719f4b48de048f9642066666a920bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12719f4b48de048f9642066666a920bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a12719f4b48de048f9642066666a920bd">keycpp::dgesv_</a> (const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, const int *info)</td></tr>
<tr class="memdesc:a12719f4b48de048f9642066666a920bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision linear system solver. <br/></td></tr>
<tr class="separator:a12719f4b48de048f9642066666a920bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0d887ae48cc4222f7167232a7f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92d0d887ae48cc4222f7167232a7f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af92d0d887ae48cc4222f7167232a7f82">keycpp::dgetri_</a> (const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:af92d0d887ae48cc4222f7167232a7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision matrix inverse function. <br/></td></tr>
<tr class="separator:af92d0d887ae48cc4222f7167232a7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190e125fe33133aafa586089ca6e174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4190e125fe33133aafa586089ca6e174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4190e125fe33133aafa586089ca6e174">keycpp::zgetri_</a> (const int *n, std::complex&lt; double &gt; *A, const int *lda, const int *ipiv, std::complex&lt; double &gt; *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a4190e125fe33133aafa586089ca6e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex matrix inverse function. <br/></td></tr>
<tr class="separator:a4190e125fe33133aafa586089ca6e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7a71afbb6c5dc049cdd7afff6c0af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8fe7a71afbb6c5dc049cdd7afff6c0af">keycpp::dgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr class="memdesc:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's double precision SVD function. <br/></td></tr>
<tr class="separator:a8fe7a71afbb6c5dc049cdd7afff6c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5e2f74110f53bd288c15ce1f183f9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afa5e2f74110f53bd288c15ce1f183f9b">keycpp::zgesvd_</a> (const char *jobu, const char *jobvt, const int *m, const int *n, std::complex&lt; double &gt; *A, const int *lda, double *S, std::complex&lt; double &gt; *U, const int *ldu, std::complex&lt; double &gt; *VT, const int *ldvt, std::complex&lt; double &gt; *work, const int *lwork, double *rwork, int *info)</td></tr>
<tr class="memdesc:afa5e2f74110f53bd288c15ce1f183f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a C interface to LAPACK's complex SVD function. <br/></td></tr>
<tr class="separator:afa5e2f74110f53bd288c15ce1f183f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2cabbae720e89202edc998eb6cbfec"><td class="memItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aef2cabbae720e89202edc998eb6cbfec">keycpp::eig</a> (const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, const matrix&lt; std::complex&lt; double &gt; &gt; &amp;B, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:aef2cabbae720e89202edc998eb6cbfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized complex-valued eigenvalue solver using LAPACK function call.  <a href="#aef2cabbae720e89202edc998eb6cbfec">More...</a><br/></td></tr>
<tr class="separator:aef2cabbae720e89202edc998eb6cbfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8be23e99e5aab35207275afc0d43a57"><td class="memItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae8be23e99e5aab35207275afc0d43a57">keycpp::eig</a> (const matrix&lt; std::complex&lt; double &gt; &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:ae8be23e99e5aab35207275afc0d43a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex-valued eigenvalue solver using LAPACK function call.  <a href="#ae8be23e99e5aab35207275afc0d43a57">More...</a><br/></td></tr>
<tr class="separator:ae8be23e99e5aab35207275afc0d43a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0634c813880b20cecb300509be839a94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0634c813880b20cecb300509be839a94"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::eig</b> (const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt;&gt; *vr_return=NULL, matrix&lt; std::complex&lt; double &gt;&gt; *vl_return=NULL)</td></tr>
<tr class="separator:a0634c813880b20cecb300509be839a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3905cfc35dbd146f5dbf7bcb5729c2c2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; double &gt; &amp;A)</td></tr>
<tr class="separator:a3905cfc35dbd146f5dbf7bcb5729c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d9a9dd04453e5a417f7a9eb8ae4391b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rcond</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a4d9a9dd04453e5a417f7a9eb8ae4391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c189f68e2b22b98c1f484c4d965e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689c189f68e2b22b98c1f484c4d965e8"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, const matrix&lt; std::complex&lt; double &gt;&gt; &amp;b_in)</td></tr>
<tr class="separator:a689c189f68e2b22b98c1f484c4d965e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3246a259240624138144230f049e8dde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3246a259240624138144230f049e8dde"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::linsolve</b> (const matrix&lt; double &gt; &amp;A_in, const matrix&lt; double &gt; &amp;b_in)</td></tr>
<tr class="separator:a3246a259240624138144230f049e8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96927cda2df7a6e8e2031941c43601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96927cda2df7a6e8e2031941c43601"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:adc96927cda2df7a6e8e2031941c43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9085342fc708fd5babae39321da3b89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9085342fc708fd5babae39321da3b89a"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::inv</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a9085342fc708fd5babae39321da3b89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bffa5a846e181974d7bfe2ab41fe03a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a3bffa5a846e181974d7bfe2ab41fe03a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; size_t, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3bffa5a846e181974d7bfe2ab41fe03a">keycpp::size</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a3bffa5a846e181974d7bfe2ab41fe03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of matrix A.  <a href="#a3bffa5a846e181974d7bfe2ab41fe03a">More...</a><br/></td></tr>
<tr class="separator:a3bffa5a846e181974d7bfe2ab41fe03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91dbdf14632d313a304d3ddbadf935f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad91dbdf14632d313a304d3ddbadf935f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad91dbdf14632d313a304d3ddbadf935f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad91dbdf14632d313a304d3ddbadf935f">keycpp::isnan</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ad91dbdf14632d313a304d3ddbadf935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is NaN. <br/></td></tr>
<tr class="separator:ad91dbdf14632d313a304d3ddbadf935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06706aa6f44dde4b12566f81ed2be94"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad06706aa6f44dde4b12566f81ed2be94"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad06706aa6f44dde4b12566f81ed2be94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad06706aa6f44dde4b12566f81ed2be94">keycpp::isnan</a> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="memdesc:ad06706aa6f44dde4b12566f81ed2be94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is NaN. <br/></td></tr>
<tr class="separator:ad06706aa6f44dde4b12566f81ed2be94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e322f9a9b9a2bd3446ecaffbcea88cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e322f9a9b9a2bd3446ecaffbcea88cb"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a7e322f9a9b9a2bd3446ecaffbcea88cb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7e322f9a9b9a2bd3446ecaffbcea88cb">keycpp::isnan</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a7e322f9a9b9a2bd3446ecaffbcea88cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are NaN. <br/></td></tr>
<tr class="separator:a7e322f9a9b9a2bd3446ecaffbcea88cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac999bd518fb456aa9a4fbd2c04f007de"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; T, dim &gt; &amp;A, T(*f)(const T &amp;))</td></tr>
<tr class="separator:ac999bd518fb456aa9a4fbd2c04f007de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0865e2c884915d6ed0e3ef7bf73438b0"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A, T(*f)(const std::complex&lt; T &gt; &amp;))</td></tr>
<tr class="separator:a0865e2c884915d6ed0e3ef7bf73438b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e135aeca12d58b9a084413bf571783"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46e135aeca12d58b9a084413bf571783"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a46e135aeca12d58b9a084413bf571783"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; T, dim &gt; &amp;A, T(*f)(T))</td></tr>
<tr class="separator:a46e135aeca12d58b9a084413bf571783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2309a6456fab18ec68a436f269d32d8f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2309a6456fab18ec68a436f269d32d8f"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a2309a6456fab18ec68a436f269d32d8f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eop</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A, T(*f)(std::complex&lt; T &gt;))</td></tr>
<tr class="separator:a2309a6456fab18ec68a436f269d32d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f8946c126102b4467b70da16766b7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86f8946c126102b4467b70da16766b7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a86f8946c126102b4467b70da16766b7a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::operator&lt;&lt;</b> (std::ostream &amp;out, const vector_k&lt; T &gt; &amp;v1)</td></tr>
<tr class="separator:a86f8946c126102b4467b70da16766b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add55ad2a40111d6368744a3d4144f25a"><td class="memTemplParams" colspan="2"><a class="anchor" id="add55ad2a40111d6368744a3d4144f25a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:add55ad2a40111d6368744a3d4144f25a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#add55ad2a40111d6368744a3d4144f25a">keycpp::prod</a> (const vector_k&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:add55ad2a40111d6368744a3d4144f25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements of the vector x. <br/></td></tr>
<tr class="separator:add55ad2a40111d6368744a3d4144f25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5471fc9074471701bde9e68eb7971b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5471fc9074471701bde9e68eb7971b4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af5471fc9074471701bde9e68eb7971b4"><td class="memTemplItemLeft" align="right" valign="top">vector_k&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af5471fc9074471701bde9e68eb7971b4">keycpp::prod</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:af5471fc9074471701bde9e68eb7971b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the product of all the elements in each column of the matrix A. <br/></td></tr>
<tr class="separator:af5471fc9074471701bde9e68eb7971b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52c37ec9c41349fd6bd862b8ebdd01bb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memTemplItemLeft" align="right" valign="top">vector_k&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a52c37ec9c41349fd6bd862b8ebdd01bb">keycpp::diff</a> (const vector_k&lt; T &gt; &amp;v1)</td></tr>
<tr class="memdesc:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of differences between adjacent elements. <br/></td></tr>
<tr class="separator:a52c37ec9c41349fd6bd862b8ebdd01bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#abb4e57814fd30b7b8d4845bbc16c73e9">keycpp::diff</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of row differences between adjacent rows.  <a href="#abb4e57814fd30b7b8d4845bbc16c73e9">More...</a><br/></td></tr>
<tr class="separator:abb4e57814fd30b7b8d4845bbc16c73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c63d9cf20e676efbcefd445698aca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a422c63d9cf20e676efbcefd445698aca"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a422c63d9cf20e676efbcefd445698aca"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::conj</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a422c63d9cf20e676efbcefd445698aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab8937a6378526f7514c6124fb9991a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ab8937a6378526f7514c6124fb9991a"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a6ab8937a6378526f7514c6124fb9991a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::real</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a6ab8937a6378526f7514c6124fb9991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d42394a53ae81f292d1e3de4383cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a026d42394a53ae81f292d1e3de4383cb"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a026d42394a53ae81f292d1e3de4383cb"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::imag</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a026d42394a53ae81f292d1e3de4383cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaeb417b7e61b4bbe200edc1315c7d2e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="separator:aeaeb417b7e61b4bbe200edc1315c7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d77410749bcf5a36793e3754e357b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f7d77410749bcf5a36793e3754e357b"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a6f7d77410749bcf5a36793e3754e357b"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::abs</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:a6f7d77410749bcf5a36793e3754e357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e5296774667c3be4e792b5cd980da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952e5296774667c3be4e792b5cd980da"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::csqrt</b> (const double &amp;a)</td></tr>
<tr class="separator:a952e5296774667c3be4e792b5cd980da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa7912f1f198c5185cb6a36cfd2fb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8faa7912f1f198c5185cb6a36cfd2fb2"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::csqrt</b> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="separator:a8faa7912f1f198c5185cb6a36cfd2fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18a3ebbda3c25527ae280f5c5725ff4e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a18a3ebbda3c25527ae280f5c5725ff4e">keycpp::sin</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:a18a3ebbda3c25527ae280f5c5725ff4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb234b850e34f9331031d39084fdbb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aedb234b850e34f9331031d39084fdbb0"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:aedb234b850e34f9331031d39084fdbb0"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aedb234b850e34f9331031d39084fdbb0">keycpp::sin</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:aedb234b850e34f9331031d39084fdbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sine of each element of A. <br/></td></tr>
<tr class="separator:aedb234b850e34f9331031d39084fdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a918a1ad9493c25e0afb4d2a37af24d25"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a918a1ad9493c25e0afb4d2a37af24d25">keycpp::cos</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a918a1ad9493c25e0afb4d2a37af24d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cosine of each element of A. <br/></td></tr>
<tr class="separator:a918a1ad9493c25e0afb4d2a37af24d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ae0fcbeee4b61db0483546cf76021"><td class="memTemplParams" colspan="2"><a class="anchor" id="a882ae0fcbeee4b61db0483546cf76021"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a882ae0fcbeee4b61db0483546cf76021"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a882ae0fcbeee4b61db0483546cf76021">keycpp::cos</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a882ae0fcbeee4b61db0483546cf76021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the cos of each element of A. <br/></td></tr>
<tr class="separator:a882ae0fcbeee4b61db0483546cf76021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81f8ab9b05b8eaf07be99e141ce1c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e81f8ab9b05b8eaf07be99e141ce1c9"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a8e81f8ab9b05b8eaf07be99e141ce1c9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8e81f8ab9b05b8eaf07be99e141ce1c9">keycpp::tan</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a8e81f8ab9b05b8eaf07be99e141ce1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:a8e81f8ab9b05b8eaf07be99e141ce1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af9d4ca9aedc999153a2dd305a6e95e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3af9d4ca9aedc999153a2dd305a6e95e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a3af9d4ca9aedc999153a2dd305a6e95e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3af9d4ca9aedc999153a2dd305a6e95e">keycpp::tan</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a3af9d4ca9aedc999153a2dd305a6e95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the tangent of each element of A. <br/></td></tr>
<tr class="separator:a3af9d4ca9aedc999153a2dd305a6e95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74731028e7d006f90426aff4547c82e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a74731028e7d006f90426aff4547c82e1"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a74731028e7d006f90426aff4547c82e1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a74731028e7d006f90426aff4547c82e1">keycpp::acos</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a74731028e7d006f90426aff4547c82e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of A. <br/></td></tr>
<tr class="separator:a74731028e7d006f90426aff4547c82e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4671e6b0c2be8f6411419d4615b2442"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4671e6b0c2be8f6411419d4615b2442"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:aa4671e6b0c2be8f6411419d4615b2442"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa4671e6b0c2be8f6411419d4615b2442">keycpp::acos</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:aa4671e6b0c2be8f6411419d4615b2442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc cosine of each element of A. <br/></td></tr>
<tr class="separator:aa4671e6b0c2be8f6411419d4615b2442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024251803fe616d13f26978e2ebb10cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a024251803fe616d13f26978e2ebb10cf"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a024251803fe616d13f26978e2ebb10cf"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a024251803fe616d13f26978e2ebb10cf">keycpp::asin</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a024251803fe616d13f26978e2ebb10cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of A. <br/></td></tr>
<tr class="separator:a024251803fe616d13f26978e2ebb10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cedb7bbe6ba4a4c6f87cff65c91298"><td class="memTemplParams" colspan="2"><a class="anchor" id="af7cedb7bbe6ba4a4c6f87cff65c91298"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:af7cedb7bbe6ba4a4c6f87cff65c91298"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af7cedb7bbe6ba4a4c6f87cff65c91298">keycpp::asin</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:af7cedb7bbe6ba4a4c6f87cff65c91298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the arc sine of each element of A. <br/></td></tr>
<tr class="separator:af7cedb7bbe6ba4a4c6f87cff65c91298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0302faeef7172f537f3473216c0cf33b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0302faeef7172f537f3473216c0cf33b"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a0302faeef7172f537f3473216c0cf33b"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0302faeef7172f537f3473216c0cf33b">keycpp::exp</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a0302faeef7172f537f3473216c0cf33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a0302faeef7172f537f3473216c0cf33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89087f62a5d5d136ad88493b920953ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89087f62a5d5d136ad88493b920953ac"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a89087f62a5d5d136ad88493b920953ac"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a89087f62a5d5d136ad88493b920953ac">keycpp::exp</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a89087f62a5d5d136ad88493b920953ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the exponential of each element of A. <br/></td></tr>
<tr class="separator:a89087f62a5d5d136ad88493b920953ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31321365987f3cadb5e6d3038d2ff6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d31321365987f3cadb5e6d3038d2ff6"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a0d31321365987f3cadb5e6d3038d2ff6"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a0d31321365987f3cadb5e6d3038d2ff6">keycpp::log</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a0d31321365987f3cadb5e6d3038d2ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:a0d31321365987f3cadb5e6d3038d2ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a235af8108964defc4dc084bec2c7f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a235af8108964defc4dc084bec2c7f9"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a7a235af8108964defc4dc084bec2c7f9"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7a235af8108964defc4dc084bec2c7f9">keycpp::log</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a7a235af8108964defc4dc084bec2c7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the natural logarithm of each element of A. <br/></td></tr>
<tr class="separator:a7a235af8108964defc4dc084bec2c7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee080f280e09a893944b33683e3d4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5ee080f280e09a893944b33683e3d4d"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:af5ee080f280e09a893944b33683e3d4d"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af5ee080f280e09a893944b33683e3d4d">keycpp::log10</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:af5ee080f280e09a893944b33683e3d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:af5ee080f280e09a893944b33683e3d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6fb67c965ed61d53e3438a65282b97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e6fb67c965ed61d53e3438a65282b97"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a3e6fb67c965ed61d53e3438a65282b97"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3e6fb67c965ed61d53e3438a65282b97">keycpp::log10</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a3e6fb67c965ed61d53e3438a65282b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the base 10 logarithm of each element of A. <br/></td></tr>
<tr class="separator:a3e6fb67c965ed61d53e3438a65282b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a50cdc90b4c6f56bf9a7c144c4ac95"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28a50cdc90b4c6f56bf9a7c144c4ac95"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a28a50cdc90b4c6f56bf9a7c144c4ac95"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a28a50cdc90b4c6f56bf9a7c144c4ac95">keycpp::sqrt</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a28a50cdc90b4c6f56bf9a7c144c4ac95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:a28a50cdc90b4c6f56bf9a7c144c4ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bd9044cff082d4bb16bf36903ca2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c9bd9044cff082d4bb16bf36903ca2f"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a1c9bd9044cff082d4bb16bf36903ca2f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1c9bd9044cff082d4bb16bf36903ca2f">keycpp::sqrt</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a1c9bd9044cff082d4bb16bf36903ca2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the sqrt of each element of A. <br/></td></tr>
<tr class="separator:a1c9bd9044cff082d4bb16bf36903ca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86dd983e0f6ac12811b765d7cb68f68"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae86dd983e0f6ac12811b765d7cb68f68"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:ae86dd983e0f6ac12811b765d7cb68f68"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; T &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ae86dd983e0f6ac12811b765d7cb68f68">keycpp::csqrt</a> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:ae86dd983e0f6ac12811b765d7cb68f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:ae86dd983e0f6ac12811b765d7cb68f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac11afedab6d33ab5c6bf7e7f7c7a32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ac11afedab6d33ab5c6bf7e7f7c7a32"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a7ac11afedab6d33ab5c6bf7e7f7c7a32"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7ac11afedab6d33ab5c6bf7e7f7c7a32">keycpp::csqrt</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a7ac11afedab6d33ab5c6bf7e7f7c7a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing the csqrt of each element of A. <br/></td></tr>
<tr class="separator:a7ac11afedab6d33ab5c6bf7e7f7c7a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ae33fb19a521ab1ec1f22e7c39ca076"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::eye</b> (const int &amp;N)</td></tr>
<tr class="separator:a8ae33fb19a521ab1ec1f22e7c39ca076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737223780bc4bcda96ca2142a2ac3de9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a737223780bc4bcda96ca2142a2ac3de9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a737223780bc4bcda96ca2142a2ac3de9">keycpp::size</a> (const matrix&lt; T, dim &gt; &amp;A, const int &amp;n)</td></tr>
<tr class="memdesc:a737223780bc4bcda96ca2142a2ac3de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements along dimension dim.  <a href="#a737223780bc4bcda96ca2142a2ac3de9">More...</a><br/></td></tr>
<tr class="separator:a737223780bc4bcda96ca2142a2ac3de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5699c522088657287bf0ac01173b716c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5699c522088657287bf0ac01173b716c">keycpp::zeros</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a5699c522088657287bf0ac01173b716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all zeros.  <a href="#a5699c522088657287bf0ac01173b716c">More...</a><br/></td></tr>
<tr class="separator:a5699c522088657287bf0ac01173b716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d2688097884d279a27fdbb38d35b6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f2d2688097884d279a27fdbb38d35b6"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3f2d2688097884d279a27fdbb38d35b6">keycpp::zeros</a> (const int &amp;N)</td></tr>
<tr class="memdesc:a3f2d2688097884d279a27fdbb38d35b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size N x N containing all zeros.  <a href="#a3f2d2688097884d279a27fdbb38d35b6">More...</a><br/></td></tr>
<tr class="separator:a3f2d2688097884d279a27fdbb38d35b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a388f91a0ccf34978ef9403ccd0c680bf">keycpp::ones</a> (const int &amp;M, const int &amp;N)</td></tr>
<tr class="memdesc:a388f91a0ccf34978ef9403ccd0c680bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size M x N containing all ones.  <a href="#a388f91a0ccf34978ef9403ccd0c680bf">More...</a><br/></td></tr>
<tr class="separator:a388f91a0ccf34978ef9403ccd0c680bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b117efdb07f136f72534b65952c167"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a49b117efdb07f136f72534b65952c167"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a49b117efdb07f136f72534b65952c167">keycpp::ones</a> (const int &amp;N)</td></tr>
<tr class="memdesc:a49b117efdb07f136f72534b65952c167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix of size N x N containing all ones.  <a href="#a49b117efdb07f136f72534b65952c167">More...</a><br/></td></tr>
<tr class="separator:a49b117efdb07f136f72534b65952c167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bb3ea9a842383b82c889179f25be9ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bb3ea9a842383b82c889179f25be9ec"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const std::initializer_list&lt; T &gt; &amp;lst, const int &amp;d=0)</td></tr>
<tr class="separator:a4bb3ea9a842383b82c889179f25be9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb22f2e817f5a19a8547f446d48855b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb22f2e817f5a19a8547f446d48855b6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb22f2e817f5a19a8547f446d48855b6"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diag</b> (const matrix&lt; T, 2 &gt; &amp;A, const int &amp;d=0)</td></tr>
<tr class="separator:abb22f2e817f5a19a8547f446d48855b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec07979cca186806a17250b2cb50aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dec07979cca186806a17250b2cb50aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7dec07979cca186806a17250b2cb50aa"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::repmat</b> (const matrix&lt; T, 2 &gt; &amp;A, const int &amp;m, const int &amp;n)</td></tr>
<tr class="separator:a7dec07979cca186806a17250b2cb50aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memTemplParams" colspan="2">template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a23a0fd48168263aad7f77f1769dc2f2a">keycpp::times</a> (const matrix&lt; T, dim &gt; &amp;A, const matrix&lt; U, dim &gt; &amp;B)</td></tr>
<tr class="memdesc:a23a0fd48168263aad7f77f1769dc2f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs array multiplication on matrices A and B.  <a href="#a23a0fd48168263aad7f77f1769dc2f2a">More...</a><br/></td></tr>
<tr class="separator:a23a0fd48168263aad7f77f1769dc2f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d379c0b2c9d430f498daae5601f7a79"><td class="memTemplParams" colspan="2">template&lt;class T , class U , size_t dim&gt; </td></tr>
<tr class="memitem:a6d379c0b2c9d430f498daae5601f7a79"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;<br class="typebreak"/>
)), dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6d379c0b2c9d430f498daae5601f7a79">keycpp::rdivide</a> (const matrix&lt; T, dim &gt; &amp;A, const matrix&lt; U, dim &gt; &amp;B)</td></tr>
<tr class="memdesc:a6d379c0b2c9d430f498daae5601f7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs right array division on matrices A and B.  <a href="#a6d379c0b2c9d430f498daae5601f7a79">More...</a><br/></td></tr>
<tr class="separator:a6d379c0b2c9d430f498daae5601f7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac57d32902cba2c399475015235aeccec"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac57d32902cba2c399475015235aeccec">keycpp::ldivide</a> (const matrix&lt; T &gt; &amp;B, const matrix&lt; U &gt; &amp;A)</td></tr>
<tr class="memdesc:ac57d32902cba2c399475015235aeccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs left array division on matrices B and A.  <a href="#ac57d32902cba2c399475015235aeccec">More...</a><br/></td></tr>
<tr class="separator:ac57d32902cba2c399475015235aeccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplParams" colspan="2"><a class="anchor" id="a87f2917e6a7c8e20d010aea0d8480668"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a87f2917e6a7c8e20d010aea0d8480668"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sign</b> (const T &amp;val)</td></tr>
<tr class="separator:a87f2917e6a7c8e20d010aea0d8480668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa2e17334911e8a447a5ef6c0cc54c3f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (const std::complex&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aaa2e17334911e8a447a5ef6c0cc54c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe373666d686c14e6ce6517d050373"><td class="memTemplParams" colspan="2"><a class="anchor" id="afbbe373666d686c14e6ce6517d050373"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:afbbe373666d686c14e6ce6517d050373"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::angle</b> (const matrix&lt; std::complex&lt; T &gt;, dim &gt; &amp;A)</td></tr>
<tr class="separator:afbbe373666d686c14e6ce6517d050373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b5a8f06ace0e74416f6b22fbefd1a0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03b5a8f06ace0e74416f6b22fbefd1a0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03b5a8f06ace0e74416f6b22fbefd1a0"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::max</b> (const matrix&lt; T, 2 &gt; &amp;A)</td></tr>
<tr class="separator:a03b5a8f06ace0e74416f6b22fbefd1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafc954673ba1f1fb140d83ba1d88a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafc954673ba1f1fb140d83ba1d88a23"></a>
matrix&lt; std::complex&lt; double &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::max</b> (const matrix&lt; std::complex&lt; double &gt;, 2 &gt; &amp;A)</td></tr>
<tr class="separator:adafc954673ba1f1fb140d83ba1d88a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f9dd276a27f616258da602ee559541"><td class="memTemplParams" colspan="2"><a class="anchor" id="a96f9dd276a27f616258da602ee559541"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a96f9dd276a27f616258da602ee559541"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::min</b> (const matrix&lt; T, 2 &gt; &amp;A)</td></tr>
<tr class="separator:a96f9dd276a27f616258da602ee559541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29add9ed4a57360a11fbf614df7f3a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29add9ed4a57360a11fbf614df7f3a7"></a>
matrix&lt; std::complex&lt; double &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::min</b> (const matrix&lt; std::complex&lt; double &gt;, 2 &gt; &amp;A)</td></tr>
<tr class="separator:aa29add9ed4a57360a11fbf614df7f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7fd5ce0385e9cc7bed5b44ed8475e8aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7fd5ce0385e9cc7bed5b44ed8475e8aa">keycpp::transpose</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of matrix A. <br/></td></tr>
<tr class="separator:a7fd5ce0385e9cc7bed5b44ed8475e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14503c0419f365433d88fa081d473210"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a14503c0419f365433d88fa081d473210"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a14503c0419f365433d88fa081d473210">keycpp::ctranspose</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a14503c0419f365433d88fa081d473210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a14503c0419f365433d88fa081d473210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fc1e2c9bf6ee79ee28a6f25b7b55b23"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9fc1e2c9bf6ee79ee28a6f25b7b55b23">keycpp::ctranspose&lt; double &gt;</a> (const matrix&lt; double &gt; &amp;A)</td></tr>
<tr class="memdesc:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex-conjugate transpose of matrix A. <br/></td></tr>
<tr class="separator:a9fc1e2c9bf6ee79ee28a6f25b7b55b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cda317c047e8579e665abccf1b1398"><td class="memTemplParams" colspan="2"><a class="anchor" id="a36cda317c047e8579e665abccf1b1398"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a36cda317c047e8579e665abccf1b1398"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a36cda317c047e8579e665abccf1b1398">keycpp::sum</a> (const matrix&lt; T, 2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a36cda317c047e8579e665abccf1b1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of each column of A. <br/></td></tr>
<tr class="separator:a36cda317c047e8579e665abccf1b1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8772b4517093ae5e6de3261ded005d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b8772b4517093ae5e6de3261ded005d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b8772b4517093ae5e6de3261ded005d"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::linspace</b> (const T &amp;x1, const T &amp;x2, const size_t &amp;N)</td></tr>
<tr class="separator:a4b8772b4517093ae5e6de3261ded005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28626d0ffc4ecda3f9bc6e7b0f4fc4d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a28626d0ffc4ecda3f9bc6e7b0f4fc4d2"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a28626d0ffc4ecda3f9bc6e7b0f4fc4d2">keycpp::logspace</a> (const T &amp;x1, const T &amp;x2, const int &amp;N)</td></tr>
<tr class="memdesc:a28626d0ffc4ecda3f9bc6e7b0f4fc4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a vector containing N values logarithmically spaced between 10^(x1) and 10^(x2), inclusively.  <a href="#a28626d0ffc4ecda3f9bc6e7b0f4fc4d2">More...</a><br/></td></tr>
<tr class="separator:a28626d0ffc4ecda3f9bc6e7b0f4fc4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec240358cae3ca4a4a92c9e7dead409c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec240358cae3ca4a4a92c9e7dead409c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aec240358cae3ca4a4a92c9e7dead409c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::unwrap</b> (const matrix&lt; T, 2 &gt; &amp;v1, const T &amp;tol=pi)</td></tr>
<tr class="separator:aec240358cae3ca4a4a92c9e7dead409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef7ec1e4c2fab43922859a44758da6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24ef7ec1e4c2fab43922859a44758da6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24ef7ec1e4c2fab43922859a44758da6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a24ef7ec1e4c2fab43922859a44758da6">keycpp::mean</a> (const matrix&lt; T, 2 &gt; &amp;v1)</td></tr>
<tr class="memdesc:a24ef7ec1e4c2fab43922859a44758da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean of vector v1. <br/></td></tr>
<tr class="separator:a24ef7ec1e4c2fab43922859a44758da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5f11c2b7a3890a0987b9dd10e31cd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c5f11c2b7a3890a0987b9dd10e31cd4"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9c5f11c2b7a3890a0987b9dd10e31cd4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1_vec</b> (const matrix&lt; U, 2 &gt; &amp;x, const matrix&lt; T, 2 &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:a9c5f11c2b7a3890a0987b9dd10e31cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452328f21ddc3131c2df2b3cbbbed7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab452328f21ddc3131c2df2b3cbbbed7c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab452328f21ddc3131c2df2b3cbbbed7c"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const matrix&lt; U, 2 &gt; &amp;x, const matrix&lt; T, 2 &gt; &amp;y, const matrix&lt; U, 2 &gt; &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:ab452328f21ddc3131c2df2b3cbbbed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa379fd1b7ae981ede575baf357c18302"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa379fd1b7ae981ede575baf357c18302"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa379fd1b7ae981ede575baf357c18302"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::interp1</b> (const matrix&lt; U, 2 &gt; &amp;x, const matrix&lt; T, 2 &gt; &amp;y, const U &amp;x_interp, std::string method=&quot;linear&quot;, Extrap extrap=Extrap())</td></tr>
<tr class="separator:aa379fd1b7ae981ede575baf357c18302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e68fc6f023bc2634c3a6f1ddb7e6b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9e68fc6f023bc2634c3a6f1ddb7e6b8"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:ac9e68fc6f023bc2634c3a6f1ddb7e6b8"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::trapz</b> (const matrix&lt; U, 2 &gt; &amp;eta, const matrix&lt; T, 2 &gt; &amp;integrand)</td></tr>
<tr class="separator:ac9e68fc6f023bc2634c3a6f1ddb7e6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb28bb59e9e552598c05ebe9d1af397"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbb28bb59e9e552598c05ebe9d1af397"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adbb28bb59e9e552598c05ebe9d1af397"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::diffxy</b> (const matrix&lt; U, 2 &gt; &amp;eta, const matrix&lt; T, 2 &gt; &amp;u, const int &amp;index=2)</td></tr>
<tr class="separator:adbb28bb59e9e552598c05ebe9d1af397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcfb748997291434fe9db7dbffd8c6f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fcfb748997291434fe9db7dbffd8c6f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1fcfb748997291434fe9db7dbffd8c6f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; double &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::fft</b> (const matrix&lt; T, 2 &gt; &amp;u, int N=-1)</td></tr>
<tr class="separator:a1fcfb748997291434fe9db7dbffd8c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7114f640a4a253a1d50ffc810bdad0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d7114f640a4a253a1d50ffc810bdad0"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:a6d7114f640a4a253a1d50ffc810bdad0"><td class="memTemplItemLeft" align="right" valign="top">ODE_type&lt; U, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::ode45</b> (F odeClass, const std::initializer_list&lt; U &gt; &amp;x_span, matrix&lt; T, 2 &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:a6d7114f640a4a253a1d50ffc810bdad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0edbbd76794e73bfade1d428f5dd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeea0edbbd76794e73bfade1d428f5dd7"></a>
template&lt;class T , class U , class F &gt; </td></tr>
<tr class="memitem:aeea0edbbd76794e73bfade1d428f5dd7"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::ode45</b> (F odeClass, matrix&lt; U, 2 &gt; x_ode, matrix&lt; T, 2 &gt; ICs, double abs_tol=1.0e-10, double rel_tol=1.0e-6)</td></tr>
<tr class="separator:aeea0edbbd76794e73bfade1d428f5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6ae07fc18f5374868fe314f00108c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd6ae07fc18f5374868fe314f00108c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, double val)</td></tr>
<tr class="separator:afcd6ae07fc18f5374868fe314f00108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd8f41e3cdddb0dcca913eef5ee329"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53fd8f41e3cdddb0dcca913eef5ee329"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, std::string val)</td></tr>
<tr class="separator:a53fd8f41e3cdddb0dcca913eef5ee329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67eb981ff22ef79a4ee90a9a40ae21f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67eb981ff22ef79a4ee90a9a40ae21f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::set</b> (Figure &amp;h, std::string property, std::initializer_list&lt; size_t &gt; list)</td></tr>
<tr class="separator:ae67eb981ff22ef79a4ee90a9a40ae21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dec3da4533a1db21a6c6c4fe8e740a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9dec3da4533a1db21a6c6c4fe8e740a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::print</b> (Figure &amp;h, std::string pterm, std::string pfilename)</td></tr>
<tr class="separator:af9dec3da4533a1db21a6c6c4fe8e740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fb697518c456560dea0b328e693418"><td class="memTemplParams" colspan="2"><a class="anchor" id="a82fb697518c456560dea0b328e693418"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a82fb697518c456560dea0b328e693418"><td class="memTemplItemLeft" align="right" valign="top">Sort_Matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::sort</b> (const matrix&lt; T &gt; &amp;A, const size_t &amp;dim=2, std::string method=&quot;ascend&quot;)</td></tr>
<tr class="separator:a82fb697518c456560dea0b328e693418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2245da139cf6cf2e03426476b3b88"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4a2245da139cf6cf2e03426476b3b88"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af4a2245da139cf6cf2e03426476b3b88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af4a2245da139cf6cf2e03426476b3b88">keycpp::disp</a> (const T &amp;x, std::ostream &amp;outStream=std::cout)</td></tr>
<tr class="memdesc:af4a2245da139cf6cf2e03426476b3b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays on standard output any parameter passed to it provided the operator &lt;&lt; is defined for its type. <br/></td></tr>
<tr class="separator:af4a2245da139cf6cf2e03426476b3b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69db64fe38ad271de1939d3f1a5520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba69db64fe38ad271de1939d3f1a5520"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aba69db64fe38ad271de1939d3f1a5520">keycpp::input</a> (const std::string &amp;prompt, std::string option)</td></tr>
<tr class="memdesc:aba69db64fe38ad271de1939d3f1a5520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the prompt to the screen and then waits for user input. Currently the option must be supplied as "s" because C++ is a statically typed language. <br/></td></tr>
<tr class="separator:aba69db64fe38ad271de1939d3f1a5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bca7924aad17a920f2f5f0606e6d9a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a4bca7924aad17a920f2f5f0606e6d9a9">keycpp::str2num</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::string to a double. Currently only works on single numbers. In the future this should be expanded to work on vectors and matrices. (see MATLAB docs) <br/></td></tr>
<tr class="separator:a4bca7924aad17a920f2f5f0606e6d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c30ad952d4422425a171c12bdf33947"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c30ad952d4422425a171c12bdf33947"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c30ad952d4422425a171c12bdf33947"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9c30ad952d4422425a171c12bdf33947">keycpp::length</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9c30ad952d4422425a171c12bdf33947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the largest dimension of A. <br/></td></tr>
<tr class="separator:a9c30ad952d4422425a171c12bdf33947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adcbcd3d38aa0721f2556422eb06cad7d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::numel</b> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:adcbcd3d38aa0721f2556422eb06cad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2731f68b07dddedc5d572a409ba9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ff2731f68b07dddedc5d572a409ba9e"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a1ff2731f68b07dddedc5d572a409ba9e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; size_t, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a1ff2731f68b07dddedc5d572a409ba9e">keycpp::find</a> (const matrix&lt; T, dim &gt; &amp;v1, const size_t &amp;k=-1, std::string start=&quot;&quot;)</td></tr>
<tr class="memdesc:a1ff2731f68b07dddedc5d572a409ba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the indices of non-zero elements of v1. <br/></td></tr>
<tr class="separator:a1ff2731f68b07dddedc5d572a409ba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6462a878df6e022bd4f9aa6f953983"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e6462a878df6e022bd4f9aa6f953983"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e6462a878df6e022bd4f9aa6f953983"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::reshape</b> (const matrix&lt; T &gt; &amp;A, const size_t &amp;m, const size_t &amp;n)</td></tr>
<tr class="separator:a8e6462a878df6e022bd4f9aa6f953983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6ec70ba46d1d830acf7fbf8b8b97e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67c6ec70ba46d1d830acf7fbf8b8b97e"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a67c6ec70ba46d1d830acf7fbf8b8b97e"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a67c6ec70ba46d1d830acf7fbf8b8b97e">keycpp::dot</a> (const matrix&lt; T &gt; &amp;A, const matrix&lt; U &gt; &amp;B, const size_t &amp;dim=-1)</td></tr>
<tr class="memdesc:a67c6ec70ba46d1d830acf7fbf8b8b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between the first non-singleton dimension of A and B. <br/></td></tr>
<tr class="separator:a67c6ec70ba46d1d830acf7fbf8b8b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157ec9804a57367b3153fb3cc81f9224"><td class="memTemplParams" colspan="2"><a class="anchor" id="a157ec9804a57367b3153fb3cc81f9224"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a157ec9804a57367b3153fb3cc81f9224"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; decltype(std::declval<br class="typebreak"/>
&lt; T &gt;)*std::declval&lt; U &gt;))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a157ec9804a57367b3153fb3cc81f9224">keycpp::cross</a> (const matrix&lt; T &gt; &amp;v1, const matrix&lt; U &gt; &amp;v2)</td></tr>
<tr class="memdesc:a157ec9804a57367b3153fb3cc81f9224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product between vectors v1 and v2. Both vectors must have exactly 3 elements. <br/></td></tr>
<tr class="separator:a157ec9804a57367b3153fb3cc81f9224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ba102c379ceaa8bfa814ecfa095a56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6ba102c379ceaa8bfa814ecfa095a56"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; double, 2, 0 &gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:af6ba102c379ceaa8bfa814ecfa095a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838fc93d66e1ab63d68d04781086d81a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a838fc93d66e1ab63d68d04781086d81a"></a>
SVD_type&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a838fc93d66e1ab63d68d04781086d81a">keycpp::svd</a> (const matrix&lt; double &gt; &amp;A_in, std::string method)</td></tr>
<tr class="memdesc:a838fc93d66e1ab63d68d04781086d81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:a838fc93d66e1ab63d68d04781086d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00bd96e42ccdc9faabc117b829f325"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d00bd96e42ccdc9faabc117b829f325"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::norm</b> (const matrix&lt; std::complex&lt; double &gt;, 2, 0 &gt; &amp;A_in, std::string method=&quot;2&quot;)</td></tr>
<tr class="separator:a3d00bd96e42ccdc9faabc117b829f325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610adca37ac4c85df23b899d29d5dfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad610adca37ac4c85df23b899d29d5dfc"></a>
SVD_type&lt; std::complex&lt; double &gt;<br class="typebreak"/>
, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ad610adca37ac4c85df23b899d29d5dfc">keycpp::svd</a> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, std::string method)</td></tr>
<tr class="memdesc:ad610adca37ac4c85df23b899d29d5dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of matrix A_in. <br/></td></tr>
<tr class="separator:ad610adca37ac4c85df23b899d29d5dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb9efbc77cc58fa22403ea7ae5f4555c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aeb9efbc77cc58fa22403ea7ae5f4555c">keycpp::rank</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the rank of a matrix by counting the singular values whose absolute value is greater than epsilon. <br/></td></tr>
<tr class="separator:aeb9efbc77cc58fa22403ea7ae5f4555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f497e2da901adba0e1257be943595a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f497e2da901adba0e1257be943595a1"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8f497e2da901adba0e1257be943595a1">keycpp::null</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8f497e2da901adba0e1257be943595a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of matrix A. <br/></td></tr>
<tr class="separator:a8f497e2da901adba0e1257be943595a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70b89ab3e8f66f86c47c3bde004d4487"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a70b89ab3e8f66f86c47c3bde004d4487">keycpp::any</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a70b89ab3e8f66f86c47c3bde004d4487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:a70b89ab3e8f66f86c47c3bde004d4487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c36622975d56232740753ada20b9f86"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c36622975d56232740753ada20b9f86"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a7c36622975d56232740753ada20b9f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a7c36622975d56232740753ada20b9f86">keycpp::any</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a7c36622975d56232740753ada20b9f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any elements of A are nonzero. <br/></td></tr>
<tr class="separator:a7c36622975d56232740753ada20b9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab77d82d9cc7d1fcca87967048f09e0e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aab77d82d9cc7d1fcca87967048f09e0e">keycpp::all</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aab77d82d9cc7d1fcca87967048f09e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is nonzero. <br/></td></tr>
<tr class="separator:aab77d82d9cc7d1fcca87967048f09e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bc3707493ba61f2165a189e7cbafd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a30bc3707493ba61f2165a189e7cbafd4"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a30bc3707493ba61f2165a189e7cbafd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a30bc3707493ba61f2165a189e7cbafd4">keycpp::all</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a30bc3707493ba61f2165a189e7cbafd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are nonzero. <br/></td></tr>
<tr class="separator:a30bc3707493ba61f2165a189e7cbafd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60465b61314a3baea857cf9d3579524"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac60465b61314a3baea857cf9d3579524"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac60465b61314a3baea857cf9d3579524"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac60465b61314a3baea857cf9d3579524">keycpp::finite</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ac60465b61314a3baea857cf9d3579524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is finite. <br/></td></tr>
<tr class="separator:ac60465b61314a3baea857cf9d3579524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f1d1e201235ae75156016fc5b7edf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a047f1d1e201235ae75156016fc5b7edf"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a047f1d1e201235ae75156016fc5b7edf"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a047f1d1e201235ae75156016fc5b7edf">keycpp::finite</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a047f1d1e201235ae75156016fc5b7edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are finite. <br/></td></tr>
<tr class="separator:a047f1d1e201235ae75156016fc5b7edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852be6145adcca15ceaeb5a138651e20"><td class="memTemplParams" colspan="2"><a class="anchor" id="a852be6145adcca15ceaeb5a138651e20"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a852be6145adcca15ceaeb5a138651e20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a852be6145adcca15ceaeb5a138651e20">keycpp::isinf</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a852be6145adcca15ceaeb5a138651e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean value that is true if a is infinite. <br/></td></tr>
<tr class="separator:a852be6145adcca15ceaeb5a138651e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c5ce0dc3b7ec19ec18f3bbc21d4f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a606c5ce0dc3b7ec19ec18f3bbc21d4f2"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a606c5ce0dc3b7ec19ec18f3bbc21d4f2"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a606c5ce0dc3b7ec19ec18f3bbc21d4f2">keycpp::isinf</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a606c5ce0dc3b7ec19ec18f3bbc21d4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix containing boolean values that are true if corresponding elements of A are infinite. <br/></td></tr>
<tr class="separator:a606c5ce0dc3b7ec19ec18f3bbc21d4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc2de8926c54a2048a0d8965e7d70995"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acc2de8926c54a2048a0d8965e7d70995"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#acc2de8926c54a2048a0d8965e7d70995">keycpp::isempty</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:acc2de8926c54a2048a0d8965e7d70995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix is empty. <br/></td></tr>
<tr class="separator:acc2de8926c54a2048a0d8965e7d70995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81a8c955cdbeb60181f6bf7d6553ac53"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a81a8c955cdbeb60181f6bf7d6553ac53">keycpp::isreal</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is real. <br/></td></tr>
<tr class="separator:a81a8c955cdbeb60181f6bf7d6553ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1342fad8b0d8f26c4acc9a65b7ec2dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1342fad8b0d8f26c4acc9a65b7ec2dd"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:af1342fad8b0d8f26c4acc9a65b7ec2dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af1342fad8b0d8f26c4acc9a65b7ec2dd">keycpp::isreal</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:af1342fad8b0d8f26c4acc9a65b7ec2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements of A are real. <br/></td></tr>
<tr class="separator:af1342fad8b0d8f26c4acc9a65b7ec2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005c1190f7087fb1d2545c38c080fd1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005c1190f7087fb1d2545c38c080fd1a"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a005c1190f7087fb1d2545c38c080fd1a">keycpp::ceil</a> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="memdesc:a005c1190f7087fb1d2545c38c080fd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the real and imaginary parts of std::complex&lt;double&gt; a towards positive infinity seperately. <br/></td></tr>
<tr class="separator:a005c1190f7087fb1d2545c38c080fd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f75eb747c57c3e5ff91323f65a02b5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f75eb747c57c3e5ff91323f65a02b5f"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a6f75eb747c57c3e5ff91323f65a02b5f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6f75eb747c57c3e5ff91323f65a02b5f">keycpp::ceil</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a6f75eb747c57c3e5ff91323f65a02b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of A towards positive infinity. <br/></td></tr>
<tr class="separator:a6f75eb747c57c3e5ff91323f65a02b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30437496fbd2011521b31aee7961516"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab30437496fbd2011521b31aee7961516"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab30437496fbd2011521b31aee7961516">keycpp::floor</a> (const std::complex&lt; double &gt; &amp;a)</td></tr>
<tr class="memdesc:ab30437496fbd2011521b31aee7961516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the real and imaginary parts of std::complex&lt;double&gt; a towards negative infinity seperately. <br/></td></tr>
<tr class="separator:ab30437496fbd2011521b31aee7961516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad0f0ac8036ee114a14da17aefcb5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8aad0f0ac8036ee114a14da17aefcb5f"></a>
template&lt;class T , size_t dim&gt; </td></tr>
<tr class="memitem:a8aad0f0ac8036ee114a14da17aefcb5f"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8aad0f0ac8036ee114a14da17aefcb5f">keycpp::floor</a> (const matrix&lt; T, dim &gt; &amp;A)</td></tr>
<tr class="memdesc:a8aad0f0ac8036ee114a14da17aefcb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of A towards negative infinity. <br/></td></tr>
<tr class="separator:a8aad0f0ac8036ee114a14da17aefcb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d215fa6882ff492cec0c3958fabadb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5d215fa6882ff492cec0c3958fabadb"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad5d215fa6882ff492cec0c3958fabadb"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; T &gt;<br class="typebreak"/>
()*std::declval&lt; U &gt;())&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::polyval</b> (const matrix&lt; T, 2 &gt; &amp;p, const U &amp;x)</td></tr>
<tr class="separator:ad5d215fa6882ff492cec0c3958fabadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ba1fe24c04df74326c1289f82fe980"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11ba1fe24c04df74326c1289f82fe980"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a11ba1fe24c04df74326c1289f82fe980"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a11ba1fe24c04df74326c1289f82fe980">keycpp::roots</a> (const matrix&lt; T, 2 &gt; &amp;p)</td></tr>
<tr class="memdesc:a11ba1fe24c04df74326c1289f82fe980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all roots of polynomial p by solving for the eigenvalues of the companion matrix. <br/></td></tr>
<tr class="separator:a11ba1fe24c04df74326c1289f82fe980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6069a9eec0edfa1d401230013d98765e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6069a9eec0edfa1d401230013d98765e"></a>
tictoc_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a6069a9eec0edfa1d401230013d98765e">keycpp::tic</a> ()</td></tr>
<tr class="memdesc:a6069a9eec0edfa1d401230013d98765e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the timer. <br/></td></tr>
<tr class="separator:a6069a9eec0edfa1d401230013d98765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe03fbbb5126729fb4b9367097acb1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe03fbbb5126729fb4b9367097acb1d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#afe03fbbb5126729fb4b9367097acb1d1">keycpp::toc</a> (tictoc_type &amp;Timer)</td></tr>
<tr class="memdesc:afe03fbbb5126729fb4b9367097acb1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the timer. The number of elapsed seconds is returned. <br/></td></tr>
<tr class="separator:afe03fbbb5126729fb4b9367097acb1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d70a761d33bbc2bdec6b4e0eb43d517"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517">keycpp::sprintf</a> (const std::string &amp;fmt,...)</td></tr>
<tr class="memdesc:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the C++ function <a class="el" href="namespacekeycpp.html#a9d70a761d33bbc2bdec6b4e0eb43d517" title="Overload of the C++ function sprintf(). This overload provides a more MATLAB-like interface...">sprintf()</a>. This overload provides a more MATLAB-like interface. Specifically, the output is returned instead of passed by reference. <br/></td></tr>
<tr class="separator:a9d70a761d33bbc2bdec6b4e0eb43d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa002278cc556c656aab5b157e81017b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa002278cc556c656aab5b157e81017b6"></a>
matrix&lt; size_t, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#aa002278cc556c656aab5b157e81017b6">keycpp::clock</a> ()</td></tr>
<tr class="memdesc:aa002278cc556c656aab5b157e81017b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of integers containing the current: year, month, day, hour, minute, and second. This is based on the system clock. The number of hours is based on the 24-hour clock. <br/></td></tr>
<tr class="separator:aa002278cc556c656aab5b157e81017b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac20bd2ef4fb18cbcdb0f462a89447bd7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac20bd2ef4fb18cbcdb0f462a89447bd7">keycpp::pinv</a> (const matrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Moore-Penrose Pseudoinverse of matrix A. Currently only the SVD method is implemented. This restricts matrix A to be only square matrices. This is currently slower than inv(), use with care. <br/></td></tr>
<tr class="separator:ac20bd2ef4fb18cbcdb0f462a89447bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70d9156c4b6a75e5b7a4c799f900162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad70d9156c4b6a75e5b7a4c799f900162"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::removeWhiteSpace</b> (std::string in)</td></tr>
<tr class="separator:ad70d9156c4b6a75e5b7a4c799f900162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c0a8bc58229a412ec2068979b6b84e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c0a8bc58229a412ec2068979b6b84e"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac5c0a8bc58229a412ec2068979b6b84e">keycpp::importdata</a> (std::string filename)</td></tr>
<tr class="memdesc:ac5c0a8bc58229a412ec2068979b6b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the data read from a text file. Values must be white space separated. <br/></td></tr>
<tr class="separator:ac5c0a8bc58229a412ec2068979b6b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126bda3ea87f21535d3a5da6587985dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a126bda3ea87f21535d3a5da6587985dc"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a126bda3ea87f21535d3a5da6587985dc">keycpp::importdata_complex</a> (std::string filename)</td></tr>
<tr class="memdesc:a126bda3ea87f21535d3a5da6587985dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the data read from a text file. Values must be white space separated. <br/></td></tr>
<tr class="separator:a126bda3ea87f21535d3a5da6587985dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b54cb009afd7217ea23f1778021c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada4b54cb009afd7217ea23f1778021c1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ada4b54cb009afd7217ea23f1778021c1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ada4b54cb009afd7217ea23f1778021c1">keycpp::stdev</a> (matrix&lt; T, 2 &gt; v1)</td></tr>
<tr class="memdesc:ada4b54cb009afd7217ea23f1778021c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of inputed vector. <br/></td></tr>
<tr class="separator:ada4b54cb009afd7217ea23f1778021c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3742d74c104a006f442440544dbc22e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3742d74c104a006f442440544dbc22e8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a3742d74c104a006f442440544dbc22e8">keycpp::stdev</a> (matrix&lt; std::complex&lt; double &gt;, 2 &gt; v1)</td></tr>
<tr class="memdesc:a3742d74c104a006f442440544dbc22e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of inputed vector. <br/></td></tr>
<tr class="separator:a3742d74c104a006f442440544dbc22e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce2d2a4c296ae28d1081f4345c3a947"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ce2d2a4c296ae28d1081f4345c3a947"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ce2d2a4c296ae28d1081f4345c3a947"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a8ce2d2a4c296ae28d1081f4345c3a947">keycpp::var</a> (matrix&lt; T, 2 &gt; v1)</td></tr>
<tr class="memdesc:a8ce2d2a4c296ae28d1081f4345c3a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variance (square of standard deviation) for inputed vector. <br/></td></tr>
<tr class="separator:a8ce2d2a4c296ae28d1081f4345c3a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94ac14515f1da6cebf6f5d924bd1a35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac94ac14515f1da6cebf6f5d924bd1a35"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ac94ac14515f1da6cebf6f5d924bd1a35">keycpp::var</a> (matrix&lt; std::complex&lt; double &gt;, 2 &gt; v1)</td></tr>
<tr class="memdesc:ac94ac14515f1da6cebf6f5d924bd1a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variance (square of standard deviation) for inputed vector. <br/></td></tr>
<tr class="separator:ac94ac14515f1da6cebf6f5d924bd1a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88845cbf85d741821f7d14f97dd1a61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88845cbf85d741821f7d14f97dd1a61"></a>
int &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rng_ns::getChoice</b> ()</td></tr>
<tr class="separator:ad88845cbf85d741821f7d14f97dd1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb757fbaa111ecb5c44c51a913609d19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb757fbaa111ecb5c44c51a913609d19"></a>
std::mt19937 &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rng_ns::get_mt_rng</b> ()</td></tr>
<tr class="separator:afb757fbaa111ecb5c44c51a913609d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6bcfb063a993212a2241fa4b722bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf6bcfb063a993212a2241fa4b722bc"></a>
std::ranlux24_base &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rng_ns::get_lagfib_rng</b> ()</td></tr>
<tr class="separator:a6cf6bcfb063a993212a2241fa4b722bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e133b94bc27c9b984d0383b01772d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e133b94bc27c9b984d0383b01772d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rng</b> (size_t seed=0, std::string generator=&quot;twister&quot;)</td></tr>
<tr class="separator:a93e133b94bc27c9b984d0383b01772d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2478c69f713d8664b53d31f25718530"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2478c69f713d8664b53d31f25718530"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::rng</b> (std::string shuffle=&quot;&quot;, std::string generator=&quot;&quot;)</td></tr>
<tr class="separator:af2478c69f713d8664b53d31f25718530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef5c1f5951e8182a7c4ec9612f3f7e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a5ef5c1f5951e8182a7c4ec9612f3f7e1">keycpp::rand</a> ()</td></tr>
<tr class="memdesc:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double between 0 and 1.0. <br/></td></tr>
<tr class="separator:a5ef5c1f5951e8182a7c4ec9612f3f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a9561cf5654ae722a0879b41d9d73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab99a9561cf5654ae722a0879b41d9d73"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#ab99a9561cf5654ae722a0879b41d9d73">keycpp::rand</a> (const unsigned int &amp;N)</td></tr>
<tr class="memdesc:ab99a9561cf5654ae722a0879b41d9d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an N x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:ab99a9561cf5654ae722a0879b41d9d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6413232f2de6f8ac96efde6531c3055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6413232f2de6f8ac96efde6531c3055"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#af6413232f2de6f8ac96efde6531c3055">keycpp::rand</a> (const unsigned int &amp;M, const unsigned int &amp;N)</td></tr>
<tr class="memdesc:af6413232f2de6f8ac96efde6531c3055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an M x N matrix of random doubles between 0 and 1.0. <br/></td></tr>
<tr class="separator:af6413232f2de6f8ac96efde6531c3055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb4c27d8c550f3a522dcd4334986161"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb4c27d8c550f3a522dcd4334986161"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::randn</b> ()</td></tr>
<tr class="separator:abbb4c27d8c550f3a522dcd4334986161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55434470472a4b6c511e5a713a4d654"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55434470472a4b6c511e5a713a4d654"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::randn</b> (const unsigned int &amp;N)</td></tr>
<tr class="separator:ab55434470472a4b6c511e5a713a4d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bbf0f2c5e3c68a4e03abcce5aa63da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43bbf0f2c5e3c68a4e03abcce5aa63da"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::randn</b> (const unsigned int &amp;M, const unsigned int &amp;N)</td></tr>
<tr class="separator:a43bbf0f2c5e3c68a4e03abcce5aa63da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eb4ea6f5e22409e718cfd24de6c17a"><td class="memItemLeft" align="right" valign="top">matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekeycpp.html#a11eb4ea6f5e22409e718cfd24de6c17a">keycpp::eig</a> (const matrix&lt; double &gt; &amp;A, matrix&lt; std::complex&lt; double &gt; &gt; *vr_return, matrix&lt; std::complex&lt; double &gt; &gt; *vl_return)</td></tr>
<tr class="memdesc:a11eb4ea6f5e22409e718cfd24de6c17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double precision eigenvalue solver using LAPACK function call.  <a href="#a11eb4ea6f5e22409e718cfd24de6c17a">More...</a><br/></td></tr>
<tr class="separator:a11eb4ea6f5e22409e718cfd24de6c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa715d09dd31ec18be5cd455c216faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fa715d09dd31ec18be5cd455c216faa"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::lu</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in)</td></tr>
<tr class="separator:a5fa715d09dd31ec18be5cd455c216faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e9ba154bce04912b775584590b4815"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e9ba154bce04912b775584590b4815"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::lu</b> (const matrix&lt; double &gt; &amp;A_in)</td></tr>
<tr class="separator:ac6e9ba154bce04912b775584590b4815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870bd38d5e2dbf79da93073b9d2d5d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a870bd38d5e2dbf79da93073b9d2d5d9e"></a>
matrix&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::lu</b> (const matrix&lt; std::complex&lt; double &gt;&gt; &amp;A_in, int *iw)</td></tr>
<tr class="separator:a870bd38d5e2dbf79da93073b9d2d5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ada4f2aa379b6d31cf0a4e1453f809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ada4f2aa379b6d31cf0a4e1453f809"></a>
matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keycpp::lu</b> (const matrix&lt; double &gt; &amp;A_in, int *iw)</td></tr>
<tr class="separator:ac6ada4f2aa379b6d31cf0a4e1453f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6eeb7d95bad691033adf85020becc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29c6eeb7d95bad691033adf85020becc"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a29c6eeb7d95bad691033adf85020becc"><td class="memTemplItemLeft" align="right" valign="top">meshgrid_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keycpp::meshgrid</b> (const matrix&lt; T &gt; &amp;x, const matrix&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:a29c6eeb7d95bad691033adf85020becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 2 2014 15:59:16 for KeyCpp -- A MATLAB-like library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
